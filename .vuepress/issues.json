[
  {
    "id": "MDU6SXNzdWU1MTYwNTcyNDA=",
    "number": 1,
    "title": "【Q001】网站开发中，如何实现图片的懒加载",
    "body": "网站开发中，如何实现图片的懒加载，随着 web 技术的发展，他有没有一些更好的方案",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
        "name": "html"
      },
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU0OTEzMzE0NQ==",
      "body": "懒加载，顾名思义，在当前网页，滑动页面到能看到图片的时候再加载图片\r\n\r\n故问题拆分成两个：\r\n\r\n1. 如何判断图片出现在了当前视口 （即如何判断我们能够看到图片）\r\n2. 如何控制图片的加载\r\n\r\n## 方案一: 位置计算 + 滚动事件 (Scroll) + DataSet API\r\n\r\n### 如何判断图片出现在了当前视口\r\n\r\n`clientTop`，`offsetTop`，`clientHeight` 以及 `scrollTop` 各种关于图片的高度作比对\r\n\r\n这些高度都代表了什么意思？\r\n\r\n这我以前有可能是知道的，那时候我比较单纯，喜欢死磕。我现在想通了，背不过的东西就不要背了\r\n\r\n**所以它有一个问题：复杂琐碎不好理解！**\r\n\r\n仅仅知道它静态的高度还不够，我们还需要知道动态的\r\n\r\n**如何动态？监听 `window.scroll` 事件**\r\n\r\n### 如何控制图片的加载\r\n\r\n``` html\r\n<img data-src=\"shanyue.jpg\">\r\n```\r\n\r\n首先设置一个临时 Data 属性 `data-src`，控制加载时使用 `src` 代替 `data-src`，可利用 DataSet API 实现\r\n\r\n``` html\r\nimg.src = img.datset.src\r\n```\r\n\r\n## 方案二: getBoundingClientRect API + Scroll with Throttle + DataSet API\r\n\r\n改进一下\r\n\r\n### 如何判断图片出现在了当前视口\r\n\r\n引入一个新的 API， **`Element.getBoundingClientRect()` 方法返回元素的大小及其相对于视口的位置。**\r\n\r\n<img alt=\"getBoundingClientRect示例图\" src=\"https://mdn.mozillademos.org/files/15087/rect.png\">\r\n\r\n那如何判断图片出现在了当前视口呢，根据示例图示意，代码如下，这个就比较好理解了，就可以很容易地背会(就可以愉快地去面试了)。\r\n\r\n``` js\r\n// clientHeight 代表当前视口的高度\r\nimg.getBoundingClientRect().top < document.documentElement.clientHeight\r\n```\r\n\r\n**监听 `window.scroll` 事件也优化一下**\r\n\r\n加个节流器，提高性能。工作中一般使用 `lodash.throttle` 就可以了，万能的 `lodash` 啊！\r\n\r\n``` js\r\n_.throttle(func, [wait=0], [options={}])\r\n```\r\n\r\n参考 [什么是防抖和节流，他们的应用场景有哪些](https://github.com/shfshanyue/Daily-Question/issues/3)，或者[前端面试题](https://q.shanyue.tech/fe/js/3.html)\r\n\r\n## 方案三: IntersectionObserver API + DataSet API\r\n\r\n再改进一下\r\n\r\n### 如何判断图片出现在了当前视口\r\n\r\n**方案二使用的方法是: `window.scroll` 监听 `Element.getBoundingClientRect()` 并使用 `_.throttle` 节流**\r\n\r\n**一系列组合动作太复杂了，于是浏览器出了一个三合一事件: `IntersectionObserver` API，一个能够监听元素是否到了当前视口的事件，一步到位！**\r\n\r\n事件回调的参数是 [IntersectionObserverEntry](https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry) 的集合，代表关于是否在可见视口的一系列值\r\n\r\n其中，`entry.isIntersecting` 代表目标元素可见\r\n\r\n``` javascript\r\nconst observer = new IntersectionObserver((changes) => {\r\n  // changes: 目标元素集合\r\n  changes.forEach((change) => {\r\n    // intersectionRatio\r\n    if (change.isIntersecting) {\r\n      const img = change.target\r\n      img.src = img.dataset.src\r\n      observer.unobserve(img)\r\n    }\r\n  })\r\n})\r\n\r\nobserver.observe(img)\r\n```\r\n\r\n**当然，`IntersectionObserver` 除了给图片做懒加载外，还可以对单页应用资源做预加载。**\r\n\r\n如在 `next.js v9` 中，会对视口内的资源做预加载，可以参考 [next 9 production optimizations](https://nextjs.org/blog/next-9#production-optimizations)\r\n\r\n``` jsx\r\n<Link href=\"/about\">\r\n  <a>关于山月</a>\r\n</Link>\r\n```\r\n\r\n## 方案四: LazyLoading属性\r\n\r\n浏览器觉得懒加载这事可以交给自己做，你们开发者加个属性就好了。实在是...！\r\n\r\n``` html\r\n<img src=\"shanyue.jpg\" loading=\"lazy\">\r\n```\r\n\r\n不过目前浏览器兼容性不太好，关于 `loading` 属性的文章也可以查看 [Native image lazy-loading for the web!](https://addyosmani.com/blog/lazy-loading/)\r\n",
      "star": {
        "totalCount": 8
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MTY0MjgxNDI=",
    "number": 2,
    "title": "【Q002】当 ping 一个 IP 地址时发生了什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
        "name": "network"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU0OTMzNjQ4Nw==",
      "body": "从 `ping` 的 `man` 手册就可以看出来，`ping` 实际上发送了 **`ICMP ECHO_REQUEST`** 的报文\r\n\r\n> ping -- send ICMP ECHO_REQUEST packets to network hosts\r\n\r\n通过让目标 IP 地址返回 **`ICMP ECHO_RESPONSE`** 报文来判断 IP 可不可达。\r\n\r\n`ICMP` 分为 `Query` 查询报文及 `Error Message` 报文，ping 为查询报文。",
      "star": {
        "totalCount": 3
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MTY4MTUzMjA=",
    "number": 3,
    "title": "【Q003】什么是防抖和节流，他们的应用场景有哪些",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2NDM3MTU0MA==",
      "body": "####  防抖(debounce)\r\n触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间\r\n\r\n##### 示例代码\r\n```javascript\r\n    // 防抖函数\r\n    function debounce(fn, wait) {\r\n        let timer;\r\n        return function() {\r\n            let _this = this;\r\n            let args = arguments;\r\n            if(timer) { clearTimeout(timer) }\r\n            timer = setTimeout(function(){\r\n                fn.apply(_this, args)\r\n            }, wait);      \r\n        }\r\n    }\r\n    // 使用\r\n    window.onresize = debounce(function() {console.log('resize')}, 500)\r\n```\r\n\r\n#### 节流(throttle)\r\n高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率\r\n##### 示例代码\r\n\r\n```javascript\r\n    // 方式1: 使用时间戳\r\n    function throttle1(fn, wait) {\r\n        let time = 0;\r\n        return function() {\r\n            let _this = this;\r\n            let args = arguments;\r\n            let now = Date.now()\r\n            if(now - time > wait) {\r\n                fn.apply(_this, args);\r\n                time = now;\r\n            }\r\n        }\r\n    }\r\n    // 方式2: 使用定时器\r\n    function thorttle2(fn, wait) {\r\n        let timer;\r\n        return function () {\r\n            let _this = this;\r\n            let args = arguments;\r\n            \r\n            if(!timer) {\r\n                timer = setTimeout(function(){\r\n                    timer = null;\r\n                    fn.apply(_this, args)\r\n                }, wait)\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\n上面`节流`和`防抖`实现方式比较简单，但是已经可以满足日常使用，如果想更近一步了解可以查看[underscore](https://www.bootcss.com/p/underscore/)和[lodash](https://www.lodashjs.com/docs/latest)文档中`debounce`和`thorttle`",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "xiaoai7904",
        "url": "https://github.com/xiaoai7904"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MTY4MTU2NzM=",
    "number": 4,
    "title": "【Q004】如何获取一个进程的内存并监控",
    "body": "在编写脚本时，有时会出现内存过大发生 OOM 的事情，那我们如何得知某个进程的内存？另外又如何监控它",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU0OTM0MjE4MQ==",
      "body": "通过 `ps` 可以获知一个进程所占用的内存\r\n\r\n``` bash\r\n$ ps -O rss -p 3506\r\n  PID   RSS S TTY          TIME COMMAND\r\n 3506  6984 S pts/1    00:00:00 vim\r\n```\r\n\r\n如果要**监控**内存，需要使用对进程万能的命令 `pidstat` （PS: 这名字一听就知道是干嘛的）\r\n\r\n``` bash\r\n# -r 显示内存信息\r\n# -p 指定 pid\r\n# 1: 每个一秒打印一次\r\n$ pidstat -r -p 3506 1\r\nLinux 3.10.0-957.21.3.el7.x86_64 (shanyue)      11/04/19        _x86_64_        (2 CPU)\r\n\r\n20:47:35      UID       PID  minflt/s  majflt/s     VSZ    RSS   %MEM  Command\r\n20:47:36        0      3506      0.00      0.00  139940   6984   0.18  vim\r\n20:47:37        0      3506      0.00      0.00  139940   6984   0.18  vim\r\n20:47:38        0      3506      0.00      0.00  139940   6984   0.18  vim\r\n20:47:39        0      3506      0.00      0.00  139940   6984   0.18  vim\r\n20:47:40        0      3506      0.00      0.00  139940   6984   0.18  vim\r\n20:47:41        0      3506      0.00      0.00  139940   6984   0.18  vim\r\n```\r\n\r\n`pidstat` 是属于 `sysstat` 下的 linux 性能工具，但在 mac 中，如何定位内存的变化？此时可以使用万能的 `top/htop`\r\n\r\n ``` bash\r\n $ htop -p 31796\r\n ```\r\n\r\n![image](https://user-images.githubusercontent.com/13389461/86353210-7b210080-bc99-11ea-9885-8e5ca1b909b5.png)\r\n\r\n## 总结\r\n\r\n简而言之，有以下三个命令\r\n\r\n1. `pidstat -r`，只在 linux 环境下使用\r\n1. `htop/top -p`\r\n1. `ps -O rss -p`\r\n\r\n关于更多指标的监控可以参考我的文章: [linux 各项监控指标小记](https://shanyue.tech/op/linux-monitor.html)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MTY4MTY0NDM=",
    "number": 6,
    "title": "【Q005】生产环境的某个接口报错，如何定位",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU0OTM0NTU1Ng==",
      "body": "通常按照以下步骤进行定位\r\n\r\n1. 测试环境是否能够复现，若复现在测试环境测试并修复\r\n1. 有没有异常报警系统，如 `sentry`，如果有在 `sentry` 中查看异常堆栈信息以及相关上下文，定位代码\r\n1. 如果堆栈信息不足够找到问题，看有没有链路追踪工具，如 `zipkin`。从 `sentry` 中找到 `requestId/traceId`，通过 `requestId` 结合 `kibana` / `ElasticSearch` 定位相关的数据库日志/上下游服务链路日志\r\n1. 如果以上都不行，查看接口相关代码\r\n\r\n既然报错，那么一定会在异常上报系统中找到这条问题进行定位。如果在报警系统中没有定位到问题，可以查看\r\n\r\n1. 报警系统是否已限流，致使无法上报\r\n1. 复现异常时，抓包查看报警相关的 API，查看是否已上报\r\n\r\n最怕的是那种接口没报错，但是业务方反馈数据有误的问题了，只能开了 debug，进行代码调试了",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MTY5MjM2NzU=",
    "number": 7,
    "title": "【Q006】如何写一个 SQL 获取分组 top n 的数据",
    "body": "一个学校中的每个学生属于一个班级，如何获取每个班的前三名\r\n\r\n假设有学生表 `student(id, score, class_id)`，`score` 代表分数，`class_id` 代表班级，如何写出 SQL 取每个班级分数前三名",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU0OTIzNDQxOQ==",
      "body": "通过一个自连接可以获取到\r\n\r\n``` sql\r\nselect id, class_id, score from student s1 where (\r\n  -- 对比每行 student，通过自连接找到该班中比该 student 分数要高与等于的人数，即排名\r\n  select count(*) from student s2 where s2.class_id = s1.class_id and s2.score >= s1.score\r\n) = 1\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MTY5ODg0NTQ=",
    "number": 8,
    "title": "【Q007】如何写一个 SQL 获取分组 top 1 的数据 ",
    "body": "一个学校中的每个学生属于一个班级，如何获取每个班的前三名\r\n\r\n假设有学生表 `student(id, score, class_id)`，`score` 代表分数，`class_id` 代表班级，如何写出 SQL 取每个班级分数前一名\r\n\r\n与 [Top n](https://github.com/shfshanyue/Daily-Question/issues/7) 类似，不过有更简单的方法\r\n\r\n（当然考虑到并列情况就会复杂很多",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU0OTM0MzI2OA==",
      "body": "单纯的获取 Top 1，只需要 `group by` 加聚合函数，不过复杂的还是参考 [top n](https://github.com/shfshanyue/Daily-Question/issues/7)\r\n\r\n``` sql\r\nselect class_id, max(score) from student group by class_id\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MTY5OTQ0NTk=",
    "number": 9,
    "title": "【Q008】当新入职一家公司时，如何快速搭建开发环境并让应用跑起来",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
        "name": "devops"
      },
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      },
      {
        "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
        "name": "vue"
      },
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU0OTM1MTAyOA==",
      "body": "新人入职新上手项目，如何把它跑起来，这是所有人都会碰到的问题：所有人都是从新手开始的。\r\n\r\n有可能你会脱口而出：`npm run dev/npm start`，但实际工作中，处处藏坑，往往没这么简单。\r\n\r\n1. 查看是否有 `CI/CD`，如果有跟着 `CI/CD` 部署的脚本跑命令\r\n1. 查看是否有 `dockerfile`，如果有跟着 `dockerfile` 跑命令\r\n1. 查看 npm scripts 中是否有 dev/start，尝试 `npm run dev/npm start`\r\n1. 查看是否有文档，如果有跟着文档走。为啥要把文档放到最后一个？原因你懂的\r\n\r\n但即便是十分谨慎，也有可能遇到以下几个叫苦不迭、浪费了一下午时间的坑:\r\n\r\n1. 前端有可能在**本地环境启动时需要依赖前端构建时所产生的文件**，所以有时需要**先正常部署一遍，再试着按照本地环境启动 (即需要先 `npm run build` 一下，再 `npm run dev/npm start`)**。(比如，一次我们的项目 npm run dev 时需要 webpack DllPlugin 构建后的东西）\r\n1. 别忘了设置环境变量或者配置文件 (.env/consul/k8s-configmap)\r\n\r\n因此，设置一个少的 script，可以很好地避免后人踩坑，更重要的是，可以避免后人骂你，\r\n\r\n此时可设置 script hooks，如 `prepare`、`postinstall` 自动执行脚本，来完善该项目的基础设施\r\n\r\n``` json\r\n{\r\n  \"scripts\": {\r\n    \"start\": \"npm run dev\",\r\n    \"config\": \"node assets && node config\",\r\n    \"build\": \"webpack\",\r\n    // 设置一个钩子，在 npm install 后自动执行，此处有可能不是必须的\r\n    \"prepare\": \"npm run build\",\r\n    \"dev\": \"webpack-dev-server --inline --progress\"\r\n  }\r\n}\r\n```\r\n\r\n## npm run dev 与 npm start 的区别\r\n\r\n对于一个**纯生成静态页面打包**的前端项目而言，它们是没有多少区别的：生产环境的部署只依赖于构建生成的资源，更不依赖 npm scripts。可见 [如何部署前端项目](https://shanyue.tech/frontend-engineering/docker.html)。\r\n\r\n使用 `create-react-app` 生成的项目，它的 npm script 中只有 `npm start`\r\n\r\n``` json\r\n{\r\n  \"start\": \"react-scripts start\",\r\n  \"build\": \"react-scripts build\",\r\n  \"test\": \"react-scripts test\",\r\n  \"eject\": \"react-scripts eject\"\r\n}\r\n```\r\n\r\n使用 `vuepress` 生成的项目，它的 npm script 中只有 `npm run dev`\r\n\r\n``` json\r\n{\r\n  \"dev\": \"vuepress dev\",\r\n  \"build\": \"vuepress build\"\r\n}\r\n```\r\n\r\n在一个**面向服务端**的项目中，如 `next`、`nuxt` 与 `nest`。dev 与 start 的区别趋于明显，一个为生产环境，一个为开发环境\r\n\r\n+ dev: 在开发环境启动项目，一般带有 watch 选项，监听文件变化而重启服务，此时会耗费大量的 CPU 性能，不宜放在生产环境\r\n+ start: 在生产环境启动项目\r\n\r\n在 `nest` 项目中进行配置\r\n\r\n``` json\r\n{\r\n  \"start\": \"nest start\",\r\n  \"dev\": \"nest start --watch\"\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MTc1ODAwMTc=",
    "number": 10,
    "title": "【Q009】如何实现一个元素的水平垂直居中",
    "body": "要求对行内元素、块状元素及不定宽高的块状元素均可适用：\r\n\r\n可打开 codepen 进行调试: <https://codepen.io/shanyue/pen/XWMdabg>，以下是布局代码\r\n\r\n``` html\r\n<div class=\"container\">\r\n  <div class=\"item\" style=\"width: 100px; height: 100px; background: #999;\">\r\n    块状元素\r\n  </div>\r\n</div>\r\n\r\n<div class=\"container\">\r\n  <div class=\"item\">不定高宽的块状元素</div>\r\n</div>\r\n\r\n<div class=\"container\">\r\n  <span class=\"item\">行内元素</span>\r\n</div>\r\n```\r\n\r\n``` scss\r\n.container {\r\n   // 把代码写在这里\r\n}\r\n\r\n.container {\r\n  height: 20rem;\r\n  background: #ccc;\r\n  margin: 1rem;\r\n}\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1MTEzMjAxNw==",
      "body": "绝对定位方法：\r\n```\r\n.box {\r\n  postion: absolute;\r\n  top: 50%;\r\n  bottom: 50%;\r\n  width: 50px;\r\n  height: 50px;\r\n  transform: translate(-50%, -50%);\r\n}\r\n<body>\r\n<div class=\"box\"><div>\r\n</body>\r\n```\r\n\r\nflex方法：\r\n```\r\nbody {\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n}\r\n.box {\r\n  width: 50px;\r\n  height: 50px;\r\n}\r\n\r\n<body>\r\n<div class=\"box\"><div>\r\n</body>\r\n```",
      "star": {
        "totalCount": 2
      },
      "author": {
        "login": "woohs",
        "url": "https://github.com/woohs"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MTc2MTA0MTY=",
    "number": 11,
    "title": "【Q010】了解 React 中的 ErrorBoundary 吗，它有那些使用场景",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1MzE4Mjg3OQ==",
      "body": "待答",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MTc2MTIxNTM=",
    "number": 12,
    "title": "【Q011】vue3.0 中为什么要使用 Proxy，它相比以前的实现方式有什么改进",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
        "name": "vue"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2NDM3MTk0OQ==",
      "body": "简单描述就是: 性能更好，解决无法监听数组变化问题",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "xiaoai7904",
        "url": "https://github.com/xiaoai7904"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MTgxODk2MDQ=",
    "number": 13,
    "title": "【Q012】helm v3 中为什么要弃用 tiller",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjYwMTIxNDcw",
        "name": "k8s"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1Mjc3NjMxNA==",
      "body": "`helm` v2 中，`helm client` 通过 gRPC 把 `Chart` 交给 `tiller`。`tiller` 是 k8s 中的一个 `pod`，在 `k8s` 集群中根据 `Chart` 以及配置信息部署资源，架构图如下\r\n\r\n![https://supergiant.io/wp-content/uploads/2018/11/helm-workflow-new.jpg](https://supergiant.io/wp-content/uploads/2018/11/helm-workflow-new.jpg)\r\n\r\n这有一个问题，`tiller` 有一个最高权限的 RBAC，而运维，开发众多权限不同的人都可以通过 `tiller` 这个最高权限来部署新的应用，会产生相应的安全问题。\r\n\r\n于是，`helm v3` 去掉了 `tiller`，它的权限控制基于操作人员的 `kubeconfig`",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MTgxOTIzNTg=",
    "number": 14,
    "title": "【Q013】有没有使用过 react hooks，它带来了那些便利",
    "body": "有没有使用过 react hooks，它有哪些优缺点？",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2ODI0NDg1NA==",
      "body": "依我的看法，`React hooks` 主要解决了状态以及副作用难以复用的场景，除此之外，他对我最大的好处就是在 `Console` 中不会看到重重叠叠相同名字的组件了(HOC)。\r\n\r\n目前使用感觉最爽的两个hook，都是关于请求的。一个是 `apollo-client` 的 `useQuery`，一个是 [swr](https://github.com/zeit/swr)。",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MTgxOTU3NDc=",
    "number": 15,
    "title": "【Q014】如何使用 react hooks 实现一个计数器的组件",
    "body": "如何使用 react hooks 实现最简单一个计数器的组件\r\n\r\n为了保证最最简单化，不需要暂停与开始状态",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2ODk0NjY4MQ==",
      "body": "```\r\nimport React, { useState, useEffect } from 'react'\r\nimport useCountDown from './useCountDown'\r\n\r\nconst useCountDown = (num) => {\r\n    const [seconds, setSecond] = useState(num)\r\n\r\n    useEffect(() => {\r\n        setTimeout(() => {\r\n            if (seconds > 0) {\r\n                setSecond(c => c - 1);\r\n            }\r\n        }, 1000);\r\n    }, [seconds]);\r\n\r\n    return [seconds, setSecond]\r\n}\r\n\r\n// use it\r\nconst Demo = () => {\r\n    const [seconds, setSecond] = useCountDown(0)\r\n    return (\r\n             <Button \r\n                disable={seconds !== 0} \r\n                onClick={() => setSecond(59)} \r\n            >\r\n                {seconds > 0 ? `${seconds}s后可点击` : '点击开始倒计时'}\r\n            </Button>\r\n        )\r\n}\r\n```",
      "star": {
        "totalCount": 2
      },
      "author": {
        "login": "Hack-Jay",
        "url": "https://github.com/Hack-Jay"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MTkxNjI4Nzg=",
    "number": 16,
    "title": "【Q015】你们的前端项目是如何在线上部署的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
        "name": "devops"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1MTA3MDkyMA==",
      "body": "> 今天正好写了一篇长文来回答这个问题\r\n\r\n前端一说起刀耕火种，那肯定紧随着前端工程化这一话题。随着 `react`/`vue`/`angular`，`es6+`，`webpack`，`babel`，`typescript` 以及 `node` 的发展，前端已经在逐渐替代过去 script 引 cdn 开发的方式了，掀起了工程化这一大浪潮。得益于工程化的发展与开源社区的良好生态，前端应用的可用性与效率得到了很大提高。\r\n\r\n前端以前是刀耕火种，那前端应用部署在以前也是刀耕火种。那前端应用部署的发展得益于什么，随前端工程化带来的副产品？\r\n\r\n这只是一部分，而更重要的原因是 `devops` 的崛起。\r\n\r\n为了更清晰地理解前端部署的发展史，了解部署时运维和前端（或者更广泛地说，业务开发人员）的职责划分，当每次前端部署发生改变时，可以思考两个问题\r\n\r\n1. 缓存，前端应用中http 的 `response header` 由谁来配？得益于工程化发展，可以对打包后得到带有 hash 值的文件可以做永久缓存\r\n1. 跨域，`/api` 的代理配置由谁来配？在开发环境前端可以开个小服务，启用 `webpack-dev-server` 配置跨域，那生产环境呢\r\n\r\n这两个问题都是前端面试时的高频问题，但话语权是否掌握在前端手里\r\n\r\n时间来到 `React` 刚刚发展起来的这一年，这时已经使用 `React` 开发应用，使用 `webpack` 来打包。但是前端部署，仍是刀耕火种\r\n\r\n## 刀耕火种\r\n\r\n一台跳板机\r\n\r\n一台生产环境服务器\r\n\r\n一份部署脚本\r\n\r\n前端调着他的 `webpack`，开心地给运维发了部署邮件并附了一份部署脚本，想着第一次不用套后端的模板，第一次前端可以独立部署。想着自己基础盘进一步扩大，前端不禁开心地笑了\r\n\r\n运维照着着前端发过来的部署邮件，一遍又一遍地拉着代码，改着配置，写着 `try_files`， 配着 `proxy_pass`。\r\n\r\n这时候，前端静态文件由 `nginx` 托管，`nginx` 配置文件大致长这个样子\r\n\r\n``` conf\r\nserver {\r\n  listen 80;\r\n  server_name shanyue.tech; \r\n\r\n  location / {\r\n    # 避免非root路径404\r\n    try_files $uri $uri/ /index.html;\r\n  }\r\n\r\n  # 解决跨域\r\n  location /api {\r\n    proxy_pass http://api.shanyue.tech;\r\n  }\r\n\r\n  # 为带 hash 值的文件配置永久缓存\r\n  location ~* \\.(?:css|js)$ {\r\n      try_files $uri =404;\r\n      expires 1y;\r\n      add_header Cache-Control \"public\";\r\n  }\r\n\r\n  location ~ ^.+\\..+$ {\r\n      try_files $uri =404;\r\n  }\r\n}\r\n```\r\n\r\n不过...经常有时候跑不起来\r\n\r\n运维抱怨着前端的部署脚本没有标好 `node` 版本，前端嚷嚷着测试环境没问题\r\n\r\n这个时候运维需要费很多心力放在部署上，甚至测试环境的部署上，前端也要操心放在运维如何部署上。这个时候由于怕影响线上环境，上线往往选择在深夜，前端和运维身心俱疲\r\n\r\n不过向来如此\r\n\r\n鲁迅说，向来如此，那便对么。\r\n\r\n**这个时候，无论跨域的配置还是缓存的配置，都是运维来管理，运维不懂前端。但配置方式却是前端在提供，而前端并不熟悉 nginx**\r\n\r\n## 使用 docker 构建镜像\r\n\r\n`docker` 的引进，很大程度地解决了部署脚本跑不了这个大BUG。**`dockerfile` 即部署脚本，部署脚本即 `dockerfile`**。也很大程度缓解了前端运维的摩擦，毕竟前端越来越靠谱了，至少部署脚本没有问题了 (笑\r\n\r\n这时候，前端不再提供静态资源，而是提供服务，一个 `http` 服务\r\n\r\n前端写的 `dockerfile` 大致长这个样子\r\n\r\n``` dockerfile\r\nFROM node:alpine\r\n\r\n# 代表生产环境\r\nENV PROJECT_ENV production\r\n# 许多 package 会根据此环境变量，做出不同的行为\r\n# 另外，在 webpack 中打包也会根据此环境变量做出优化，但是 create-react-app 在打包时会写死该环境变量\r\nENV NODE_ENV production\r\nWORKDIR /code\r\nADD . /code\r\nRUN npm install && npm run build && npm install -g http-server\r\nEXPOSE 80\r\n\r\nCMD http-server ./public -p 80\r\n```\r\n\r\n单单有 `dockerfile` 也跑不起来，另外前端也开始维护一个 `docker-compose.yaml`，交给运维执行命令 `docker-compose up -d` 启动前端应用。前端第一次写 `dockerfile` 与 `docker-compose.yaml`，在部署流程中扮演的角色越来越重要。想着自己基础盘进一步扩大，前端不禁开心地笑了\r\n\r\n``` yaml\r\nversion: \"3\"\r\nservices:\r\n  shici:\r\n    build: .\r\n    expose:\r\n      - 80\r\n```\r\n\r\n\r\n运维的 `nginx` 配置文件大致长这个样子\r\n\r\n``` conf\r\nserver {\r\n  listen 80;\r\n  server_name shanyue.tech; \r\n\r\n  location / {\r\n    proxy_pass http://static.shanyue.tech;\r\n  }\r\n\r\n  location /api {\r\n    proxy_pass http://api.shanyue.tech;\r\n  }\r\n}\r\n```\r\n\r\n运维除了配置 `nginx` 之外，还要执行一个命令: `docker-compose up -d`\r\n\r\n这时候再思考文章最前面两个问题\r\n\r\n1. 缓存，由于从静态文件转换为服务，缓存开始交由前端控制 (但是镜像中的 `http-server` 不太适合做这件事情)\r\n1. 跨域，跨域仍由运维在 `nginx` 中配置\r\n\r\n前端可以做他应该做的事情中的一部分了，这是一件令人开心的事情\r\n\r\n当然，前端对于 `dockerfile` 的改进也是一个慢慢演进的过程，那这个时候镜像有什么问题呢？\r\n\r\n1. 构建镜像体积过大\r\n1. 构建镜像时间过长\r\n\r\n## 使用多阶段构建优化镜像\r\n\r\n这中间其实经历了不少坎坷，其中过程如何，详见我的另一篇文章: [如何使用 docker 部署前端应用](https://juejin.im/post/5c83cbaa6fb9a04a0f65fdaa)。\r\n\r\n其中主要的优化也是在上述所提到的两个方面\r\n\r\n1. 构建镜像体积由 1G+ 变为 10M+\r\n1. 构建镜像时间由 5min+ 变为 1min (视项目复杂程度，大部分时间在构建时间与上传静态资源时间)\r\n\r\n``` dockerfile\r\nFROM node:alpine as builder\r\n\r\nENV PROJECT_ENV production\r\nENV NODE_ENV production\r\n\r\nWORKDIR /code\r\n\r\nADD package.json /code\r\nRUN npm install --production\r\n\r\nADD . /code\r\n\r\n# npm run uploadCdn 是把静态资源上传至 oss 上的脚本文件，将来会使用 cdn 对 oss 加速\r\nRUN npm run build && npm run uploadCdn\r\n\r\n# 选择更小体积的基础镜像\r\nFROM nginx:alpine\r\nCOPY --from=builder code/public/index.html code/public/favicon.ico /usr/share/nginx/html/\r\nCOPY --from=builder code/public/static /usr/share/nginx/html/static\r\n```\r\n\r\n那它怎么做的\r\n\r\n1. 先 `ADD package.json /code`, 再 `npm install --production` 之后 `Add` 所有文件。充分利用镜像缓存，减少构建时间\r\n1. 多阶段构建，大大减小镜像体积\r\n\r\n另外还可以有一些小优化，如\r\n\r\n+ `npm cache` 的基础镜像或者 `npm` 私有仓库，减少 `npm install` 时间，减小构建时间\r\n+ `npm install --production` 只装必要的包\r\n\r\n前端看着自己优化的 `dockerfile`，想着前几天还被运维吵，说什么磁盘一半的空间都被前端的镜像给占了，想着自己节省了前端镜像几个数量级的体积，为公司好像省了不少服务器的开销，想着自己的基础盘进一步扩大，不禁开心的笑了\r\n\r\n这时候再思考文章最前面两个问题\r\n\r\n1. 缓存，缓存由前端控制，缓存在oss上设置，将会使用 cdn 对 oss 加速。此时缓存由前端写脚本控制\r\n1. 跨域，跨域仍由运维在 `nginx` 中配置\r\n\r\n## CI/CD 与 gitlab\r\n\r\n此时前端成就感爆棚，运维呢？运维还在一遍一遍地上线，重复着一遍又一遍的部署三个动作\r\n\r\n1. 拉代码\r\n1. `docker-compose up -d`\r\n1. 重启 nginx\r\n\r\n运维觉得再也不能这么下去了，于是他引进了 `CI`: 与现有代码仓库 `gitlab` 配套的 `gitlab ci`\r\n\r\n+ `CI`，`Continuous Integration`，持续集成\r\n+ `CD`，`Continuous Delivery`，持续交付\r\n\r\n重要的不是 `CI/CD` 是什么，重要的是现在运维不用跟着业务上线走了，不需要一直盯着前端部署了。这些都是 `CI/CD` 的事情了，它被用来做自动化部署。上述提到的三件事交给了 `CI/CD`\r\n\r\n`.gitlab-ci.yml` 是 `gitlab` 的 CI 配置文件，它大概长这个样子\r\n\r\n``` yaml\r\ndeploy:\r\n  stage: deploy\r\n  only:\r\n    - master\r\n  script:\r\n    - docker-compose up --build -d\r\n  tags:\r\n    - shell\r\n```\r\n\r\n`CI/CD` 不仅仅更解放了业务项目的部署，也在交付之前大大加强了业务代码的质量，它可以用来 `lint`，`test`，`package` 安全检查，甚至多特性多环境部署，我将会在我以后的文章将这部分事情\r\n\r\n我的一个服务器渲染项目 [shfshanyue/shici](https://github.com/shfshanyue/shici) 以前在我的服务器中就是以 `docker`/`docker-compose/gitlab-ci` 的方式部署，有兴趣的可以看看它的配置文件\r\n\r\n+ [shfshanyue/shici:Dockerfile](https://github.com/shfshanyue/shici/blob/master/Dockerfile)\r\n+ [shfshanyue/shici:docker-compose.yml](https://github.com/shfshanyue/shici/blob/master/docker-compose.yml)\r\n+ [shfshanyue/shici:gitlab-ci.yml](https://github.com/shfshanyue/shici/blob/master/.gitlab-ci.yml)\r\n\r\n如果你有个人服务器的话，也建议你做一个自己感兴趣的前端应用和配套的后端接口服务，并且配套 `CI/CD` 把它部署在自己的自己服务器上\r\n\r\n而你如果希望结合 `github` 做 `CI/CD`，那可以试一试 `github` + `github action`\r\n\r\n另外，也可以试试 `drone.ci`，如何部署可以参考我以前的文章: [github 上持续集成方案 drone 的简介及部署](https://juejin.im/post/5dc0b563f265da4cef190b8a)\r\n\r\n## 使用 kubernetes 部署\r\n\r\n随着业务越来越大，镜像越来越多，`docker-compose` 已经不太能应付，`kubernetes` 应时而出。这时服务器也从1台变成了多台，多台服务器就会有分布式问题\r\n\r\n**一门新技术的出现，在解决以前问题的同时也会引进复杂性。**\r\n\r\nk8s 部署的好处很明显: 健康检查，滚动升级，弹性扩容，快速回滚，资源限制，完善的监控等等\r\n\r\n那现在遇到的新问题是什么？\r\n\r\n**构建镜像的服务器，提供容器服务的服务器，做持续集成的服务器是一台！**\r\n\r\n需要一个私有的镜像仓库，这是运维的事情，`harbor` 很快就被运维搭建好了，但是对于前端部署来说，复杂性又提高了\r\n\r\n先来看看以前的流程:\r\n\r\n1. 前端配置 `dockerfile` 与 `docker-compose`\r\n1. 生产环境服务器的 `CI runner` 拉代码(可以看做以前的运维)，`docker-compose up -d` 启动服务。然后再重启 `nginx`，做反向代理，对外提供服务\r\n\r\n以前的流程有一个问题: **构建镜像的服务器，提供容器服务的服务器，做持续集成的服务器是一台！**，所以需要一个私有的镜像仓库，一个能够访问 `k8s` 集群的持续集成服务器\r\n\r\n流程改进之后结合 `k8s` 的流程如下\r\n\r\n1. 前端配置 `dockerfile`，构建镜像，推到镜像仓库\r\n1. 运维为前端应用配置 `k8s` 的资源配置文件，`kubectl apply -f` 时会重新拉取镜像，部署资源\r\n\r\n运维问前端，需不需要再扩大下你的基础盘，写一写前端的 `k8s` 资源配置文件，并且列了几篇文章\r\n\r\n+ [使用 k8s 部署你的第一个应用: Pod，Deployment 与 Service](https://juejin.im/post/5db8c2b46fb9a020256692dc)\r\n+ [使用 k8s 为你的应用配置域名: Ingress](https://juejin.im/post/5db8da4b6fb9a0204520b310)\r\n+ [使用 k8s 为你的域名加上 https](https://juejin.im/post/5db8d94be51d4529f73e2833)\r\n\r\n前端看了看后端十几个 k8s 配置文件之后，摇摇头说算了算了\r\n\r\n这个时候，`gitlab-ci.yaml` 差不多长这个样子，配置文件的权限由运维一人管理\r\n\r\n``` yaml\r\ndeploy:\r\n  stage: deploy\r\n  only:\r\n    - master\r\n  script:\r\n    - docker build -t harbor.shanyue.tech/fe/shanyue\r\n    - docker push harbor.shanyue.tech/fe/shanyue\r\n    - kubectl apply -f https://k8s-config.default.svc.cluster.local/shanyue.yaml\r\n  tags:\r\n    - shell\r\n```\r\n\r\n这时候再思考文章最前面两个问题\r\n\r\n1. 缓存，缓存由前端控制\r\n1. 跨域，跨域仍由运维控制，在后端 `k8s` 资源的配置文件中控制 `Ingress`\r\n\r\n## 使用 helm 部署\r\n\r\n这时前端与运维已不太往来，除了偶尔新起项目需要运维帮个忙以外\r\n\r\n但好景不长，突然有一天，前端发现自己连个环境变量都没法传！于是经常找运维修改配置文件，运维也不胜其烦\r\n\r\n于是有了 `helm`，如果用一句话解释它，那它就是一个带有模板功能的 `k8s` 资源配置文件。作为前端，你只需要填参数。更多详细的内容可以参考我以前的文章 [使用 helm 部署 k8s 资源](https://juejin.im/post/5dbf7909f265da4d4b5fe7b4)\r\n\r\n假如我们使用 [bitnami/nginx](https://hub.helm.sh/charts/bitnami/nginx) 作为 `helm chart`，前端可能写的配置文件长这个样子\r\n\r\n``` yaml\r\nimage:\r\n  registry: harbor.shanyue.tech\r\n  repository: fe/shanyue\r\n  tag: 8a9ac0\r\n\r\ningress:\r\n  enabled: true\r\n  hosts:\r\n  - name: shanyue.tech\r\n    path: /\r\n\r\n  tls:\r\n  - hosts:\r\n      - shanyue.tech\r\n    secretName: shanyue-tls\r\n\r\n    # livenessProbe:\r\n    #   httpGet:\r\n    #     path: /\r\n    #     port: http\r\n    #   initialDelaySeconds: 30\r\n    #   timeoutSeconds: 5\r\n    #   failureThreshold: 6\r\n    # \r\n    # readinessProbe:\r\n    #   httpGet:\r\n    #     path: /\r\n    #     port: http\r\n    #   initialDelaySeconds: 5\r\n    #   timeoutSeconds: 3\r\n    #   periodSeconds: 5\r\n```\r\n\r\n这时候再思考文章最前面两个问题\r\n\r\n1. 缓存，缓存由前端控制\r\n1. 跨域，跨域由后端控制，配置在后端 Chart 的配置文件 `values.yaml` 中\r\n\r\n到了这时前端和运维的职责所在呢？\r\n\r\n前端需要做的事情有:\r\n\r\n1. 写前端构建的 `dockerfile`，这只是一次性的工作，而且有了参考\r\n1. 使用 `helm` 部署时指定参数\r\n\r\n那运维要做的事情呢\r\n\r\n1. 提供一个供所有前端项目使用的 `helm chart`，甚至不用提供，如果运维比较懒那就就使用 [bitnami/nginx](https://hub.helm.sh/charts/bitnami/nginx) 吧。也是一次性工作\r\n1. 提供一个基于 `helm` 的工具，禁止业务过多的权限，甚至不用提供，如果运维比较懒那就直接使用 `helm`\r\n\r\n这时前端可以关注于自己的业务，运维可以关注于自己的云原生，职责划分从未这般清楚\r\n\r\n## 统一前端部署平台\r\n\r\n后来运维觉得前端应用的本质是一堆静态文件，较为单一，容易统一化，来避免各个前端镜像质量的参差不齐。于是运维准备了一个统一的 `node` 基础镜像\r\n\r\n前端再也不需要构建镜像，上传 CDN 了，他只需要写一份配置文件就可以了，大致长这个样子\r\n\r\n``` yaml\r\nbuild:\r\n  command: npm run build\r\n  dist: /dist\r\n\r\nhosts:\r\n- name: shanyue.tech\r\n  path: /\r\n\r\nheaders:\r\n- location: /*\r\n  values:\r\n  - cache-control: max-age=7200\r\n- location: assets/*\r\n  values:\r\n  - cache-control: max-age=31536000\r\n\r\nredirects:\r\n- from : /api\r\n  to: https://api.shanyue.tech\r\n  status: 200\r\n```\r\n\r\n此时，前端只需要写一份配置文件，就可以配置缓存，配置 `proxy`，做应该属于前端做的一切，而运维也再也不需要操心前端部署的事情了\r\n\r\n前端看着自己刚刚写好的配置文件，怅然若失的样子...\r\n\r\n不过一般只有大厂会有这么完善的前端部署平台，如果你对它有兴趣，你可以尝试下 `netlify`，可以参考我的文章: [使用 netlify 部署你的前端应用](https://shanyue.tech/op/deploy-fe-with-netlify.html)\r\n\r\n## 服务端渲染与后端部署\r\n\r\n大部分前端应用本质上是静态资源，剩下的少部分就是服务端渲染了，服务端渲染的本质上是一个后端服务，它的部署可以视为后端部署\r\n\r\n后端部署的情况更为复杂，比如\r\n\r\n1. 配置服务，后端需要访问敏感数据，但又不能把敏感数据放在代码仓库。你可以在 `environment variables`， `consul` 或者 `k8s configmap` 中维护\r\n1. 上下链路服务，你需要依赖数据库，上游服务\r\n1. 访问控制，限制 IP，黑白名单\r\n1. RateLimit\r\n1. 等等\r\n\r\n我将在以后的文章分享如何在 k8s 中部署一个后端\r\n\r\n## 小结\r\n\r\n随着 `devops` 的发展，前端部署越来越简单，可控性也越来越高，建议所有人都稍微学习一下 `devops` 的东西。\r\n\r\n道阻且长，行则将至。\r\n\r\n## 相关文章\r\n\r\n+ [个人服务器运维指南](https://juejin.im/post/5db7a9e2f265da4cf85d6fb9)\r\n+ [如果你想搭建一个博客](https://juejin.im/post/5db78500f265da4d0a68cef7)\r\n+ [当我有一台服务器时我做了什么](https://juejin.im/post/5c9232a8e51d45729b3b71e1)\r\n+ [使用 k8s 部署你的第一个应用: Pod，Deployment 与 Service](https://juejin.im/post/5db8c2b46fb9a020256692dc)\r\n+ [使用 k8s 为你的应用配置域名: Ingress](https://juejin.im/post/5db8da4b6fb9a0204520b310)\r\n+ [使用 k8s 为你的域名加上 https](https://juejin.im/post/5db8d94be51d4529f73e2833)\r\n",
      "star": {
        "totalCount": 2
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MTk1OTg4MDg=",
    "number": 17,
    "title": "【Q016】后端的敏感数据在生产环境是如何配置的",
    "body": "后端的敏感数据在生产环境是如何配置的，如数据库的账号密码，jwt 的 secret，联调上游服务的 token 等",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1MTM0NjI1OA==",
      "body": "目前我们的方式是在每次部署之前，在 [vault](https://github.com/hashicorp/vault) 和 [consul](https://github.com/hashicorp/consul) 拉取敏感数据，写在配置文件中\r\n\r\n另外，还有几种可选的方案\r\n\r\n1. 跟随 `CI/CD` 的环境变量，敏感配置放在 CI 平台\r\n1. 跟随 k8s `secret`/`configMap`，敏感配置放在 k8s 集群\r\n1. 跟随专有的配置服务，如 `consul`/`vault`",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MTk5NTY3NjQ=",
    "number": 18,
    "title": "【Q017】css 如何实现左侧固定300px，右侧自适应的布局",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2MjQxMzkzMA==",
      "body": "css---\r\n .box{\r\n            width:100%;;\r\n            height:100%;\r\n            display:flex;\r\n        }\r\n        .one{\r\n            width:300px;\r\n            height:300px;\r\n            background-color: #afa;\r\n        }\r\n        .two{\r\n            flex:1;\r\n            height:300px;\r\n            background-color: #ae5aca;\r\n        }\r\nhtml----\r\n <div class=\"box\">\r\n        <div class=\"one\">12312313</div>\r\n        <div class=\"two\">123</div>\r\n    </div>",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "zhaochongzi",
        "url": "https://github.com/zhaochongzi"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MTk5NTk0MTI=",
    "number": 19,
    "title": "【Q018】当你使用 docker 部署应用时，如何查看应用日志",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
        "name": "devops"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1MjQ0MjU4NA==",
      "body": "在docker中使用 `docker logs CONTAINER`\r\n\r\n如果在k8s中使用 `kubectl logs POD`",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjA0MjExNDI=",
    "number": 20,
    "title": "【Q019】浏览器中如何实现剪切板复制内容的功能",
    "body": "在一些博客系统，如掘金的博客中，可以复制代码，它是如何实现的",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
        "name": "html"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1MjA5OTE2NQ==",
      "body": "它一般可以使用第三方库 [clipboard-copy](https://github.com/feross/clipboard-copy/blob/master/index.js) 来实现，源码很简单，可以读一读\r\n\r\n目前最为推荐的方式是使用 `Clipboard API` 进行实现\r\n\r\n``` js\r\nnavigator.clipboard.writeText(text)\r\n```\r\n\r\n而对于一些不支持 `Clipboard API` 的浏览器，使用以下 API 进行复制\r\n\r\n1. 选中: `Selection API`\r\n1. 复制: `document.execCommand` (已被废弃)\r\n\r\n## 选中: Selection API/Range API\r\n\r\n选中主要利用了 [Selection API](https://developer.mozilla.org/en-US/docs/Web/API/Selection) 与 Range API\r\n\r\n选中的代码如下\r\n\r\n``` js\r\nconst selection = window.getSelection();\r\nconst range = document.createRange();\r\n\r\n// RangeAPI: 制造区域\r\nrange.selectNodeContents(element);\r\n\r\n// Selection: 选中区域\r\nselection.addRange(range);\r\n\r\nselectedText = selection.toString();\r\n```\r\n\r\n取消选中的代码如下\r\n\r\n``` js\r\nwindow.getSelection().removeAllRanges();\r\n```\r\n\r\n它有现成的第三方库可以使用: [select.js](https://github.com/zenorocha/select)\r\n\r\n## 复制: execCommand\r\n\r\n复制就比较简单了，`execCommand`\r\n\r\n``` js\r\ndocument.execCommand('copy')\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjA0Mjc1NzU=",
    "number": 21,
    "title": "【Q020】如何实现一个分布式锁",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      },
      {
        "id": "MDU6TGFiZWwxNjY2OTk3OTM5",
        "name": "redis"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1Mjc2NTk0NA==",
      "body": "mysql,redis,zk redis效率较高\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "zhangxiaokun",
        "url": "https://github.com/zhangxiaokun"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjA1NjU4MDk=",
    "number": 22,
    "title": "【Q021】React 中，cloneElement 与 createElement 各是什么，有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1NDY4ODc0MQ==",
      "body": "``` js\r\nReact.cloneElement(\r\n  element,\r\n  [props],\r\n  [...children]\r\n)\r\n\r\nReact.createElement(\r\n  type,\r\n  [props],\r\n  [...children]\r\n)\r\n```\r\n\r\n直接上 API，很容易得出结论：首参不一样。这也是他们的最大区别：\r\n\r\n1. `cloneElement`，根据 Element 生成新的 Element\r\n1.  `createElement`，根据 Type 生成新的 Element\r\n\r\n然而，此时估计还是云里雾里，含糊不清，需要弄清它，首先要明白俩概念\r\n\r\n1. Type\r\n1. Element\r\n\r\n## React.cloneElement 的使用场景",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjA1NjY4MzA=",
    "number": 23,
    "title": "【Q022】如何实现一个简单的 Promise",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1MzE4MjA0Mg==",
      "body": "一个简单的 `Promise` 的粗糙实现，关键点在于\r\n\r\n1. 当 `pending` 时， `thenable` 函数由一个队列维护\r\n1. 当状态变为 `resolved(fulfilled)` 时，队列中所有 `thenable` 函数执行\r\n1. 当 `resolved` 时， `thenable` 函数直接执行\r\n\r\n<!--more-->\r\n\r\n`rejected` 状态同理\r\n\r\n```javascript\r\nclass Prom {\r\n  static resolve (value) {\r\n    if (value && value.then) {\r\n      return value \r\n    }\r\n    return new Prom(resolve => resolve(value))\r\n  }\r\n\r\n  constructor (fn) {\r\n    this.value = undefined\r\n    this.reason = undefined\r\n    this.status = 'PENDING'\r\n\r\n    // 维护一个 resolve/pending 的函数队列\r\n    this.resolveFns = []\r\n    this.rejectFns = []\r\n\r\n    const resolve = (value) => {\r\n      // 注意此处的 setTimeout\r\n      setTimeout(() => {\r\n        this.status = 'RESOLVED'\r\n        this.value = value\r\n        this.resolveFns.forEach(({ fn, resolve: res, reject: rej }) => res(fn(value)))\r\n      })\r\n    }\r\n\r\n    const reject = (e) => {\r\n      setTimeout(() => {\r\n        this.status = 'REJECTED'\r\n        this.reason = e\r\n        this.rejectFns.forEach(({ fn, resolve: res, reject: rej }) => rej(fn(e)))\r\n      })\r\n    }\r\n\r\n    fn(resolve, reject)\r\n  }\r\n\r\n\r\n  then (fn) {\r\n    if (this.status === 'RESOLVED') {\r\n      const result = fn(this.value)\r\n      // 需要返回一个 Promise\r\n      // 如果状态为 resolved，直接执行\r\n      return Prom.resolve(result)\r\n    }\r\n    if (this.status === 'PENDING') {\r\n      // 也是返回一个 Promise\r\n      return new Prom((resolve, reject) => {\r\n        // 推进队列中，resolved 后统一执行\r\n        this.resolveFns.push({ fn, resolve, reject }) \r\n      })\r\n    }\r\n  }\r\n\r\n  catch (fn) {\r\n    if (this.status === 'REJECTED') {\r\n      const result = fn(this.value)\r\n      return Prom.resolve(result)\r\n    }\r\n    if (this.status === 'PENDING') {\r\n      return new Prom((resolve, reject) => {\r\n        this.rejectFns.push({ fn, resolve, reject }) \r\n      })\r\n    }\r\n  }\r\n}\r\n\r\nProm.resolve(10).then(o => o * 10).then(o => o + 10).then(o => {\r\n  console.log(o)\r\n})\r\n\r\nreturn new Prom((resolve, reject) => reject('Error')).catch(e => {\r\n  console.log('Error', e)\r\n})\r\n```\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjA1NjY5ODI=",
    "number": 24,
    "title": "【Q023】websocket 服务多节点部署时会有什么问题，怎么解决",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1MzE4NzQ4MA==",
      "body": "## 多节点问题\r\n\r\n在开始思考分布式会有什么问题时，先来回答一个问题: 服务端如何与客户端交流？\r\n\r\n在 ws 服务端，当与客户端连接成功后，会生成一个对象 `connection`，ws 会维护一个与客户端所有连接的 `connections`。如果想要主动推送消息到客户端，只需要调用API `connection.sendText(message)`。\r\n\r\n那如何给所有人广播消息呢？\r\n\r\n服务器只需要与它自身的所有连接 `server.connections` 挨个发消息就是广播，所以它只是一个伪广播：我要给群里所有人发消息，但我不能在群里发，只能挨个私发。\r\n\r\n### 单节点\r\n\r\n当单节点时所有用户都能正常受到通知，流程如下\r\n\r\n![ws 单节点时](https://raw.githubusercontent.com/shfshanyue/graph/master/draw/ws-single-node.jpg)\r\n\r\n这时所有用户都能收到消息通知\r\n\r\n### 多节点\r\n\r\n当多节点时，就会有部分用户无法正常受到通知，从以下流程图中可以很清楚地看到问题所在\r\n\r\n![ws 多节点时](https://raw.githubusercontent.com/shfshanyue/graph/master/draw/ws-multi-node.jpg)\r\n\r\n**负载到节点2的所有用户都没有收到消息通知**\r\n\r\n## 如何解决\r\n\r\n多节点服务器就会有分布式问题，解决分布式问题就找一个大家都能找到的地，比如说 `Redis`，比如说 `Kafka` 等消息件\r\n\r\n改进后流程图如下\r\n\r\n1. 需要向所有用户推送消息，请求 websocket 服务\r\n1. 负载均衡到某个节点\r\n1. 该节点向 redis/kafka 推送消息: 向所有用户推送消息通知\r\n1. 所有节点在 redis/kafka 上订阅消息\r\n1. 订阅成功后所有节点向客户端 push 消息\r\n\r\n![借用 redis](https://raw.githubusercontent.com/shfshanyue/graph/master/draw/ws-redis.jpg)\r\n\r\n## redis PUBSUB\r\n\r\n其中有一个细节是 pub/sub 那里，redis 的 `pubsub` 较 `Kafka` 等消息中间件更为轻便，**最主要的是与ws集成的社区方案比较成熟，这点很重要**，如 Node 中的以下两个\r\n\r\n+ [graphql subscriptions - redis](https://github.com/davidyaha/graphql-redis-subscriptions)\r\n+ [socket.io-redis](https://github.com/socketio/socket.io-redis)\r\n\r\n`pubsub` 在 redis 中的命令如下\r\n\r\n+ pub: `publish channel message`\r\n+ sub: `subscribe`\r\n\r\n如果我们要订阅 `eat` 这个 `channel` 的话，图示如下\r\n\r\n![redis pubsub example](https://raw.githubusercontent.com/shfshanyue/Daily-Question/master/assets/pubsub.png)\r\n\r\n## 进一步追问\r\n\r\n面试官见我回答完问题后，又一次追问\r\n\r\n**那 websocket 如何向特定的用户组推送消息？**\r\n\r\n假如一个学校有以下数据结构\r\n\r\n1. `Class`: 代表班级\r\n1. `Student`: 代表学生，每个学生都在其中一个班级\r\n\r\n那假如要向 `Class:201901` 班级的所有学生发送通知，应该如何实现\r\n\r\n欢迎在 Issue 中讨论: [【Q029】websocket 如何向特定用户组推送消息](https://github.com/shfshanyue/Daily-Question/issues/30)\r\n\r\n## 小结\r\n\r\n借用解决方案的图作为小结\r\n\r\n![借用 redis](https://raw.githubusercontent.com/shfshanyue/graph/master/draw/ws-redis.jpg)\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjA4MDYxMTU=",
    "number": 25,
    "title": "【Q024】在 postgres 中，查询时如何对 jsonb 数据格式化",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1MjM0MDU0Ng==",
      "body": "使用 `jsonb_pretty` 函数，示例如下\r\n\r\n``` sql\r\n> select jsonb_pretty('{\"a\": {\"b\": 4}}'::jsonb)\r\n+----------------+\r\n| jsonb_pretty   |\r\n|----------------|\r\n| {              |\r\n|     \"a\": {     |\r\n|         \"b\": 4 |\r\n|     }          |\r\n| }              |\r\n+----------------+\r\nSELECT 1\r\nTime: 0.018s\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjA5NTU1MDI=",
    "number": 26,
    "title": "【Q025】简述 TCP socket 建立的过程",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
        "name": "network"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1MzE4MjMyNQ==",
      "body": "一图胜千言\r\n\r\n![image](https://user-images.githubusercontent.com/13389461/68817970-5e11d000-06be-11ea-85ee-5d2496d14c63.png)\r\n",
      "star": {
        "totalCount": 3
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjEyOTc0OTU=",
    "number": 27,
    "title": "【Q026】如何对接口进行压力测试",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1MzE4MjE0NQ==",
      "body": "``` bash\r\n$ ab\r\n\r\n$ wrk\r\n\r\n$ siege\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjEzNzA0Mjg=",
    "number": 28,
    "title": "【Q027】在前端开发中，如何获取浏览器的唯一标识",
    "body": "如何获取浏览器的唯一标识，原理是什么",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1Mjc4NDQ1Ng==",
      "body": "由于不同的系统显卡绘制 `canvas` 时渲染参数、抗锯齿等算法不同，因此绘制成图片数据的 `CRC` 校验也不一样。\r\n\r\n``` js\r\nfunction getCanvasFp () {\r\n  const canvas = document.getElementById('canvas')\r\n  const ctx = canvas.getContext('2d')\r\n  ctx.font = '14px Arial'\r\n  ctx.fillStyle = '#ccc'\r\n  ctx.fillText('hello, shanyue', 2, 2)\r\n  return canvas.toDataURL('image/jpeg')\r\n}\r\n```\r\n\r\n因此根据 `canvas` 可以获取浏览器指纹信息。\r\n\r\n1. 绘制 `canvas`，获取 `base64` 的 dataurl\r\n1. 对 dataurl 这个字符串进行 `md5` 摘要计算，得到指纹信息\r\n\r\n但是对于常见的需求就有成熟的解决方案，若在生产环境使用，可以使用以下库\r\n\r\n+ [fingerprintjs2](https://github.com/Valve/fingerprintjs2)\r\n\r\n它依据以下信息，获取到浏览器指纹信息，**而这些信息，则成为 `component`**\r\n\r\n1. `canvas`\r\n1. `webgl`\r\n1. `UserAgent`\r\n1. `AudioContext`\r\n1. 对新式 API 的支持程度等\r\n\r\n``` js\r\nrequestIdleCallback(function () {\r\n  Fingerprint2.get((components) => {\r\n    const values = components.map((component) => component.value)\r\n    const fp = Fingerprint2.x64hash128(values.join(''), 31)\r\n  })\r\n})\r\n```\r\n\r\n在 `fingerprintjs2` 中，对于 `component` 也有分类\r\n\r\n+ [browser independent component](https://github.com/Valve/fingerprintjs2/wiki/Browser-independent-components)：有些 `component` 同一设备跨浏览器也可以得到相同的值，有些独立浏览器，得到不同的值\r\n+ [stable component](https://github.com/Valve/fingerprintjs2/wiki/Stable-components): 有些 `component` 刷新后值就会发生变化，称为不稳定组件\r\n\r\n在实际业务中，可根据业务选择合适的组件\r\n\r\n``` js\r\nconst options = {\r\n  excludes: {userAgent: true, language: true}\r\n}\r\n```\r\n\r\n## 简答\r\n\r\n根据 `canvas` 可以获取浏览器指纹信息\r\n\r\n1. 绘制 `canvas`，获取 `base64` 的 dataurl\r\n1. 对 dataurl 这个字符串进行 `md5` 摘要计算，得到指纹信息\r\n\r\n若在生产环境使用，可以使用 [fingerprintjs2](https://github.com/Valve/fingerprintjs2)，根据业务需求，如单设备是否可跨浏览器，以此选择合适的 `component`",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjEzOTk3ODA=",
    "number": 29,
    "title": "【Q028】在linux中如何获取登录的用户",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1MzE4MTg2OQ==",
      "body": "``` bash\r\n$ who\r\n\r\n$ last\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjE5MjExMTQ=",
    "number": 30,
    "title": "【Q029】websocket 如何向特定的用户组推送消息",
    "body": "假如一个学校有以下数据结构\r\n\r\n1. `Class`: 代表班级\r\n1. `Student`: 代表学生，每个学生都在其中一个班级\r\n\r\n那假如要向 `Class:201901` 班级的所有学生发送通知，应该如何实现",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1NDYyNjQzOA==",
      "body": "在 `redis` 处维护一个对象，记录每个 group 所对应的 `connections`/`sockets`\r\n\r\n``` js\r\n{\r\n  'Class:201901': [student1Socket, student2Socket]\r\n}\r\n```\r\n\r\n当 client 刚连入 server 时，便加入某个特定的组，或者叫 room，比如 student01，刚开始连入 server，可能要加入 room：`Student:01`，`Class:201901`，`Group:10086`",
      "star": {
        "totalCount": 2
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjI2MDI3MTU=",
    "number": 31,
    "title": "【Q030】linux 中如何打印所有网络接口",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
        "name": "network"
      },
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1Mzc0MjYyOA==",
      "body": "## ifconfig\r\n\r\n`ifconfig` 是最简单最常用，但是打印信息太多了\r\n\r\n``` bash\r\n$ ifconfig\r\ncni0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1450\r\n        inet 10.244.0.1  netmask 255.255.255.0  broadcast 0.0.0.0\r\n        ether 9e:f3:9e:47:9d:55  txqueuelen 1000  (Ethernet)\r\n        RX packets 14733665  bytes 1007493238 (960.8 MiB)\r\n        RX errors 0  dropped 0  overruns 0  frame 0\r\n        TX packets 15040396  bytes 4534954611 (4.2 GiB)\r\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\r\n\r\ndocker0: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500\r\n        inet 172.18.0.1  netmask 255.255.0.0  broadcast 172.18.255.255\r\n        ether 02:42:09:fe:1d:e5  txqueuelen 0  (Ethernet)\r\n        RX packets 0  bytes 0 (0.0 B)\r\n        RX errors 0  dropped 0  overruns 0  frame 0\r\n        TX packets 0  bytes 0 (0.0 B)\r\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\r\n```\r\n\r\n## netstat\r\n\r\n`netstat` 与 `ip` 也挺好用，特别是它们还可以打印路由表\r\n\r\n``` bash\r\n$ netstat -i\r\nKernel Interface table\r\nIface             MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg\r\ncni0             1450 14733471      0      0 0      15040202      0      0      0 BMRU\r\ndocker0          1500        0      0      0 0             0      0      0      0 BMU\r\neth0             1500 42833038      0      0 0      40961577      0      0      0 BMRU\r\nflannel.1        1450  4761436      0      0 0       4091581      0      0      0 BMRU\r\nlo              65536 376447249      0      0 0      376447249      0      0      0 LRU\r\nveth2052e2d6     1450  7358995      0      0 0       7518642      0      0      0 BMRU\r\nveth3190806e     1450  7363232      0      0 0       7510100      0      0      0 BMRU\r\n```\r\n\r\n## ip\r\n\r\n``` bash\r\n$ ip link\r\n\r\n$ ip addr\r\n```\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjM0MTY3MTM=",
    "number": 32,
    "title": "【Q031】js 中如何实现 bind",
    "body": "提供以下测试用例，注意第二条测试用例，因此 bind 可实现 `_.partial(func, [partials])` 类似功能\r\n\r\n``` js\r\nfunction f (b) {\r\n  console.log(this.a, b)\r\n}\r\n\r\n//=> 3, 4\r\nf.fakeBind({ a: 3 })(4)\r\n\r\n//=> 3, 10\r\nf.fakeBind({ a: 3 }, 10)(11)\r\n```\r\n\r\n\r\n相关问题:\r\n\r\n+ [【Q032】js 中什么是 softbind，如何实现](https://github.com/shfshanyue/Daily-Question/issues/33)\r\n+ [【Q656】JS 中如何实现 call/apply (代码集合)](https://github.com/shfshanyue/Daily-Question/issues/674)",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1NDYyNzg0NA==",
      "body": "**最简单的 `bind` 一行就可以实现，而在实际面试过程中也不会考察你太多的边界条件**\r\n\r\n``` js\r\nFunction.prototype.fakeBind = function(obj, ...args) {\r\n  return (...rest) => this.call(obj, ...args, ...rest)\r\n}\r\n```\r\n\r\n测试一下\r\n\r\n``` js\r\nfunction f (arg) {\r\n  console.log(this.a, arg)\r\n}\r\n\r\n// output: 3, 4\r\nf.bind({ a: 3 })(4)\r\n\r\n// output: 3, 4\r\nf.fakeBind({ a: 3 })(4)\r\n```\r\n",
      "star": {
        "totalCount": 3
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjM0MTgxNDI=",
    "number": 33,
    "title": "【Q032】js 中什么是 softbind，如何实现",
    "body": "相关问题:\r\n\r\n+ [如何实现 bind](https://github.com/shfshanyue/Daily-Question/issues/32)",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc0ODczMjQwNw==",
      "body": "bind函数多次调用会已第一次绑定的this为准，softbind已最后一次绑定传入的this为准；",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "newwangyiyang",
        "url": "https://github.com/newwangyiyang"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjM0MTkyNDM=",
    "number": 34,
    "title": "【Q033】如何对接口进行限流",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1NDYzMDg2MQ==",
      "body": "一般采用漏桶算法：\r\n\r\n1. 漏桶初始为空\r\n1. API 调用是在往漏桶里注水\r\n1. 漏桶会以一定速率出水\r\n1. 水满时 API 拒绝调用\r\n\r\n![漏桶算法](https://d33wubrfki0l68.cloudfront.net/e737eb0be9176ca74d03344f082281154f90f12c/c0076/assets/img/leaky-bucket.f8cb8f08.png)\r\n\r\n可以使用 `redis` 的计数器实现\r\n\r\n1. 计数器初始为空\r\n1. API 调用计数器增加\r\n1. 给计数器设置过期时间，隔段时间清零，视为一定速率出水\r\n1. 计数器达到上限时，拒绝调用\r\n\r\n当然，这只是大致思路，这时会有两个问题要注意\r\n\r\n1. 最坏情况下的限流是额定限流速率的2倍\r\n1. 条件竞争问题\r\n\r\n不过实际实现时注意以下就好了（话说一般也是调用现成的三方库做限流...)，可以参考我以前的文章 <https://shanyue.tech/post/rate-limit/>",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjM4Mjg0NTU=",
    "number": 35,
    "title": "【Q034】如何实现一个 loading 动画",
    "body": "如何实现一个 loading 动画，可用 css 或 svg",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1NDgyMjkzMQ==",
      "body": "svg比较实在",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "chen-rongliang",
        "url": "https://github.com/chen-rongliang"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjM4MjkxMDQ=",
    "number": 36,
    "title": "【Q035】http 常见的状态码有哪些",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1NDgxODIzMw==",
      "body": "* 1XX 表示消息\r\n* 2XX 表示成功\r\n* 3XX 表示重定向\r\n* 4XX 表示客户端错误\r\n* 5XX 表示服务端错误\r\n\r\n#### 常见的状态码\r\n\r\n* 200\r\n> 最喜欢见到的状态码，表示请求成功\r\n\r\n* 301\r\n> 永久重定向\r\n\r\n* 302\r\n> 临时重定向\r\n\r\n* 304\r\n> 自上次请求，未修改的文件\r\n\r\n* 400\r\n> 错误的请求\r\n\r\n* 401\r\n> 未被授权，需要身份验证，例如token信息等等\r\n\r\n* 403\r\n> 请求被拒绝\r\n\r\n* 404\r\n> 资源缺失，接口不存在，或请求的文件不存在等等\r\n\r\n* 500\r\n> 服务器端的未知错误\r\n\r\n* 502\r\n> 网关错误\r\n\r\n* 503\r\n> 服务暂时无法使用\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "jiayankai",
        "url": "https://github.com/jiayankai"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjM4Mjk0MTg=",
    "number": 37,
    "title": "【Q036】http 状态码中 301，302和307有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1NDY4ODQ3NA==",
      "body": "+ 301，Moved Permanently。永久重定向，该操作比较危险，需要谨慎操作：如果设置了301，但是一段时间后又想取消，但是浏览器中已经有了缓存，还是会重定向。\r\n+ 302，Found。临时重定向，但是会在重定向的时候改变 method: 把 POST 改成 GET，于是有了 307\r\n+ 307，Temporary Redirect。临时重定向，在重定向时不会改变 method\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjM5NTQ1NjY=",
    "number": 38,
    "title": "【Q037】linux 有哪些发行版，你最喜欢哪一个",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      },
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1NTAwNjY1Mw==",
      "body": "我最喜欢的Linux发行版是Centos，第二喜欢的是Ubuntu。Centos在服务器上很好用，Ubuntu做开发环境很好用。",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "zhangzl419",
        "url": "https://github.com/zhangzl419"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjQzMDM3ODE=",
    "number": 39,
    "title": "【Q038】使用 react 实现一个通用的 message 组件",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1MjQzNjE1ODQ=",
    "number": 40,
    "title": "【Q039】redis 的持久化方案有哪些",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjY2OTk3OTM5",
        "name": "redis"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2OTAyNjM1MQ==",
      "body": " rdb aof 主从复制+哨兵\r\nrdb是全量  aof 是增量 ",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "Carrie999",
        "url": "https://github.com/Carrie999"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjQ4MzAwODA=",
    "number": 41,
    "title": "【Q040】k8s 由那些组件组成",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjYwMTIxNDcw",
        "name": "k8s"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1MjQ5ODUyMzY=",
    "number": 42,
    "title": "【Q041】CoW 策略指什么，docker 中有哪些应用",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      },
      {
        "id": "MDU6TGFiZWwxNjg1NjEyMDI0",
        "name": "docker"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1MjU3NzExNTQ=",
    "number": 43,
    "title": "【Q042】docker 中如何查看某个容器消耗的内存和CPU",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjg1NjEyMDI0",
        "name": "docker"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1NTk4MjU5MA==",
      "body": "``` bash\r\n$ docker stats postgres\r\nCONTAINER ID        NAME                CPU %               MEM USAGE / LIMIT     MEM %               NET I/O             BLOCK I/O           PIDS\r\nadb85849e229        postgres            0.00%               3.328MiB / 1.796GiB   0.18%               0B / 0B             874GB / 2.6GB       7\r\n\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjU4MDc3NjY=",
    "number": 44,
    "title": "【Q043】如何使用命令查看一个文件有多少字符以及多少行",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcxMzIzMTc2NQ==",
      "body": "wc，及 `word count`，用以统计一个文件的行数、单词数、字符数及文件大小\r\n\r\n``` bash\r\n# 97 - lines\r\n# 177 - words\r\n# 5087 - bytes\r\n$ wc Readme.md\r\n97  177 5087 Readme.md\r\n\r\n# -m 用以统计字符数\r\n$ wc -m Readme.md\r\n3107 Readme.md\r\n```\r\n\r\n\r\n相关问题：\r\n\r\n+ [Vim 中如何查看文件的行数及字符数](https://github.com/shfshanyue/Daily-Question/issues/45)\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjU4MDkzNzk=",
    "number": 45,
    "title": "【Q044】如何使用vim查看文件有多少个字符以及多少行",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjg3OTAxMzk2",
        "name": "vim"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcxMzIzMDA1OA==",
      "body": "在 `Normal` 模式下，可以通过快捷键 `g + <Ctrl-g>` 查看文件行数、列数、字符数及所占字节大小，此时状态栏(即 vim 最底下一行)显示如下：\r\n\r\n``` txt\r\nCol 1 of 10; Line 28 of 161; Word 71 of 377; Char 636 of 4315; Byte 768 of 4969\r\n```\r\n\r\n如果**仅仅想要了解文件行数及列数**，可以通过快捷键 `<Ctrl-g>` 查看，此时状态栏如下\r\n\r\n``` txt\r\n\"package.json\" 行 14 / 42 --33%-- 列 5\r\n```\r\n\r\n![image](https://user-images.githubusercontent.com/13389461/97083635-f725c680-1643-11eb-8716-75a88ad14edc.png)\r\n\r\n如果**仅仅想要了解文件行数**，可以通过快捷键 `G` 直接移动到文件最后一行来查看行数\r\n\r\n## 相关问题：\r\n\r\n+ [Linux 中如何使用命令查看文件的行数及字符数](https://github.com/shfshanyue/Daily-Question/issues/44)\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjU4MjAwNDE=",
    "number": 46,
    "title": "【Q045】如何把一个 CIDR 地址转化为IP地址范围段",
    "body": "如 `172.16.0.0/27` 的IP范围是多少",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
        "name": "network"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1MjU4MjcwODc=",
    "number": 47,
    "title": "【Q046】docker 中的网络隔离是如何实现的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjg1NjEyMDI0",
        "name": "docker"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1NjAxODkxNQ==",
      "body": "参考: https://docs.docker.com/network/iptables/",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjY2MTA3NDk=",
    "number": 48,
    "title": "【Q047】如何设计一个高并发系统",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1MjY2MTM0MTI=",
    "number": 49,
    "title": "【Q048】如何实现一个优先级队列",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
        "name": "algorithm"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1MjY5MjA3MTI=",
    "number": 50,
    "title": "【Q049】什么是守护进程",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
        "name": "os"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1OTcwNzYyOQ==",
      "body": "守护进程，可以被认为是后台进程，当你把控制台关闭时，它仍然还会运行。\r\n\r\n当然 - 这只是表面，从更深层次看呢？",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjcwNjMyNjg=",
    "number": 51,
    "title": "【Q050】http 状态码 502 和 504 有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1NzQ3NTAyNw==",
      "body": "* 502 Bad Gateway\r\nThe server was acting as a gateway or proxy and received an invalid response from the upstream server.\r\n收到了上游响应但无法解析\r\n\r\n* 504 Gateway Timeout\r\nThe server was acting as a gateway or proxy and did not receive a timely response from the upstream server.\r\n上游响应超时\r\n",
      "star": {
        "totalCount": 1
      },
      "author": {
        "login": "sjfkai",
        "url": "https://github.com/sjfkai"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjc0NzQxMDI=",
    "number": 52,
    "title": "【Q051】简述一下 graphql，它的引进有什么好处",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkyOTk0Mjk2",
        "name": "graphql"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1Mjc0NzQ0MTc=",
    "number": 53,
    "title": "【Q052】graphql 的引进有什么风险，以及性能问题",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkyOTk0Mjk2",
        "name": "graphql"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1Mjc1MzEwMDA=",
    "number": 54,
    "title": "【Q053】什么是对象存储，与块存储和文件存储有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
        "name": "os"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1Mjc3MDM1MTU=",
    "number": 55,
    "title": "【Q054】简述TCP 的三次握手",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
        "name": "network"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1OTcwNTkzMw==",
      "body": "我：你在吗？\r\n他： 我在的。\r\n我： 那开始聊天吧",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "WenHaiYana",
        "url": "https://github.com/WenHaiYana"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjc3ODA5MDQ=",
    "number": 56,
    "title": "【Q055】如何在 linux 中打印所有环境变量",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1OTY3OTYxNA==",
      "body": "``` shell\r\n$ printenv\r\nXDG_SESSION_ID=10536\r\nHOSTNAME=shanyue\r\nTERM=xterm-256color\r\nSHELL=/bin/bash\r\nHISTSIZE=1000\r\nSSH_CLIENT=124.200.184.74 16003 22\r\nSSH_TTY=/dev/pts/0\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjc4NzYwMjU=",
    "number": 57,
    "title": "【Q056】什么是服务降级",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
        "name": "micro-service"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1Mjc4NzkzNzE=",
    "number": 58,
    "title": "【Q057】什么是熔断机制，微服务如何做熔断",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
        "name": "micro-service"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1ODk0ODU0OA==",
      "body": "TODO",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjc5MzkyNjU=",
    "number": 59,
    "title": "【Q058】什么是负载均衡",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
        "name": "micro-service"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1Mjg0Njk3NTU=",
    "number": 60,
    "title": "【Q059】四层负载均衡与七层负载均衡有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
        "name": "micro-service"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1OTcwNzQ5OQ==",
      "body": "TODO",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjg0NzAzNTI=",
    "number": 61,
    "title": "【Q060】你们项目中的计划任务是如何组织的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      },
      {
        "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
        "name": "micro-service"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1OTcwNzU1NQ==",
      "body": "TODO\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjg0NzE0MDg=",
    "number": 62,
    "title": "【Q061】如何判断两个链表是否相交",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
        "name": "algorithm"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2MzA5MDI0MQ==",
      "body": "只判断链表相交，好一点的方式是用双指针+哈希表。\r\n同时遍历a，b链表，如果当前a和b所在元素不在哈希表，则将元素加入哈希表。知道找到哈希表里面重复元素则算相交。时间复杂度o(max(a, b))是a，b不想交部分的较大值。空间复杂度是o(a + b)，a和b不想交部分。\r\n\r\n第二种是遍历a和b，判断尾指针是否相等。时间复杂度o(a + b)，空间复杂度o(1)。\r\n\r\n进阶问题是，找到相交链表的第一个相交点",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "wython",
        "url": "https://github.com/wython"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjkwMzQxMDE=",
    "number": 63,
    "title": "【Q062】RPC 与 REST 有什么优劣",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
        "name": "micro-service"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1OTcwNzQ1Mw==",
      "body": "TODO",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjkwMzc1Mzk=",
    "number": 64,
    "title": "【Q063】SIGINT SIGTERM SIGKILL 有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
        "name": "os"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1OTcwNzM5OA==",
      "body": "TODO",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjkwNDE0MzU=",
    "number": 65,
    "title": "【Q064】如何实现服务发现 (Service Discovery)",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
        "name": "micro-service"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1OTcwNzM0NQ==",
      "body": "TODO: k8s 的服务发现是如何实现的",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjkwNDE4MzI=",
    "number": 66,
    "title": "【Q065】有没有使用过 oss，对象存储相比块存储和文件存储有什么优缺点",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
        "name": "os"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1OTcwNzIzOA==",
      "body": "OSS 兼具分布式与读取速度的平衡吧",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjkxMzEzOTk=",
    "number": 67,
    "title": "【Q066】如何使用 react hooks 实现 useFetch 请求数据",
    "body": "比如设计成 `useFetch` 这种形式，它的 API 应该如何设计",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1ODk0NDYyMg==",
      "body": "可以参考 [How to fetch data with React Hooks?](https://www.robinwieruch.de/react-hooks-fetch-data)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjkxNDIxODg=",
    "number": 68,
    "title": "【Q067】react 如何使用 render prop component 请求数据",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1ODk0ODM4Mg==",
      "body": "参考: <https://www.robinwieruch.de/react-fetching-data#how-to-fetch-data-in-render-props>",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjk2MjYxNzA=",
    "number": 69,
    "title": "【Q068】React Portal 有哪些使用场景",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1OTY0ODY2MQ==",
      "body": "> Portals provide a first-class way to render children into a DOM node that exists outside the DOM hierarchy of the parent component.\r\n\r\n在以前， `react` 中所有的组件都会位于 `#app` 下，而使用 `Portals` 提供了一种脱离 `#app` 的组件。\r\n\r\n因此 `Portals` 适合脱离文档流(out of flow) 的组件，特别是 `position: absolute` 与 `position: fixed` 的组件。比如模态框，通知，警告，goTop 等。\r\n\r\n以下是官方一个模态框的示例，可以在以下地址中测试效果 <https://codepen.io/gaearon/pen/jGBWpE?editors=1010>\r\n\r\n\r\n``` html\r\n<html>\r\n  <body>\r\n    <div id=\"app\"></div>\r\n    <div id=\"modal\"></div>\r\n    <div id=\"gotop\"></div>\r\n    <div id=\"alert\"></div>\r\n  </body>\r\n</html>\r\n```\r\n\r\n\r\n``` jsx\r\nconst modalRoot = document.getElementById('modal');\r\n\r\nclass Modal extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.el = document.createElement('div');\r\n  }\r\n\r\n  componentDidMount() {\r\n    modalRoot.appendChild(this.el);\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    modalRoot.removeChild(this.el);\r\n  }\r\n\r\n  render() {\r\n    return ReactDOM.createPortal(\r\n      this.props.children,\r\n      this.el,\r\n    );\r\n  }\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjk2MjY5OTE=",
    "number": 70,
    "title": "【Q069】什么是 virtual DOM，它的引入带了什么好处",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2OTA3NDAyNQ==",
      "body": "- 虚拟 DOM 最大的优势在于抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种 GUI。\r\n-  vdom 把渲染过程抽象化了，从而使得组件的抽象能力也得到提升，并且可以适配 DOM 以外的渲染目标。\r\n\r\n\r\n- Virtual DOM 在牺牲(牺牲很关键)部分性能的前提下，增加了可维护性，这也是很多框架的通性。\r\n实现了对 DOM 的集中化操作，在数据改变时先对虚拟 DOM 进行修改，再反映到真实的 DOM中，用最小的代价来更新DOM，提高效率(提升效率要想想是跟哪个阶段比提升了效率，别只记住了这一条)。\r\n- 打开了函数式 UI 编程的大门。\r\n- 可以渲染到 DOM 以外的端，使得框架跨平台，比如 ReactNative，React VR 等。\r\n- 可以更好的实现 SSR，同构渲染等。这条其实是跟上面一条差不多的。\r\n- 组件的高度抽象化。\r\n\r\n> 虚拟 DOM 的缺点\r\n- 首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢。\r\n- 虚拟 DOM 需要在内存中的维护一份 DOM 的副本(更上面一条其实也差不多，上面一条是从速度上，这条是空间上)。\r\n- 如果虚拟 DOM 大量更改，这是合适的。但是单一的，频繁的更新的话，虚拟 DOM 将会花费更多的时间处理计算的工作。所以，如果你有一个DOM 节点相对较少页面，用虚拟 DOM，它实际上有可能会更慢。但对于大多数单页面应用，这应该都会更快。\r\n",
      "star": {
        "totalCount": 9
      },
      "author": {
        "login": "libin1991",
        "url": "https://github.com/libin1991"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjk5MzIxOTA=",
    "number": 71,
    "title": "【Q070】如何用 linux 命令输出文件的特定行",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1OTYzNTA3Mg==",
      "body": "通常使用 `sed` 命令打印特定行，如\r\n\r\n``` bash\r\n# -n: 按特定格式打印\r\n# 100p: 指打印第一百行\r\n$ sed -n 100p Readme.md\r\n```\r\n\r\n但 `sed` 打印的本领，远不止于此，除了打印特定行，还可以打印一段范围的行，如\r\n\r\n``` bash\r\n# 打印文件中第 100-120 行\r\n$ sed -n 100,120p Readme.md\r\n\r\n# 打印文件中第 100-120 行\r\n$ sed -n 100,+20p Readme.md\r\n```\r\n\r\n还有一种本办法，`head`/`tail` 的组合命令，以要输出第100行为例\r\n\r\n``` bash\r\n# 输出前100行，再通过 pipe，输出最后一行\r\n$ head -100 Readme.md | tail -1\r\n```\r\n\r\n关于 `sed` 更多的用法可以参考我的文章: [sed 命令详解及示例](https://shanyue.tech/op/linux-sed.html)\r\n\r\n## 总结\r\n\r\n两种方法\r\n\r\n1. `sed -n 100p Readme.md`\r\n1. `head -100 Readme.md | tail -1`",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA1Nzc4MjA=",
    "number": 72,
    "title": "【Q071】react 与 vue 数组中 key 的作用是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      },
      {
        "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
        "name": "vue"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYxOTMwODgxNQ==",
      "body": "diff算法需要比对虚拟dom的修改，然后异步的渲染到页面中，当出现大量相同的标签时，vnode会首先判断key和标签名是否一致，如果一致再去判断子节点一致，使用key可以帮助diff算法提升判断的速度，在页面重新渲染时更快消耗更少",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "su-imagine",
        "url": "https://github.com/su-imagine"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA1ODYyNDI=",
    "number": 73,
    "title": "【Q072】webpack 是用来做什么的，原理是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
        "name": "webpack"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2OTE3MTUzNg==",
      "body": "https://juejin.im/post/5e01de37f265da33ab637daf?utm_source=gold_browser_extension",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "lf75152798",
        "url": "https://github.com/lf75152798"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA1ODgzMTQ=",
    "number": 74,
    "title": "【Q073】webpack 中的 loader 的作用是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
        "name": "webpack"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2OTM4MTQ5Mw==",
      "body": "哎  lodaer 的作用就是处理单个文件的  跳到这啥都没有",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "wang120140",
        "url": "https://github.com/wang120140"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA1ODg1MTY=",
    "number": 75,
    "title": "【Q074】有没有自己写过一个webpack的loader",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
        "name": "webpack"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2OTM4MTUyOA==",
      "body": "我看过源码 没有写过",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "wang120140",
        "url": "https://github.com/wang120140"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA1ODg2MTQ=",
    "number": 76,
    "title": "【Q075】webpack 中plugin的作用是什么，有没有自己写过",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
        "name": "webpack"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1MzA1ODkyODU=",
    "number": 77,
    "title": "【Q076】如何设计一个短网址生成服务",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
        "name": "micro-service"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDgwNDU3OTY5Mg==",
      "body": "建立一张表存储长链和短链接的对应关系，把长链接按照规则或随机生成短链接，且要保证短链接生成后唯一\r\n每次点击短链接的时候，就去查询长链接出来替换就可以了\r\n\r\n工作需要，用过百度提供的转短链接服务！！！\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "maqiang123",
        "url": "https://github.com/maqiang123"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjMzNzQ=",
    "number": 78,
    "title": "【Q077】使用 webpack 时如何优化项目体积",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
        "name": "webpack"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYxMDEzMzg3Mg==",
      "body": "使用用uglyfly进行代码压缩，使用commonsChunk分离第三方代码",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "izhangjinzhe",
        "url": "https://github.com/izhangjinzhe"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjM4NTA=",
    "number": 79,
    "title": "【Q078】webpack 中什么是 HMR，原理是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
        "name": "webpack"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDgwNTUyMDc5OA==",
      "body": "HMR（Hot Module Replacement），热更新又称热替换，基于 webpack-dev-server。\r\n第一步：webpack 对文件系统进行 watch 打包到内存中\r\n第二步：devServer 通知浏览器端文件发生改变，在这一阶段，sockjs 是服务端和浏览器端之间的桥梁，在启动 devServer 的时候，sockjs 在服务端和浏览器端建立了一个 webSocket 长连接，以便将 webpack 编译和打包的各个阶段状态告知浏览器\r\n第三步：webpack-dev-server/client 接收到服务端消息做出响应\r\n第四步：webpack 接收到最新 hash 值验证并请求模块代码\r\n第五步：HotModuleReplacement.runtime 对模块进行热更新\r\n第六步：调用accept 方法，及时将新后的内容插入到页面中",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "wjw-gavin",
        "url": "https://github.com/wjw-gavin"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjQ0NjY=",
    "number": 80,
    "title": "【Q079】简述 http 的缓存机制",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2NTg5MTI5OA==",
      "body": "强缓存 协商缓存",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "xjx-me",
        "url": "https://github.com/xjx-me"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjQ2Mzk=",
    "number": 81,
    "title": "【Q080】使用 webpack 打包时，如何更好地利用 long term cache",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
        "name": "webpack"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYxMjM2MjM1NQ==",
      "body": "查阅了很多前辈的资料，总结大致如下：（最后附上链接）\r\nlong term cache即“持久性缓存”\r\nUse [chunkhash] to add a content-dependent cache-buster to each file.\r\nUse compiler stats to get the file names when requiring resources in HTML.\r\nGenerate the chunk-manifest JSON and inline it into the HTML page before loading resources.\r\nEnsure that the entry point chunk containing the bootstrapping code doesn’t change its hash over time for the same set of dependencies.\r\n\r\n1.使用 [chunkhash] 为每个文件增加一个内容相关的缓存清道夫；\r\nSeparate development and production configs and use [name].js for development and [name].[chunkhash].js in production.\r\n\r\n2.使用编译统计在 HTML 中获取资源时取得文件名；[html-webpack-plugin](https://github.com/jantimon/html-webpack-plugin)\r\n\r\n3.生成 JSON 格式的模块清单文件，并在 HTML 页面加载资源之前内联进去；\r\nTo fix that, we should use [chunk-manifest-webpack-plugin](https://github.com/diurnalist/chunk-manifest-webpack-plugin) which will extract that manifest to a separate JSON file. \r\n\r\n4.保证包含启动代码的入口块不会对于同样的依赖生成不同的哈希值；（3.x 以前的版本是使用 CommonsChunkPlugin 来做代码分离的——将公共库(vendor)和应用程序代码分离开来，并创建一个显式的vendor chunk以防止它频繁更改。而 webpack 4.x 则是把相关的功能包到了optimization.splitChunks中，直接使用该配置就可以实现代码分离。）\r\n\r\n[代码示例](https://github.com/okonet/webpack-long-term-cache-demo)版本：\"webpack\": \"^1.10.1\"\r\n资料来源：\r\n[webpack中文文档](https://www.webpackjs.com/guides/caching/)\r\n[Webpack Freestyle 之 Long Term Cache](https://zhuanlan.zhihu.com/p/27710902)\r\n[Long-term caching of static assets with Webpack](https://codeburst.io/long-term-caching-of-static-assets-with-webpack-1ecb139adb95#.9ro7cpngr)\r\n[用 webpack 实现持久化缓存](https://sebastianblade.com/using-webpack-to-achieve-long-term-cache/#webpack)\r\n[Webpack 的静态资源持久缓存](https://zcfy.cc/article/long-term-caching-of-static-assets-with-webpack-1204.html)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "SageSanyue",
        "url": "https://github.com/SageSanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjQ3OTk=",
    "number": 82,
    "title": "【Q081】http proxy 的原理是什么",
    "body": "如 `webpack-dev-server` 可以设置 proxy，`nginx` 也可以设置",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2NTM1NTQyMA==",
      "body": "todo",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjQ5NzM=",
    "number": 83,
    "title": "【Q082】随着 http2 的发展，webpack 有没有更好的打包方案",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
        "name": "webpack"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjUyMDk=",
    "number": 84,
    "title": "【Q083】网站性能优化都有哪些点",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      },
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDgwNTU0MTQ4NQ==",
      "body": "减少http请求次数：\r\nCSS Sprites, JS、CSS源码压缩、图片大小适当控制；\r\n网页Gzip，CDN托管，data缓存 ，图片服务器。\r\n尽量减少内联样式\r\n将脚本放在底部 \r\n少用全局变量、缓存DOM节点查找的结果\r\n图片预加载\r\n按需加载",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "wjw-gavin",
        "url": "https://github.com/wjw-gavin"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjUzODQ=",
    "number": 85,
    "title": "【Q084】随着 http2 的发展，前端性能优化中的哪些传统方案可以被替代",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2MjA5NjA4MA==",
      "body": "1. 雪碧图\r\n1. 资源文件合并",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjU0NzI=",
    "number": 86,
    "title": "【Q085】http2 与 http1.1 有什么改进",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2ODkxNTczOQ==",
      "body": "1. 二进制分帧\r\n1. 请求多路复用 (Stream/Frame)\r\n1. 头部压缩: (HPack)\r\n1. 服务端推送: (PUSH_PROMISE)\r\n\r\n可参考文章 [http2 详解](https://juejin.im/post/5b88a4f56fb9a01a0b31a67e)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjU2Nzk=",
    "number": 87,
    "title": "【Q086】Tree Shaking 的原理是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
        "name": "webpack"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2ODk1MjkwNA==",
      "body": "应该是基于es6 modules的静态分析",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "coderyyx",
        "url": "https://github.com/coderyyx"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjYxMTc=",
    "number": 88,
    "title": "【Q087】什么是 CNAME 记录和 A 记录",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
        "name": "network"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2MjA5NTgwNg==",
      "body": "CNAME：域名  -> 域名\r\nA：域名 -> IP",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjY0Nzk=",
    "number": 89,
    "title": "【Q088】如何实现 promise.map，限制 promise 并发数",
    "body": "实现一个 promise.map，进行并发数控制，有以下测试用例\r\n\r\n``` js\r\npMap([1, 2, 3, 4, 5], x => Promise.resolve(x + 1))\r\n\r\npMap([Promise.resolve(1), Promise.resolve(2)], x => x + 1)\r\n\r\n// 注意输出时间控制\r\npMap([1, 1, 1, 1, 1, 1, 1, 1], x => sleep(1000), { concurrency: 2 })\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDgwMzUzMDU2Mw==",
      "body": "没人回答",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "dmwin72015",
        "url": "https://github.com/dmwin72015"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjY4NTc=",
    "number": 90,
    "title": "【Q089】vue 中 v-if 和 v-show 的区别是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
        "name": "vue"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2MTkzNDA3NQ==",
      "body": "> v-show always compiles and renders everything - it simply adds the \"display: none\" style to the element. It has a higher initial load cost, but toggling is very cheap.\r\n> Incomparison, v-if is truely conditional: it is lazy, so if its initial condition is false, it won't even do anything. This can be good for initial load time. When the condition is true, v-if will then compile and render its content. Toggling a v-if block actually tearsdown everything inside it, e.g. Components inside v-if are acually destroyed and re-created when toggled, so toggling a huge v-if block can be more expensive than v-show.\r\n\r\nv-show 总是会进行编译和渲染的工作 - 它只是简单的在元素上添加了 `display: none;` 的样式。v-show 具有较高的初始化性能成本上的消耗，但是使得转换状态变得很容易。\r\n相比之下，v-if 才是真正「有条件」的：它的加载是惰性的，因此，若它的初始条件是 false，它就不会做任何事情。这对于初始加载时间来说是有益的，当条件为 true 时，v-if 才会编译并渲染其内容。切换 v-if 下的块儿内容实际上时销毁了其内部的所有元素，比如说处于v-if下的组件实际上在切换状态时会被销毁并重新生成，因此，切换一个较大v-if块儿时会比v-show消耗的性能多。",
      "star": {
        "totalCount": 3
      },
      "author": {
        "login": "zhaofeihao",
        "url": "https://github.com/zhaofeihao"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjcwNTE=",
    "number": 91,
    "title": "【Q090】vue 中 computed 的原理是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
        "name": "vue"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2MzA1MDQzMw==",
      "body": "要讲清楚，computed原理，首先得讲vue响应式原理，因为computed的实现是基于Watcher对象的。\r\n那么vue的响应式原理是什么呢，众所周知，vue是基于Object.defineProperty实现监听的。在vue初始化数据data和computed数据过程中。会涉及到以下几个对象：\r\n1. Observe对象\r\n2. Dep对象\r\n3. Watch对象\r\nObserve对象是在data执行响应式时候调用，因为computed属性基于响应式属性，所以其不需要创建Observe对象。\r\nDep对象主要功能是做依赖收集，有个属性维护多个Watch对象，当更新时候循环调用每个Watch执行更新。\r\nWatch对象主要是用于更新，而且是收集的重点对象。\r\n\r\n这里谈到computed计算属性，首先要知道，其有两种定义方式，一种是方法，另一种是get，set属性。而且，其内部监听的对象必须是已经定义响应式的属性，比如data的属性vuex的属性。\r\n\r\nvue在创建computed属性时候，会循环所有计算属性，每一个计算属性会创建一个watch，并且在通过defineProperty定义监听，在get中，计算属性工作是做依赖收集，在set中，计算属性重要工作是重新执行计算方法，这里需要多补充一句，因为computed是懒执行，也就是说第一次初始化之后，变不会执行计算，下一次变更执行重新计算是在set中。\r\n\r\n另一个补充点是依赖收集的时机，computed收集时机和data一样，是在组件挂载前，但是其收集对象是自己属性对应的watch，而data本身所有数据对应一个watch。\r\n\r\n以下附计算属性源码验证说法：\r\n\r\n```typescript\r\n\r\nfunction initComputed (vm: Component, computed: Object) {\r\n  // $flow-disable-line\r\n  const watchers = vm._computedWatchers = Object.create(null)\r\n  // computed properties are just getters during SSR\r\n  const isSSR = isServerRendering()\r\n\r\n  for (const key in computed) {\r\n    const userDef = computed[key]\r\n    const getter = typeof userDef === 'function' ? userDef : userDef.get\r\n    if (process.env.NODE_ENV !== 'production' && getter == null) {\r\n      warn(\r\n        `Getter is missing for computed property \"${key}\".`,\r\n        vm\r\n      )\r\n    }\r\n\r\n    if (!isSSR) {\r\n      // create internal watcher for the computed property.\r\n      watchers[key] = new Watcher(\r\n        vm,\r\n        getter || noop,\r\n        noop,\r\n        computedWatcherOptions\r\n      )\r\n    }\r\n\r\n    // component-defined computed properties are already defined on the\r\n    // component prototype. We only need to define computed properties defined\r\n    // at instantiation here.\r\n    if (!(key in vm)) {\r\n      defineComputed(vm, key, userDef)\r\n    } else if (process.env.NODE_ENV !== 'production') {\r\n      if (key in vm.$data) {\r\n        warn(`The computed property \"${key}\" is already defined in data.`, vm)\r\n      } else if (vm.$options.props && key in vm.$options.props) {\r\n        warn(`The computed property \"${key}\" is already defined as a prop.`, vm)\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n可以看到，在执行new Watcher之前，会对计算属性做判断，判断其是否为函数，如果不是则取getter。这是因为计算属性有两种定义方式。之后第二步是执行deineCoumputed。这一步只是简单的调用defineProterty我就不贴代码了。\r\n\r\n关于计算属性的getter和setter定义如下：\r\n重点关注get的懒加载部分，和Watcher的定义\r\n```typescript\r\nfunction createComputedGetter (key) {\r\n  return function computedGetter () {\r\n    const watcher = this._computedWatchers && this._computedWatchers[key]\r\n    if (watcher) {\r\n      if (watcher.dirty) {\r\n        watcher.evaluate()\r\n      }\r\n      if (Dep.target) {\r\n        watcher.depend()\r\n      }\r\n      return watcher.value\r\n    }\r\n  }\r\n}\r\n\r\nfunction createGetterInvoker(fn) {\r\n  return function computedGetter () {\r\n    return fn.call(this, this)\r\n  }\r\n}\r\n```\r\n",
      "star": {
        "totalCount": 5
      },
      "author": {
        "login": "wython",
        "url": "https://github.com/wython"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjcxNzg=",
    "number": 92,
    "title": "【Q091】vue-loader 的实现原理是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
        "name": "vue"
      },
      {
        "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
        "name": "webpack"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs43Kirf",
      "body": "vue-loader会把sfc中的内容拆分为template，script，style三个“虚拟模块”，然后分别匹配webpack配置中对应的rules，比如script模块会匹配所有跟处理JavaScript或TypeScript相关的loader。\r\n\r\ntemplate中的内容会通过 vue compiler 转换为 render函数后合并到 script “虚拟模块”中。\r\n\r\nscoped style 会经过vue-loader/style-post-loader的处理，成为只匹配特定元素的私有样式。\r\n\r\n参考 [vue-loader README](https://github.com/vuejs/vue-loader/blob/master/README.md)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "hwb2017",
        "url": "https://github.com/hwb2017"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzE4MTgyMzA=",
    "number": 93,
    "title": "【Q092】react 中 ref 是干什么用的，有哪些使用场景",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2NDM4ODY5MQ==",
      "body": "**取得深层次的dom的结构。进行操作；我用过的主要是对表格滚动条的操作**",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "senbochen",
        "url": "https://github.com/senbochen"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzI1NzgxMzc=",
    "number": 94,
    "title": "【Q093】如何实现一个 LRU",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
        "name": "algorithm"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc3NDA0OTQ5Nw==",
      "body": "leetcode149\r\n1. 用双向链表+哈希。\r\n```javascript\r\n/**\r\n * @param {number} capacity\r\n */\r\nvar LRUCache = function (capacity) {\r\n    this.capacity = capacity;\r\n    this.map = new Map();\r\n    this.cache = new DoubleList();\r\n};\r\nclass Node {\r\n    constructor(k, val) {\r\n        this.k = k;\r\n        this.val = val;\r\n        this.pre = null;\r\n        this.next = null;\r\n    }\r\n}\r\nclass DoubleList {\r\n    constructor() {\r\n        this.size = 0;\r\n        this.head = new Node(0, 0);\r\n        this.tail = new Node(0, 0);\r\n        this.head.next = this.tail;\r\n        this.tail.pre = this.head;\r\n    }\r\n    addLast(x) {\r\n        const { head, tail } = this;\r\n        x.pre = tail.pre;\r\n        x.next = tail;\r\n        tail.pre.next = x;\r\n        tail.pre = x;\r\n        this.size++;\r\n    }\r\n    remove(x) {\r\n        x.pre.next = x.next;\r\n        x.next.pre = x.pre;\r\n        this.size--;\r\n    }\r\n    removeFirst() {\r\n        const { head, tail } = this;\r\n        if (head.next === tail) return null;\r\n        let first = head.next;\r\n        this.remove(first);\r\n        return first;\r\n    }\r\n}\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function (key) {\r\n    const { cache, map } = this;\r\n    if (map.has(key)) {\r\n        let x = map.get(key);\r\n        cache.remove(x);\r\n        cache.addLast(x);\r\n        return map.get(key).val;\r\n    } else {\r\n        return -1;\r\n    }\r\n};\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function (key, value) {\r\n    const { cache, map,size } = this;\r\n    const addRecently = function(key,value){\r\n        let x = new Node(key,value);\r\n        cache.addLast(x);\r\n        map.set(key,x);\r\n    }\r\n    if (map.has(key)) {\r\n        let x = map.get(key);\r\n        cache.remove(x);\r\n        map.delete(key);\r\n        addRecently(key,value);\r\n    }else{\r\n        if(cache.size=== this.capacity){\r\n            let x = cache.removeFirst();\r\n            map.delete(x.k);\r\n        }\r\n        addRecently(key,value);\r\n    }\r\n};\r\n```\r\n2. Map的巧妙使用\r\nmap放入数据是按顺序的，最新放入的数据在迭代器最后\r\n而且map的entries方法，还有keys方法，会返回一个迭代器，迭代器调用next也是顺序返回，所以返回第一个的值就是最老的，找到并删除即可\r\n```javascript\r\n/**\r\n * @param {number} capacity\r\n */\r\nvar LRUCache = function (capacity) {\r\n    this.capacity = capacity;\r\n    this.map = new Map();\r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function (key) {\r\n    const map = this.map;\r\n    let val = map.get(key);\r\n    if (val !== undefined) {\r\n        map.delete(key);\r\n        map.set(key, val);\r\n        return val;\r\n    } else {\r\n        return -1;\r\n    }\r\n\r\n};\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function (key, value) {\r\n    const { map, capacity } = this\r\n    if (map.has(key)) map.delete(key);\r\n    map.set(key, value);\r\n    if (map.size > capacity) {\r\n        map.delete(map.entries().next().value[0])\r\n    }\r\n};\r\n```\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "manyyuri",
        "url": "https://github.com/manyyuri"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzI2MzUxNDc=",
    "number": 95,
    "title": "【Q094】你们的前端代码上线部署一次需要多长时间，需要人为干预吗",
    "body": "更短的部署时间，更少的人为干预，更有利于敏捷开发",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      },
      {
        "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
        "name": "devops"
      },
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2MjA5NDkyMA==",
      "body": "TODO",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzMyMTI2OTc=",
    "number": 96,
    "title": "【Q095】k8s 中的 QoS 有哪几种类型",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjYwMTIxNDcw",
        "name": "k8s"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2MjAzNzYzNw==",
      "body": "参考官方文档：[Configure Quality of Service for Pods\r\n](https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/)，总结如下\r\n\r\n有三种类型 `Guaranteed`，`Burstable` 与 `BestEffort `\r\n\r\n+ `Guaranteed`\r\n    + Pod 里的每个容器都必须有内存 `resources.limits` 和 `resources.requests`，而且必须是一样的\r\n    + Pod 里的每个容器都必须有 CPU `resources.limits` 和 `resources.requests`，而且必须是一样的\r\n+ `Burstable`\r\n    + Pod 里至少有一个容器有内存或者 CPU `resources.requests`\r\n+ `BestEffort`\r\n    + 不设置 `resources.requests` 和 `resources.limits`",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzMyNjAxNzg=",
    "number": 97,
    "title": "【Q096】cron 表达式 (* 10 * * *) 会如何触发",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2MjA5MTA3Mg==",
      "body": "每天十点，每分钟都会执行一次",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzMyNjIyOTE=",
    "number": 98,
    "title": "【Q097】cron 表达式 (30 10 * * *) 会如何触发",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2MjA5MTIxMw==",
      "body": "每天十点半执行一次",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzMyOTUyMzQ=",
    "number": 99,
    "title": "【Q098】在 linux 中如何查看 cron 执行的情况",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2MjA5MTk0NA==",
      "body": "在 `centos` 中，查看日志文件\r\n\r\n``` bash\r\n$ tail -f /var/log/cron\r\nDec  5 19:30:01 8 CROND[24068]: (root) CMD (echo hello, world)\r\nDec  5 19:31:01 8 CROND[24084]: (root) CMD (echo hello, world)\r\nDec  5 19:31:01 8 CROND[24083]: (root) CMD (echo hello)\r\nDec  5 19:32:01 8 CROND[24094]: (root) CMD (echo hello, world)\r\nDec  5 19:32:01 8 CROND[24093]: (root) CMD (echo hello)\r\nDec  5 19:33:01 8 CROND[24104]: (root) CMD (echo hello, world)\r\nDec  5 19:33:01 8 CROND[24103]: (root) CMD (echo hello)\r\nDec  5 19:34:01 8 CROND[24113]: (root) CMD (echo hello)\r\nDec  5 19:34:01 8 CROND[24114]: (root) CMD (echo hello, world)\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzM0MDI4NzA=",
    "number": 100,
    "title": "【Q099】git 如何查看某个文件的提交历史",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzE2ODAxMDI2",
        "name": "git"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2MjE2ODM3OA==",
      "body": "``` bash\r\ngit log -p file\r\n```",
      "star": {
        "totalCount": 1
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzM0NDIzMzk=",
    "number": 101,
    "title": "【Q100】如何使用 react/vue 实现一个 message API",
    "body": "可以实现如下 API\r\n\r\n`message.info()`\r\n`message.success()`",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      },
      {
        "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
        "name": "vue"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2OTQwMzE1MQ==",
      "body": "```\r\nimport React from 'react';\r\nimport ReactDOM from 'react-dom';\r\n// info组件\r\nimport Info from 'info';\r\n// success组件\r\nimport Success from 'success';\r\n\r\nfunction createMessage(message, Com) {\r\n\r\n  let el = document.createElement('div');\r\n\r\n  document.body.appendChild(el);\r\n\r\n  const component = React.createElement(Com, {\r\n    message\r\n  });\r\n\r\n  ReactDOM.render(component, el);\r\n}\r\n\r\nconst message = {\r\n  info(message) {\r\n    return createMessage(message, Info);\r\n  },\r\n  success(message) {\r\n    return createMessage(message, Success);\r\n  },\r\n};\r\n\r\nexport default message;\r\n```\r\n主要实现思路就是创建一个div到body下，然后利用ReactDOM.render将组件渲染到这个容器下，这只是一个简单的实现，没实现关闭和多次调用",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "allan-hx",
        "url": "https://github.com/allan-hx"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzM3NTE1MTA=",
    "number": 102,
    "title": "【Q101】你们后端代码上线部署一次需要多长时间",
    "body": "关键在于考虑开发人员对项目部署流程的了解",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      },
      {
        "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
        "name": "devops"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU3MDA1ODE1Ng==",
      "body": "30分钟左右",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "fmleing",
        "url": "https://github.com/fmleing"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzM4MzM1Mzk=",
    "number": 103,
    "title": "【Q102】有没有用 npm 发布过 package，如何发布",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcyOTM4NzI3MA==",
      "body": "## 步骤\r\n\r\n1. 注册 npm 账号 https://www.npmjs.com/\r\n2. 本地通过命令行 `npm login` 登陆\r\n3. 进入到项目目录下（与 package.json 同级），在 package.json 中指定发布文件、文件夹\r\n```json\r\n{\r\n  \"name\": \"pkg-xxx\",\r\n  \"version\": \"0.0.1\",\r\n  \"main\": \"lib/index.js\",\r\n  \"module\": \"esm/index.js\",\r\n  \"typings\": \"types/index.d.ts\",\r\n  \"files\": [\r\n    \"CHANGELOG.md\",\r\n    \"lib\",\r\n    \"esm\",\r\n    \"dist\",\r\n    \"types\",\r\n  ],\r\n  ...\r\n}\r\n```\r\n执行 `npm publish --registry=https://registry.npmjs.org/` 即可发布\r\n\r\n## 其他\r\n\r\n还可以配合 [GitHub Packages](https://docs.github.com/en/free-pro-team@latest/packages/using-github-packages-with-your-projects-ecosystem/configuring-npm-for-use-with-github-packages) 发布",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "wangkailang",
        "url": "https://github.com/wangkailang"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzM5MTQ3NDA=",
    "number": 104,
    "title": "【Q103】你在工作中遇到最有挑战的事情是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU3MDA1NzQ5NQ==",
      "body": "一个人3天负责完成本来评估1周工作量的需求变更，在刚接手项目进行维护的前提下，不熟悉需要更改的业务代码实现。",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "fmleing",
        "url": "https://github.com/fmleing"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzM5MTQ5MTk=",
    "number": 105,
    "title": "【Q104】你在工作中遇到最受挫折的事情是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs45c1Ji",
      "body": "就是钱少干的多委屈",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "Carrie999",
        "url": "https://github.com/Carrie999"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzM5OTgwODg=",
    "number": 106,
    "title": "【Q105】你为什么从上家公司离职",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs45c1F_",
      "body": "俺觉得主要是钱多，去哪里其实都差不多",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "Carrie999",
        "url": "https://github.com/Carrie999"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzQ0MDA5NTk=",
    "number": 107,
    "title": "【Q106】什么是IO多路复用",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
        "name": "os"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2MjkwMTQzNg==",
      "body": "假设你的服务器要同时处理 100 个 `socket` 连接\r\n\r\n1. 开一个线程，挨个处理。这就没法处理并发了\r\n1. 开100个线程，分别处理。这么多的线程在内核态频频进进出出也很消耗性能\r\n1. 开一个线程，去检查 `socket` 是否就绪，如果就绪则再开一个线程去处理。这就是IO多路复用了\r\n\r\n`select`、`poll`、`epoll` 是三中典型的IO多路复用的系统调用，但实际上现在 `epoll` 使用的最多。当你使用 `strace` 查看 `nodejs` 某个服务的系统调用时，将会发现 `nodejs` 就是使用了 `epoll`\r\n\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzQ0MDg0MzU=",
    "number": 108,
    "title": "【Q107】什么是 Basic Auth 和 Digest Auth",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      },
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1MzQ0MTY5MDI=",
    "number": 109,
    "title": "【Q108】gzip 的原理是什么，如何配置",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2MjkwNjgyNg==",
      "body": "一句话：`gzip` 的核心是 `Deflate`，而它使用了 `LZ77` 算法与 `Huffman` 编码来压缩文件，重复度越高的文件可压缩的空间就越大。\r\n\r\n因此 `gzip` 用于 HTTP 文件传输中，比如 JS、CSS 等，**但一般不会压缩图片**。在 HTTP Response 报文中，用 `Content-Encoding` 指明使用 gzip 压缩，而以下响应头在大部分生产环境的响应报文中都可以看到！比如你现在立刻马上可以打开[我的网站](https://q.shanyue.tech)或者[百度](https://www.baidu.com)试一试。\r\n\r\n``` bash\r\n# Request Header\r\nAccept-Encoding: gzip, deflate, br\r\n\r\n# Reponse Header\r\nContent-Encoding: gzip\r\n```\r\n\r\n`gzip` 一般在反向代理那一层，如 `nginx` 进行处理，直接使用 C 语言编写，具有更好的性能。\r\n\r\n在 `nginx` 开启 `gzip`: 配置可参考 [gzip module](http://nginx.org/en/docs/http/ngx_http_gzip_module.html)\r\n\r\n``` nginx\r\ngzip on;\r\n```\r\n\r\n## LZ77\r\n\r\n## Huffman\r\n\r\n## 相关阅读\r\n\r\n+ [gzip原理与实现](https://blog.csdn.net/imquestion/article/details/16439)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzQ0NzcxNzA=",
    "number": 110,
    "title": "【Q109】可以对图片开启 gzip 压缩吗，为什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2MjkwMzYyMw==",
      "body": "不需要开启，如果开启的话，有可能使图片变的更大。如果你注意一些网站的 img 资源时，就会发现他们都没有开启 `gzip`\r\n\r\n参考: https://webmasters.stackexchange.com/questions/8382/is-gzipping-images-worth-it-for-a-small-size-reduction-but-overhead-compressing\r\n\r\n> **Don't use gzip for image or other binary files.**\r\n>\r\n> Image file formats supported by the web, as well as videos, PDFs and other binary formats, are already compressed; using gzip on them won't provide any additional benefit, and can actually make them larger. To compress images, see Optimize images.",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU0NTc0OTg=",
    "number": 111,
    "title": "【Q110】http 的请求报文与响应报文的格式是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2MzYzNzUzMA==",
      "body": "以 `nc` 模拟 http 报文如下\r\n\r\n``` bash\r\n$ nc www.baidu.com 80\r\nGET / HTTP/1.1\r\nHost: www.baidu.com\r\n\r\nHTTP/1.1 200 OK\r\nAccept-Ranges: bytes\r\nCache-Control: no-cache\r\nConnection: Keep-Alive\r\nContent-Length: 14615\r\nContent-Type: text/html\r\nDate: Tue, 10 Dec 2019 02:48:44 GMT\r\nP3p: CP=\" OTI DSP COR IVA OUR IND COM \"\r\nP3p: CP=\" OTI DSP COR IVA OUR IND COM \"\r\nPragma: no-cache\r\nServer: BWS/1.1\r\nSet-Cookie: BAIDUID=F0FC6B3A056DEA285F51A1F2F8A170BB:FG=1; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com\r\nSet-Cookie: BIDUPSID=F0FC6B3A056DEA285F51A1F2F8A170BB; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com\r\nSet-Cookie: PSTM=1575946124; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com\r\nSet-Cookie: BAIDUID=F0FC6B3A056DEA287CB2B9422E09E30E:FG=1; max-age=31536000; expires=Wed, 09-Dec-20 02:48:44 GMT; domain=.baidu.com; path=/; version=1; comment=bd\r\nTraceid: 1575946124058431156210725656341129791126\r\nVary: Accept-Encoding\r\nX-Ua-Compatible: IE=Edge,chrome=1\r\n\r\n<!DOCTYPE html><!--STATUS OK-->\r\n........内容省略\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU0NzEwNzM=",
    "number": 112,
    "title": "【Q111】http 响应头中的 ETag 值是如何生成的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2Mzg5NDAzNA==",
      "body": "关于 `etag` 的生成需要满足几个条件，至少是宽松满足\r\n\r\n1. 当文件更改时，`etag` 值必须改变。\r\n1. **尽量**便于计算，不会特别耗 CPU。这样子利用摘要算法生成 (MD5, SHA128, SHA256) 需要慎重考虑，因为他们是 CPU 密集型运算\r\n1. **必须**横向扩展，分布式部署时多个服务器节点上生成的 `etag` 值保持一致。这样子 `inode` 就排除了\r\n\r\n> 关于服务器中 `etag` 如何生成可以参考 [HTTP: Generating ETag Header](https://stackoverflow.com/questions/4533/http-generating-etag-header)\r\n\r\n以上几个条件是理论上的成立条件，那在真正实践中，应该如何处理？\r\n\r\n我们来看一下 `nginx` 中是如何做的\r\n\r\n## nginx 中 ETag 的生成\r\n\r\n我翻阅了 `nginx` 的源代码，并翻译成伪代码如下：由 last_modified 与 content_length 拼接而成\r\n\r\n``` js\r\netag = header.last_modified + header.content_lenth\r\n```\r\n\r\n可见源码位置，并在以下贴出: [ngx_http_core_modules.c](https://github.com/nginx/nginx/blob/6c3838f9ed45f5c2aa6a971a0da3cb6ffe45b61e/src/http/ngx_http_core_module.c#L1582)\r\n\r\n``` c\r\netag->value.len = ngx_sprintf(etag->value.data, \"\\\"%xT-%xO\\\"\",\r\n                                  r->headers_out.last_modified_time,\r\n                                  r->headers_out.content_length_n)\r\n                      - etag->value.data;\r\n```\r\n\r\n**总结：`nginx` 中 `etag` 由响应头的 `Last-Modified` 与 `Content-Length` 表示为十六进制组合而成。**\r\n\r\n随手在我的k8s集群里找个 `nginx` 服务测试一下\r\n\r\n``` bash\r\n$ curl --head 10.97.109.49\r\nHTTP/1.1 200 OK\r\nServer: nginx/1.16.0\r\nDate: Tue, 10 Dec 2019 06:45:24 GMT\r\nContent-Type: text/html\r\nContent-Length: 612\r\nLast-Modified: Tue, 23 Apr 2019 10:18:21 GMT\r\nConnection: keep-alive\r\nETag: \"5cbee66d-264\"\r\nAccept-Ranges: bytes\r\n```\r\n\r\n由 `etag` 计算 `Last-Modified` 与 `Content-Length`，使用 `js` 计算如下，结果相符\r\n\r\n``` js\r\n> new Date(parseInt('5cbee66d', 16) * 1000).toJSON()\r\n\"2019-04-23T10:18:21.000Z\"\r\n> parseInt('264', 16)\r\n612\r\n```\r\n\r\n## Nginx 中的 ETag 算法及其不足\r\n\r\n协商缓存用来计算资源是否返回 304，我们知道协商缓存有两种方式\r\n\r\n+ `Last-Modified`/`if-Modified-Since`\r\n+ `ETag`/`If-None-Match`\r\n\r\n既然在 `nginx` 中 `ETag` 由 `Last-Modified` 和 `Content-Length` 组成，那它便算是一个加强版的 `Last-Modified` 了，那加强在什么地方呢？\r\n\r\n**`Last-Modified` 是由一个 `unix timestamp` 表示，则意味着它只能作用于秒级的改变，而 nginx 中的 ETag 添加了文件大小的附加条件**\r\n\r\n那下一个问题：[如果 http 响应头中 ETag 值改变了，是否意味着文件内容一定已经更改](https://github.com/shfshanyue/Daily-Question/issues/113)\r\n\r\n答案：不能。\r\n\r\n**因此使用 nginx 计算 304 有一定局限性：在 1s 内修改了文件并且保持文件大小不变。但这种情况出现的概率极低就是了，因此在正常情况下可以容忍一个不太完美但是高效的算法。**\r\n\r\n## 相关问题\r\n\r\n+ [如果 http 响应头中 ETag 值改变了，是否意味着文件内容一定已经更改](https://github.com/shfshanyue/Daily-Question/issues/113)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU1Njc3NTk=",
    "number": 113,
    "title": "【Q112】如果 http 响应头中 ETag 值改变了，是否意味着文件内容一定已经更改",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2MzkyNTM2Ng==",
      "body": "不一定，由服务器中 `ETag` 的生成算法决定。详见 [#112](https://github.com/shfshanyue/Daily-Question/issues/112)\r\n\r\n比如 `nginx` 中的 `etag` 由 `last_modified` 与 `content_length` 组成，而 `last_modified` 又由 `mtime` 组成\r\n\r\n当编辑文件却未更改文件内容时，或者 `touch file`，`mtime` 也会改变，此时 `etag` 改变，但是文件内容没有更改。",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU1ODU2ODY=",
    "number": 114,
    "title": "【Q113】如何看待 toB 与 toC",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1MzU1OTAyOTc=",
    "number": 115,
    "title": "【Q114】如何查看一个文件的 inode number",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2Mzk3ODc1Nw==",
      "body": "可以使用 `ls` 或者 `stat`\r\n\r\n``` bash\r\n$ stat hello.txt\r\n  File: ‘hello.txt’\r\n  Size: 30              Blocks: 8          IO Block: 4096   regular file\r\nDevice: fd01h/64769d    Inode: 917526      Links: 1\r\nAccess: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)\r\nAccess: 2019-12-10 16:15:55.253325208 +0800\r\nModify: 2019-12-10 16:15:52.740653330 +0800\r\nChange: 2019-12-10 16:15:52.742653069 +0800\r\n\r\n$ ls -i hello.txt\r\n917526 hello.txt\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU2NTA0MDI=",
    "number": 116,
    "title": "【Q115】文件系统中 mtime、ctime 和 atime 指什么，都有什么不同",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      },
      {
        "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
        "name": "os"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2Mzk4MzQ3Nw==",
      "body": "在 `linux` 中，\r\n\r\n+ `mtime`：`modified time` 指文件内容改变的时间戳\r\n+ `ctime`：`change time` 指文件属性改变的时间戳，属性包括 `mtime`。而在 windows 上，它表示的是 `creation time`\r\n\r\n所以 `ctime` 会比 `mtime` 要大一些，使用 `stat` 查看文件属性如下\r\n\r\n``` bash\r\n$ stat hello.txt\r\n  File: ‘hello.txt’\r\n  Size: 30              Blocks: 8          IO Block: 4096   regular file\r\nDevice: fd01h/64769d    Inode: 917526      Links: 1\r\nAccess: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)\r\nAccess: 2019-12-10 16:15:55.253325208 +0800\r\nModify: 2019-12-10 16:15:52.740653330 +0800\r\nChange: 2019-12-10 16:15:52.742653069 +0800\r\n Birth: -\r\n```\r\n\r\n而 http 服务选择 `Last_Modified` 时一般会选择 `mtime`",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU2NzAxMjE=",
    "number": 117,
    "title": "【Q116】http 服务中静态文件的 Last-Modified 是根据什么生成的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2Mzk5NzU5OA==",
      "body": "一般会选文件的 `mtime`，表示文件内容的修改时间\r\n\r\n`nginx` 也是这样处理的，源码见: [ngx_http_static_module.c](https://github.com/nginx/nginx/blob/4bf4650f2f10f7bbacfe7a33da744f18951d416d/src/http/modules/ngx_http_static_module.c#L217)\r\n\r\n``` c\r\n    r->headers_out.status = NGX_HTTP_OK;\r\n    r->headers_out.content_length_n = of.size;\r\n    r->headers_out.last_modified_time = of.mtime;\r\n```\r\n\r\n关于为什么使用 `mtime` 而非 `ctime`，可以参考 [#116](https://github.com/shfshanyue/Daily-Question/issues/117)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU2ODYxNjY=",
    "number": 118,
    "title": "【Q117】既然 http 是无状态协议，那它是如何保持登录状态",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2NDAwMzA2Nw==",
      "body": "通过 cookie 或者 Authorization header 来传递凭证，在服务端进行认证",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU3ODY0ODM=",
    "number": 119,
    "title": "【Q118】有没有读过 koa 的源码，什么是洋葱模型呢",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDgwMDAzMjkzMw==",
      "body": "# 四十行代码实现一个 koa\r\n\r\n当我们在深入学习一个框架或者库时，为了了解它的思想及设计思路，也为了更好地使用和避免无意的 Bug，有时很有必要研究源码。对于 koa 这种极为简单，而应用却很广泛的框架/库更应该了解它的源码。\r\n\r\n而为了验证我们是否已足够了解它，可以实现一个仅仅具备核心功能的迷你的库。正所谓，麻雀虽小，五脏俱全。\r\n\r\n`删繁就简三秋树`，这里只用四十行代码实现一个小型的却具有其核心功能的 koa。\r\n\r\n> **源码实现：<https://github.com/shfshanyue/koa-mini>**\r\n\r\n![](https://cdn.jsdelivr.net/gh/shfshanyue/blog@latest/node/assets/koa.jpg)\r\n\r\n这是一个拥有 koa 几乎所有核心功能最简化的示例：\r\n\r\n``` js\r\nconst Koa = require('koa')\r\nconst app = new Koa()\r\n\r\napp.use(async (ctx, next) => {\r\n  console.log('Middleware 1 Start')\r\n  await next()\r\n  console.log('Middleware 1 End')\r\n})\r\n\r\napp.use(async (ctx, next) => {\r\n  console.log('Middleware 2 Start')\r\n  await next()\r\n  console.log('Middleware 2 End')\r\n\r\n  ctx.body = 'hello, world'\r\n})\r\n\r\napp.listen(3000)\r\n\r\n// output\r\n// Middleware 1 Start\r\n// Middleware 2 Start\r\n// Middleware 2 End\r\n// Middleware 1 End\r\n```\r\n\r\n在这个最简化的示例中，可以看到有三个清晰的模块，分别如下：\r\n\r\n+ Application: 基本服务器框架\r\n+ Context: 服务器框架基本数据结构的封装，用以 http 请求解析及响应\r\n+ Middleware: 中间件，也是洋葱模型的核心机制\r\n\r\n![](https://cdn.jsdelivr.net/gh/shfshanyue/blog@latest/node/assets/koa-module.jpg)\r\n\r\n我们开始逐步实现这三个模块：\r\n\r\n## 抛开框架，来写一个简单的 server\r\n\r\n我们先基于 node 最基本的 `http API` 来启动一个 http 服务，并通过它来实现最简版的 koa：\r\n\r\n``` js\r\nconst http = require('http')\r\n\r\nconst server = http.createServer((req, res) => {\r\n  res.end('hello, world')\r\n})\r\n\r\nserver.listen(3000)\r\n```\r\n\r\n而要实现最简版的 `koa` 示例如下，我把最简版的这个 koa 命名为 `koa-mini`\r\n\r\n``` js\r\nconst Koa = require('koa-mini')\r\nconst app = new Koa()\r\n\r\napp.use(async (ctx, next) => {\r\n  console.log('Middleware 1 Start')\r\n  await next()\r\n  console.log('Middleware 1 End')\r\n})\r\n\r\napp.use(async (ctx, next) => {\r\n  console.log('Middleware 2 Start')\r\n  await next()\r\n  console.log('Middleware 2 End')\r\n\r\n  ctx.body = 'hello, world'\r\n})\r\n\r\napp.listen(3000)\r\n```\r\n\r\n## 构建 Application\r\n\r\n首先完成 `Appliacation` 的大体框架：\r\n\r\n+ `app.listen`: 处理请求及响应，并且监听端口\r\n+ `app.use`: 中间件函数，处理请求并完成响应\r\n\r\n只有简单的十几行代码，示例如下：\r\n\r\n``` js\r\nconst http = require('http')\r\n\r\nclass Application {\r\n  constructor () {\r\n    this.middleware = null \r\n  }\r\n\r\n  listen (...args) {\r\n    const server = http.createServer(this.middleware)\r\n    server.listen(...args)\r\n  }\r\n\r\n  // 这里依旧调用的是原生 http.createServer 的回调函数\r\n  use (middleware) {\r\n    this.middleware = middleware\r\n  }\r\n}\r\n```\r\n\r\n此时调用 `Application` 启动服务的代码如下:\r\n\r\n``` js\r\nconst app = new Appliacation()\r\n\r\napp.use((req, res) => {\r\n  res.end('hello, world')\r\n})\r\n\r\napp.listen(3000)\r\n```\r\n\r\n由于 `app.use` 的回调函数依然是原生的 `http.crateServer` 回调函数，而在 `koa` 中回调参数是一个 `Context` 对象。\r\n\r\n下一步要做的将是构建 `Context` 对象。\r\n\r\n## 构建 Context\r\n\r\n在 koa 中，`app.use` 的回调参数为一个 `ctx` 对象，而非原生的 `req/res`。因此在这一步要构建一个 `Context` 对象，并使用 `ctx.body` 构建响应：\r\n\r\n+ `app.use(ctx => ctx.body = 'hello, world')`: 通过在 `http.createServer` 回调函数中进一步封装 `Context` 实现\r\n+ `Context(req, res)`: 以 `request/response` 数据结构为主体构造 Context 对象\r\n\r\n核心代码如下，注意注释部分：\r\n\r\n``` js\r\nconst http = require('http')\r\n\r\nclass Application {\r\n  constructor () {}\r\n  use () {}\r\n\r\n  listen (...args) {\r\n    const server = http.createServer((req, res) => {\r\n      // 构造 Context 对象\r\n      const ctx = new Context(req, res)\r\n\r\n      // 此时处理为与 koa 兼容 Context 的 app.use 函数\r\n      this.middleware(ctx)\r\n\r\n      // ctx.body 为响应内容\r\n      ctx.res.end(ctx.body)\r\n    })\r\n    server.listen(...args)\r\n  }\r\n}\r\n\r\n// 构造一个 Context 的类\r\nclass Context {\r\n  constructor (req, res) {\r\n    this.req = req\r\n    this.res = res\r\n  }\r\n}\r\n```\r\n\r\n此时 `koa` 被改造如下，`app.use` 可以正常工作：\r\n\r\n``` js\r\nconst app = new Application()\r\n\r\napp.use(ctx => {\r\n  ctx.body = 'hello, world'\r\n})\r\n\r\napp.listen(7000)\r\n```\r\n\r\n实现以上的代码都很简单，现在就剩下一个最重要也是最核心的功能：洋葱模型\r\n\r\n## 洋葱模型及中间件改造\r\n\r\n上述工作只有简单的一个中间件，然而在现实中中间件会有很多个，如错误处理，权限校验，路由，日志，限流等等。因此我们要改造下 `app.middlewares`\r\n\r\n+ `app.middlewares`: 收集中间件回调函数数组，并并使用 `compose` 串联起来\r\n\r\n对所有中间件函数通过 `compose` 函数来达到抽象效果，它将对 `Context` 对象作为参数，来接收请求及处理响应：\r\n\r\n``` js\r\n// this.middlewares 代表所有中间件\r\n// 通过 compose 抽象\r\nconst fn = compose(this.middlewares)\r\nawait fn(ctx)\r\n\r\n// 当然，也可以写成这种形式，只要带上 ctx 参数\r\nawait compose(this.middlewares, ctx)\r\n```\r\n\r\n此时完整代码如下：\r\n\r\n``` js\r\nconst http = require('http')\r\n\r\nclass Application {\r\n  constructor () {\r\n    this.middlewares = []\r\n  }\r\n\r\n  listen (...args) {\r\n    const server = http.createServer(async (req, res) => {\r\n      const ctx = new Context(req, res)\r\n\r\n      // 对中间件回调函数串联，形成洋葱模型\r\n      const fn = compose(this.middlewares)\r\n      await fn(ctx)\r\n\r\n      ctx.res.end(ctx.body)\r\n    })\r\n    server.listen(...args)\r\n  }\r\n\r\n  use (middleware) {\r\n    // 中间件回调函数变为了数组\r\n    this.middlewares.push(middleware)\r\n  }\r\n}\r\n```\r\n\r\n接下来，着重完成 `compose` 函数\r\n\r\n### 完成 compose 函数的封装\r\n\r\n![](https://cdn.jsdelivr.net/gh/shfshanyue/blog@latest/node/assets/yangcong.png)\r\n\r\nkoa 的洋葱模型指出每一个中间件都像是洋葱的每一层，当从洋葱中心穿过时，每层都会一进一出穿过两次，且最先穿入的一层最后穿出。\r\n\r\n+ `middleware`: 第一个中间件将会执行\r\n+ `next`: 每个中间件将会通过 next 来执行下一个中间件\r\n\r\n我们如何实现所有的中间件的洋葱模型呢?\r\n\r\n我们看一看每一个 middleware 的 API 如下\r\n\r\n``` js\r\nmiddleware(ctx, next)\r\n```\r\n\r\n而每个中间件中的 `next` 是指执行下一个中间件，我们来把 `next` 函数提取出来，而 `next` 函数中又有 `next`，这应该怎么处理呢？\r\n\r\n``` js\r\nconst next = () => nextMiddleware(ctx, next)\r\nmiddleware(ctx, next(0))\r\n```\r\n\r\n是了，使用一个递归完成中间件的改造，并把中间件给连接起来，如下所示:\r\n\r\n``` js\r\n// dispatch(i) 代表执行第 i 个中间件\r\n\r\nconst dispatch = (i) => {\r\n  return middlewares[i](ctx, () => dispatch(i+1))\r\n}\r\ndispatch(0)\r\n```\r\n\r\n`dispatch(i)` 代表执行第 i 个中间件，而 `next()` 函数将会执行下一个中间件 `dispatch(i+1)`，于是我们使用递归轻松地完成了洋葱模型\r\n\r\n此时，再把递归的终止条件补充上: 当最后一个中间件函数执行 `next()` 时，直接返回\r\n\r\n``` js\r\nconst dispatch = (i) => {\r\n  const middleware = middlewares[i]\r\n  if (i === middlewares.length) {\r\n    return\r\n  }\r\n  return middleware(ctx, () => dispatch(i+1))\r\n}\r\nreturn dispatch(0)\r\n```\r\n\r\n最终的 `compose` 函数代码如下:\r\n\r\n``` js\r\nfunction compose (middlewares) {\r\n  return ctx => {\r\n    const dispatch = (i) => {\r\n      const middleware = middlewares[i]\r\n      if (i === middlewares.length) {\r\n        return\r\n      }\r\n      return middleware(ctx, () => dispatch(i+1))\r\n    }\r\n    return dispatch(0)\r\n  }\r\n}\r\n```\r\n\r\n至此，koa 的核心功能洋葱模型已经完成，写个示例来体验一下吧:\r\n\r\n``` js\r\nconst app = new Application()\r\n\r\napp.use(async (ctx, next) => {\r\n  ctx.body = 'hello, one'\r\n  await next()\r\n})\r\n\r\napp.use(async (ctx, next) => {\r\n  ctx.body = 'hello, two'\r\n  await next()\r\n})\r\n\r\napp.listen(7000)\r\n```\r\n\r\n此时还有一个小小的但不影响全局的不足：异常处理，下一步将会完成异常捕获的代码\r\n\r\n## 异常处理\r\n\r\n如果在你的后端服务中因为某一处报错，而把整个服务给挂掉了怎么办？\r\n\r\n我们只需要对中间件执行函数进行一次异常处理即可：\r\n\r\n``` js\r\ntry {\r\n  const fn = compose(this.middlewares)\r\n  await fn(ctx)\r\n} catch (e) {\r\n  console.error(e)\r\n  ctx.res.statusCode = 500\r\n  ctx.res.write('Internel Server Error')\r\n}\r\n```\r\n\r\n然而在日常项目中使用时，我们**必须**在框架层的异常捕捉之前就需要捕捉到它，来做一些异常结构化及异常上报的任务，此时会使用一个异常处理的中间件：\r\n\r\n``` js\r\n// 错误处理中间件\r\napp.use(async (ctx, next) => {\r\n  try {\r\n    await next();\r\n  }\r\n  catch (err) {\r\n    // 1. 异常结构化\r\n    // 2. 异常分类\r\n    // 3. 异常级别\r\n    // 4. 异常上报\r\n  }\r\n})\r\n```\r\n\r\n## 小结\r\n\r\n`koa` 的核心代码特别简单，如果你是一个 Node 工程师，非常建议在业务之余研究一下 koa 的源码，并且自己也实现一个最简版的 koa。\r\n\r\n我源码实现的仓库为：[koa-mini](https://github.com/shfshanyue/koa-mini)",
      "star": {
        "totalCount": 2
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU3ODcwMDU=",
    "number": 120,
    "title": "【Q119】https 是如何保证报文安全的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2ODM4MDY4MA==",
      "body": "https主要解决三个安全问题：\r\n1. 内容隐私\r\n2. 防篡改\r\n3. 确认对方身份\r\n\r\nhttps并不是直接通过非对称加密传输过程，而是有握手过程，握手过程主要是和服务器做通讯，生成私有秘钥，最后通过该秘钥对称加密传输数据。还有验证证书的正确性。\r\n证书验证过程保证了对方是合法的，并且中间人无法通过伪造证书方式进行攻击。",
      "star": {
        "totalCount": 1
      },
      "author": {
        "login": "wython",
        "url": "https://github.com/wython"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU4MTAyNTc=",
    "number": 121,
    "title": "【Q120】TCP 是如何保证可靠性的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
        "name": "network"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2NDkwNDY3Nw==",
      "body": "ACK",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU4MTk4MDM=",
    "number": 122,
    "title": "【Q121】我们如何从 http 的报文中得知该服务使用的技术栈",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2NDEwMTEwMw==",
      "body": "一般有两个 response header，有时服务端为了隐蔽自己真实的技术栈会隐蔽这两个字段\r\n\r\n+ `X-Powerd-By`\r\n+ `Server`",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzYxODgyMjQ=",
    "number": 123,
    "title": "【Q122】在发送 http 请求报文时，Host 是必要的吗",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2NDgwODY1NA==",
      "body": "是有必要的，因为我们不知道会途径会不会有代理出现， 如果直接到达服务器的话，服务器是可以通过路径知道资源在哪，但是如果通过代理的话，代理无法得知具体服务器是什么地址",
      "star": {
        "totalCount": 1
      },
      "author": {
        "login": "Gloomysunday28",
        "url": "https://github.com/Gloomysunday28"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzY3MzY1NTI=",
    "number": 124,
    "title": "【Q123】如何监控文件的变动",
    "body": "当一个文件或者一个目录下的文件有所变动时能够监控到。\r\n\r\n如一些前端和后端项目在开发环境下会根据项目目录变动而重启或者重新编译",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
        "name": "os"
      },
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2NDkwNDYwMQ==",
      "body": "1. 在 node 中调用 API `fs.watch`\r\n1. 在 linux 中原理是 `inotify`，macos 中原理是 `FSEvents`，windows 中原理是 ` ReadDirectoryChangesW`\r\n1. 由于内核对文件监控更加细粒度，更加敏感，当每次修改文件时可能触发内核多次调用，需要防抖\r\n1. 注意软链接，读写权限等文件系统属性\r\n\r\n可参考文章 [How to Watch for Files Changes in Node.js](https://thisdavej.com/how-to-watch-for-files-changes-in-node-js/) 及 [精读《如何利用 Nodejs 监听文件夹》](https://github.com/dt-fe/weekly/blob/v2/059.%E7%B2%BE%E8%AF%BB%E3%80%8A%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%20Nodejs%20%E7%9B%91%E5%90%AC%E6%96%87%E4%BB%B6%E5%A4%B9%E3%80%8B.md)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzY4MDc0NDQ=",
    "number": 125,
    "title": "【Q124】如何保证内网服务的安全性",
    "body": "如 `gitlab CE` 经常暴露出重大漏洞，而它也只需要在公司内部使用。部署 `gitlab` 时我们如何保证它的安全性",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
        "name": "micro-service"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2NDk2MTA5Nw==",
      "body": "basic auth，digest auth，ip whitelist，vpn",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzY4MzU3MzA=",
    "number": 126,
    "title": "【Q125】docker 中如何为每个容器的 cpu/memory 设限，原理是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjg1NjEyMDI0",
        "name": "docker"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1Mzc0MTgzNzQ=",
    "number": 127,
    "title": "【Q126】localhost:3000 与 localhost:5000 的 cookie 信息是否共享",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
        "name": "html"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2NTM1Mjk1Mg==",
      "body": "共享",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1Mzc1NDM2MzA=",
    "number": 128,
    "title": "【Q127】vpn 的原理是什么",
    "body": "当在公司工作时经常需要 vpn 用以连接公司内网，其原理是什么",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
        "name": "network"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2ODMzMjQ2NQ==",
      "body": "正向代理",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "xinlanlan",
        "url": "https://github.com/xinlanlan"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1Mzc4ODYyMzI=",
    "number": 129,
    "title": "【Q128】构建镜像时，那几个指令会增加镜像层数",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjg1NjEyMDI0",
        "name": "docker"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2NTY5Njk1Nw==",
      "body": "`RUN`，`ADD`，`COPY`",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1Mzc5MDczNTY=",
    "number": 130,
    "title": "【Q129】shell 中 ${} 与 $() 各是什么意思",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2NTcxMjkwOQ==",
      "body": "+ `${}` 变量\r\n+ `$()` 命令",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzgxMjc4MDU=",
    "number": 131,
    "title": "【Q130】docker 如何隔离容器与宿主机的时间",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjg1NjEyMDI0",
        "name": "docker"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1MzgxMjkzODM=",
    "number": 132,
    "title": "【Q131】在 docker 的容器中，如何访问宿主机的 localhost",
    "body": "如在宿主机有一个 `mysql` 数据库，在容器中，如何连接数据库",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjg1NjEyMDI0",
        "name": "docker"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1MzgxMzEzMjg=",
    "number": 133,
    "title": "【Q132】如何在 docker 中运行 docker",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjg1NjEyMDI0",
        "name": "docker"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1MzgyNzc2Nzg=",
    "number": 134,
    "title": "【Q133】http 响应头中如果 content-type 为 application/octet-stream，则代表什么意思",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2ODYxMDg3MA==",
      "body": "代表二进制流，一般用以下载文件",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzkxMDc4ODk=",
    "number": 135,
    "title": "【Q134】ssh 的原理是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
        "name": "network"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY1MjE1ODM3OQ==",
      "body": "搬运 [图解SSH原理](https://www.jianshu.com/p/33461b619d53)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "nextprops",
        "url": "https://github.com/nextprops"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1Mzk0MjUwMzk=",
    "number": 136,
    "title": "【Q135】负载均衡有哪几种方式，它们的原理是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
        "name": "micro-service"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2Njg0NzUzOQ==",
      "body": "TODO",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDAxMzI2OTY=",
    "number": 137,
    "title": "【Q136】http 向 https 做重定向应该使用哪个状态码",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2ODYxMTc1Nw==",
      "body": "一般用作 `301` 的较为多，但是也有使用 `302`，如果开启了 `HSTS` 则会使用 `307`\r\n\r\n如知乎使用了 302，淘宝使用了 301\r\n\r\n``` bash\r\n$ curl --head www.zhihu.com\r\nHTTP/1.1 302 Found\r\nDate: Tue, 24 Dec 2019 00:13:54 GMT\r\nContent-Length: 22\r\nConnection: keep-alive\r\nServer: NWS_TCloud_IPV6\r\nLocation: https://www.zhihu.com/\r\nX-NWS-LOG-UUID: 0e28d9a1-6aeb-42cd-9f6b-00bd6cf11500\r\n\r\n$ curl --head www.taobao.com\r\nHTTP/1.1 301 Moved Permanently\r\nServer: Tengine\r\nDate: Tue, 24 Dec 2019 00:13:58 GMT\r\nContent-Type: text/html\r\nContent-Length: 278\r\nConnection: keep-alive\r\nLocation: https://www.taobao.com/\r\nVia: cache20.cn1480[,0]\r\nTiming-Allow-Origin: *\r\nEagleId: 6f3f38a815771464380412555e\r\n\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDA4MTY1NDQ=",
    "number": 138,
    "title": "【Q137】js 代码压缩 minify 的原理是什么",
    "body": "我们知道 `javascript` 代码经压缩 (uglify) 后，可以使体积变得更小，那它代码压缩的原理是什么。\r\n\r\n如果你来做这么一个功能的话，你会怎么去压缩一段 `js` 代码的体积",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2NzgxOTE4Ng==",
      "body": "https://github.com/mishoo/UglifyJS2",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDA5NjUwNTk=",
    "number": 139,
    "title": "【Q138】一个守护进程的创建步骤是什么，如何用 C 语言创建",
    "body": "#50 ",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
        "name": "os"
      },
      {
        "id": "MDU6TGFiZWwxNzQ1MjU2MzU2",
        "name": "c"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NDA5NzU5MDg=",
    "number": 140,
    "title": "【Q139】在 Node 应用中如何利用多核心CPU的优势",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2NzkyNDQyMQ==",
      "body": "使用 `cluster` 模块\r\n\r\n[Node 中 cluster 的原理是什么](https://github.com/shfshanyue/Daily-Question/issues/141)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDA5ODQ0NDI=",
    "number": 141,
    "title": "【Q140】Node 中 cluster 的原理是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
        "name": "os"
      },
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2NzkyMzY1NA==",
      "body": "1. `fork` 子进程\r\n1. `Load Balance`\r\n1. 多进程共享端口\r\n\r\n## 相关文章\r\n\r\n+ [Node 官方文档: cluster](https://nodejs.org/api/cluster.html)\r\n+ [深入浅出 node cluster](https://juejin.im/post/5c87760fe51d4507534c88e5)\r\n+ [Node.js进阶：cluster模块深入剖析](https://github.com/chyingp/nodejs-learning-guide/blob/master/%E6%A8%A1%E5%9D%97/cluster.md)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDEzMjg1MTI=",
    "number": 142,
    "title": "【Q141】http 响应头中的 Date 与 Last-Modified 有什么不同，网站部署时需要注意什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2ODE4MjMzNw==",
      "body": "+ `Date`: 报文在源服务器的产生时间，由此可查看报文已缓存了多久时间\r\n+ `Last-Modified`: 源服务器上资源的上次修改时间\r\n\r\n`LM-Factor` 与它俩有关，它处于 [0, 1] 之间，以下使用 n 来替代。\r\n\r\n简而言之，一个静态资源没有设置 `Cache-Control` 时会以这两个响应头来设置强制缓存时间：`(Date - LastModified) * n`，而非直接进行协商缓存。在涉及到 CDN 时，表现更为明显，体现在更新代码部署后，界面没有更新。",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDE0MjcyMzg=",
    "number": 143,
    "title": "【Q142】react hooks 中如何模拟 componentDidMount",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2ODg1MDAwNw==",
      "body": "在 `useEffect`，把第二个参数即依赖的状态，设置为 `[]`\r\n \r\n``` js\r\nuseEffect(callback, [])\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDE1NzE2NTk=",
    "number": 144,
    "title": "【Q143】docker-compose 部署 docker 时，如何把宿主机的环境变量注入到容器中",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjg1NjEyMDI0",
        "name": "docker"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NDE5Mzc1MTU=",
    "number": 145,
    "title": "【Q144】http 1.1 中的 keep-alive 有什么作用",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2ODYxMDUxMw==",
      "body": "在 `http 1.1` 中，在响应头中设置 `keep-alive` 可以在一个 TCP 连接上发送多个 http 请求\r\n\r\n1. 避免了重开 TCP 连接的开销\r\n1. 避免了刷新时重新建立 SSL 连接的开销\r\n1. 避免了QPS过大时，服务器的连接数过大\r\n\r\n在服务器端使用响应头开启 `keep-alive`\r\n\r\n``` bash\r\nConnection: Keep-Alive\r\nKeep-Alive: timeout=5, max=1000\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDIxMzQ2MTU=",
    "number": 146,
    "title": "【Q145】如何判断端口是否可达",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2ODc1MjAzMA==",
      "body": "使用 `nc`，`-z` 指测试接口连通性\r\n\r\n``` bash\r\nnc -vz localhost 443\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDIyMjk1OTE=",
    "number": 147,
    "title": "【Q146】如果使用 SSR，可以在 created/componentWillMount 中访问 localStorage 吗",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      },
      {
        "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
        "name": "vue"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2ODgxNzY1Mw==",
      "body": "不可以，created/componentWillMount 时，还未挂载，代码仍然在服务器中执行，此时没有浏览器环境，因此此时访问 localStorage 将会报错",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDI1NDY2MzM=",
    "number": 148,
    "title": "【Q147】当在浏览器中看到某资源使用了 http2 后，使用 curl 为什么看到的仍是 http 1.1",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYxMTM4MzY4Mg==",
      "body": "当前 curl 的版本及支持的协议以及功能特性没有支持 HTTP2",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "vczx1994",
        "url": "https://github.com/vczx1994"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDI3ODkxODU=",
    "number": 149,
    "title": "【Q148】关于 JSON，以下代码输出什么",
    "body": "``` js\r\nconst obj = {\r\n  a: 3,\r\n  b: 4,\r\n  c: null,\r\n  d: undefined,\r\n  get e () {}\r\n}\r\n\r\nconsole.log(JSON.stringify(obj))\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2OTIxNzAyNg==",
      "body": "> ``` js\r\n> const obj = {\r\n>   a: 3,\r\n>   b: 4,\r\n>   c: null,\r\n>   d: undefined,\r\n>   get e () {}\r\n> }\r\n> ```\r\n> \r\n> console.log(JSON.stringify(obj))\r\n>\r\n> 输出什么？\r\n\r\n``` js\r\n{\"a\":3,\"b\":4,\"c\":null}\r\n```\r\n\r\n对其中的 `undefined`，`function` 将在 `JSON.stringify` 时会忽略掉",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDI3OTEzMzg=",
    "number": 150,
    "title": "【Q149】什么是队首阻塞，如何解决，原理如何",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NDMxMzgwMDQ=",
    "number": 151,
    "title": "【Q150】redis 中 zset 是什么，用作什么应用场景",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjY2OTk3OTM5",
        "name": "redis"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2OTQxMjcyNQ==",
      "body": "`SortedSet`，有序集合，一般可以有两种用途\r\n\r\n1. 排行榜，TOP N 之类\r\n1. 优先级消息队列",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDM3MDQxMDM=",
    "number": 152,
    "title": "【Q151】react hooks 如何替代或部分替代 redux 功能",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2OTcwNDI4MQ==",
      "body": "我们把全局store分为两块\r\n\r\n1. 从服务器端来，如各种 `model`，此时可以使用 `swr` 直接替代。或者封装一个 `useModel`，如 `useUser`，`usePermission`\r\n1. 客户端全局 store，此时可以使用 `useReducer` 和 `useContext` 来替代",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDM3MDQ5NTA=",
    "number": 153,
    "title": "【Q152】如何实现一个 react hook，你有没有自己写过一个",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2OTcwMzM1Nw==",
      "body": "可以参考官方文档 <https://reactjs.org/docs/hooks-custom.html>\r\n\r\n自定义一个 `hook` 仅仅是一个以 `use` 打头，组合 `useState` 和 `useEffect` 或者其它 `hooks` 的一个普通函数",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDQ0MzI2MjM=",
    "number": 154,
    "title": "【Q153】权限设计中的 RABC 是指什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      },
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcwMTc0MTg3Mw==",
      "body": "RBAC: Role-Based Access Control?",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "e10101",
        "url": "https://github.com/e10101"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDQ0NTk0MjA=",
    "number": 155,
    "title": "【Q154】在 react/vue 中数组是否可以以在数组中的次序为 key",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      },
      {
        "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
        "name": "vue"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU3MDUzMjIwMg==",
      "body": "不可，key应为唯一标示，在数组变更时插入或删除后，index无法确保始终指向对应的序列",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "into-piece",
        "url": "https://github.com/into-piece"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDQ0ODE3NjM=",
    "number": 156,
    "title": "【Q155】当服务升级或者回退时，如何保证流量平滑切换",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
        "name": "micro-service"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NDQ1NDE5Mjc=",
    "number": 157,
    "title": "【Q156】如何进行代码质量检测",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      },
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU3MDE4Nzc0NA==",
      "body": "圈复杂度(Cyclomatic complexity)描写了代码的复杂度，可以理解为覆盖代码所有场景所需要的最少测试用例数量。CC 越高，代码则越不好维护\r\n\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDQ1NTcxMDg=",
    "number": 158,
    "title": "【Q157】如何管理生产环境多个数据库的配置，如何快速连接",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NDUyODExMzI=",
    "number": 159,
    "title": "【Q158】数据库 postgres 与 mysql 相比有哪些优劣",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NDUzNzQ2NDc=",
    "number": 160,
    "title": "【Q159】什么是 CSRF 攻击",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
        "name": "html"
      },
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYxMzgyMTQyOA==",
      "body": "跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。\r\n\r\n来源：[维基百科](https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "DoubleRayWang",
        "url": "https://github.com/DoubleRayWang"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDUzNzUwNDI=",
    "number": 161,
    "title": "【Q160】如何设置一个 cookie",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYxMjgxMjk3MQ==",
      "body": "HTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie使基于无状态的HTTP协议记录稳定的状态信息成为了可能。\r\n\r\n服务端是通过setCookie的响应头来设置cookie的，要设置多个cookie时，得多写几个setCookie。服务器如果希望在浏览器保存 Cookie，就要在 HTTP 回应的头信息里面，放置一个Set-Cookie字段。\r\n\r\n前端使用document.cookie属性来读写当前网页的 Cookie。写入的时候，Cookie 的值必须写成key=value的形式。\r\n\r\nCookie曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie渐渐被淘汰。由于服务器指定Cookie后，浏览器的每次请求都会携带Cookie数据，会带来额外的性能开销（尤其是在移动环境下）。新的浏览器API已经允许开发者直接将数据存储到本地，如使用 Web storage API （本地存储和会话存储）或 IndexedDB 。\r\n参考资料：\r\n[MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies)\r\n[把cookie聊清楚](https://juejin.im/post/59d1f59bf265da06700b0934)\r\n[阮一峰JavaScript教程](https://javascript.ruanyifeng.com/bom/cookie.html)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "SageSanyue",
        "url": "https://github.com/SageSanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDUzNzUwNjU=",
    "number": 162,
    "title": "【Q161】如何删除一个 cookie",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2NDgxMjkzOQ==",
      "body": "通过把该 `cookie` 的过期时间改为过去时即可删除成功，具体操作的话可以通过操作两个字段来完成\r\n\r\n1. `max-age`: 将要过期的最大秒数，设置为 `-1` 即可删除\r\n1. `expires`: 将要过期的绝对时间，存储到 `cookies` 中需要通过 `date.toUTCString()` 处理，设置为过期时间即可删除\r\n\r\n很明显，`max-age` 更为简单，以下代码可在命令行控制台中进行测试\r\n\r\n``` js\r\n// max-age 设置为 -1 即可成功\r\ndocument.cookie = 'a=3; max-age=-1'\r\n```\r\n\r\n``` js\r\n> document.cookie\r\n< \"\"\r\n\r\n> document.cookie = 'a=3'\r\n< \"a=3\"\r\n\r\n> document.cookie\r\n< \"a=3\"\r\n\r\n// 把该字段的 max-age 设置为 -1\r\n> document.cookie = 'a=3; max-age=-1'\r\n< \"a=3; max-age=-1\"\r\n\r\n// 删除成功\r\n> document.cookie\r\n< \"\"\r\n```\r\n\r\n同时，也可以使用最新关于 cookie 操作的 API: `CookieStorea API` 其中的 `cookieStore.delete(name)` 删除某个 cookie",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDU0MTk0OTE=",
    "number": 163,
    "title": "【Q162】如何禁止服务器被 ping",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY5MzM4NTQ3MA==",
      "body": "\r\n> echo \"1\" > /proc/sys/net/ipv4/icmp_echo_ignore_all\r\n\r\n\r\n[How do I disable ping responses from my system?\r\n](https://access.redhat.com/articles/7134#:~:text=To%20configure%20a%20Red%20Hat,command%20as%20the%20root%20user.&text=To%20make%20the%20changes%20persistent,to%20ICMP%20(ping)%20net.)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "iSenninha",
        "url": "https://github.com/iSenninha"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDU3MDExMDM=",
    "number": 164,
    "title": "【Q163】如何创建一个线程",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzQ1MjU2MzU2",
        "name": "c"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU3MjUzNTY3NQ==",
      "body": "创建一个最简单的线程\r\n\r\n``` c\r\n#include <pthread.h>\r\n#include <stdio.h>\r\n#include <unistd.h>\r\n\r\nvoid *thread_function(void *arg) {\r\n  printf(\"hello, world\\n\");\r\n  sleep(10);\r\n}\r\n\r\nint main() {\r\n  pthread_t thread;\r\n\r\n  pthread_create(&thread, NULL, thread_function, NULL);\r\n  pthread_join(thread, NULL);\r\n}\r\n```\r\n\r\n执行它\r\n\r\n``` bash\r\n$ gcc thread.c -std=c99 -lpthread && ./a.out\r\nhello, world\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDc0Mzk3ODI=",
    "number": 165,
    "title": "【Q164】React 中 fiber 是用来做什么的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYxMDczODQ3NA==",
      "body": "因为JavaScript单线程的特点，每个同步任务不能耗时太长，不然就会让程序不会对其他输入作出相应，React的更新过程就是犯了这个禁忌，而React Fiber就是要改变现状。\r\n而可以通过分片来破解JavaScript中同步操作时间过长的问题。\r\n\r\n把一个耗时长的任务分成很多小片，每一个小片的运行时间很短，虽然总时间依然很长，但是在每个小片执行完之后，都给其他任务一个执行的机会，这样唯一的线程就不会被独占，其他任务依然有运行的机会。\r\n\r\nReact Fiber把更新过程碎片化，每执行完一段更新过程，就把控制权交还给React负责任务协调的模块，看看有没有其他紧急任务要做，如果没有就继续去更新，如果有紧急任务，那就去做紧急任务。\r\n\r\n维护每一个分片的数据结构，就是Fiber。",
      "star": {
        "totalCount": 3
      },
      "author": {
        "login": "yuzeyang97",
        "url": "https://github.com/yuzeyang97"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDc1MTMwODM=",
    "number": 166,
    "title": "【Q165】什么是公有云，私有云，混合云以及多重云",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
        "name": "devops"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg0Mjk5ODAzNQ==",
      "body": "公有云就是阿里云 腾讯云 aws 等\r\n私有云 就是公司自己买物理机，在机房自己搭建网络，自己做虚拟机\r\n混合云 就是 公有云 + 私有云\r\n多重云 就是多个公有云",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "timtike",
        "url": "https://github.com/timtike"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDc1MzA5OTA=",
    "number": 167,
    "title": "【Q166】在C语言中，void * 是什么意思",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzQ1MjU2MzU2",
        "name": "c"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcxNTMzMTM0OA==",
      "body": "`void` 指无类型，常用在函数前，表示什么也不用返回。\r\n\r\n`*` 代表一个指针，如 `int *p` 代表指针 p 指向一个整型，`char *s` 代表指针 s 指向一个字符串的首地址。\r\n\r\n而 `void *` 代表一个可能指向任何类型的指针，如下代码所示：\r\n\r\n``` c\r\n#include <stdio.h>\r\n\r\nint main() {\r\n  void *p;\r\n\r\n  // 使用它装一个整数\r\n  int a = 3;\r\n  p = &a;\r\n  printf(\"%d\", *(int *)p);\r\n\r\n  // 使用它装一个字符串\r\n  char s[] = \"hello, world\";\r\n  p = s;\r\n  printf(\"%s\", p);\r\n  return 0;\r\n}\r\n```\r\n\r\n## 相关问题\r\n\r\n+ [【Q433】在C语言中，void 是什么意思](https://github.com/shfshanyue/Daily-Question/issues/440)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDg0MTM1MTQ=",
    "number": 168,
    "title": "【Q167】每个指针所占的存储空间是多少",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzQ1MjU2MzU2",
        "name": "c"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU3MzMwNDg5MQ==",
      "body": "与字长有关。如果是64位系统，则占八个字节，32位系统，则占四个字节。可以用 `sizeof` 测试\r\n\r\n``` c\r\n#include <stdio.h>\r\n\r\nint main() {\r\n  int *p;\r\n\r\n  printf(\"size: %d\", sizeof(p));\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDg3MTA3OTM=",
    "number": 169,
    "title": "【Q168】在 js 中如何把类数组转化为数组",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU3MzY3MTY0Mg==",
      "body": "首先，什么是类数组(Array Like)？\r\n\r\n**一个简单的定义，如果一个对象有 `length` 属性值，则它就是类数组**\r\n\r\n那常见的类数组有哪些呢？\r\n\r\n这在 DOM 中甚为常见，如各种元素检索 API 返回的都是类数组，如 `document.getElementsByTagName`，`document.querySelectorAll` 等等。除了 DOM API 中，常见的 `function` 中的 `arguments` 也是类数组\r\n\r\n那如何把类数组转化为数组呢？这是类数组操作时一个典型的场景，也是一个典型的面试题\r\n\r\n以下我们将以 `{ length: 3 }` 来指代类数组，来作为演示\r\n\r\n<!--more-->\r\n\r\n## ES6+\r\n\r\n`ES6` 中有现成的 API：`Array.from`，极为简单\r\n\r\n``` js\r\n// [undefined, undefined, undefined]\r\nArray.from({ length: 3 })\r\n```\r\n\r\n除了 `Array.from` 还有更简单的运算符 `...` 扩展运算符，不过它只能作用于 `iterable` 对象，即拥有 `Symbol(Symbol.iterator)` 属性值\r\n\r\n拥有 `Symbol(Symbol.iterator)` 属性值，意味着可以使用 `for of` 来循环迭代\r\n\r\n``` js\r\n// 适用于 iterable 对象\r\n[...document.querySelectorAll('div')]\r\n```\r\n\r\n但是严格意义上来说，它不能把类数组转化为数组，如 `{ length: 3 }`。它将会抛出异常\r\n\r\n``` js\r\n// Uncaught TypeError: object is not iterable (cannot read property Symbol(Symbol.iterator))\r\n[...{length: 3}]\r\n```\r\n\r\n## ES5\r\n\r\n在此之前，我们先不使用 `{ length: 3 }`，使用以下数据来代表类数组\r\n\r\n``` js\r\nconst arrayLike = {\r\n  0: 3,\r\n  1: 4,\r\n  2: 5,\r\n  length: 3\r\n}\r\n```\r\n\r\n在 `ES5` 中可以借用 `Array API` 通过 `call/apply` 改变 `this` 或者 `arguments` 来完成转化。\r\n\r\n最常见的转换是 `Array.prototype.slice`\r\n\r\n``` js\r\nArray.prototype.slice.call(arrayLike)\r\n```\r\n\r\n**当然由于借用 `Array API`，一切以数组为输入，并以数组为输出的 API 都可以来做数组转换，如**\r\n\r\n+ `Array` (借用 arguments)\r\n+ `Array.prototype.concat` (借用 arguments)\r\n+ `Array.prototype.slice` (借用 this)\r\n+ `Array.prototype.map` (借用 this)\r\n+ `Array.prototype.filter` (借用 this)\r\n\r\n``` js\r\nArray.apply(null, arrayLike)\r\nArray.prototype.concat.apply([], arrayLike)\r\nArray.prototype.slice.call(arrayLike)\r\nArray.prototype.map.call(arrayLike, x => x)\r\nArray.prototype.filter.call(arrayLike, x => 1)\r\n```\r\n\r\n此时一切正常，但是忘了一个特例，稀疏数组。在此之前，先做一个题，以下代码输出多少\r\n\r\n``` js\r\n// 该代码输出多少\r\nArray(100).map(x => 1)\r\n```\r\n\r\n> 参考 [Array(100).map(x => 1) 结果是多少](https://github.com/shfshanyue/Daily-Question/issues/170)\r\n\r\n## 稀疏数组 (sparse array)\r\n\r\n使用 `Array(n)` 将会创建一个稀疏数组，为了节省空间，稀疏数组内含非真实元素，在控制台上将以 `empty` 显示，如下所示\r\n\r\n`[,,,]` 与 `Array(3)` 都将返回稀疏数组\r\n\r\n``` js\r\n> [,,,]\r\n[empty × 3]\r\n> Array(3)\r\n[empty × 3]\r\n```\r\n\r\n当类数组为 `{ length: 3 }` 时，一切将类数组做为 `this` 的方法将都返回稀疏数组，而将类数组做为 `arguments` 的方法将都返回密集数组\r\n\r\n## 总结\r\n\r\n由上总结，把类数组转化成数组最靠谱的方式是以下三个\r\n\r\n``` js\r\nArray.from(arrayLike)\r\nArray.apply(null, arrayLike)\r\nArray.prototype.concat.apply([], arrayLike)\r\n```\r\n\r\n以下几种方式需要考虑稀疏数组的转化\r\n\r\n``` js\r\nArray.prototype.filter.call(divs, x => 1)\r\nArray.prototype.map.call(arrayLike, x => x)\r\nArray.prototype.filter.call(arrayLike, x => 1)\r\n```\r\n\r\n以下方法要注意是否是 `iterable object`\r\n\r\n``` js\r\n[...arrayLike]\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDg3MzAxNjc=",
    "number": 170,
    "title": "【Q169】Array(100).map(x => 1) 结果是多少",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU3MzUyNzgyOA==",
      "body": "`Array(100)` 将会创建一个稀疏数组 (sparse array)，即不存在真实元素，节省内存空间。在控制台上显示为 `[empty]`\r\n\r\n``` js\r\n// [empty × 100]\r\nArray(100)\r\n```\r\n\r\n正因为没有元素，所以它也不会有 `map` 操作，所以 `Array(100).map(x => 1)` 仍然返回为 `[empty]`\r\n\r\n**那如何生成100个元素为1的数组呢？**\r\n\r\n可以使用 `Array.from`\r\n\r\n``` js\r\nArray.from(Array(100), x => 1)\r\n```\r\n\r\n而在 `ES5` 中借用 `apply`\r\n\r\n``` js\r\nArray.apply(null, Array(100)).map(x => 1)\r\n```\r\n\r\n根据楼下提示，再添加一个 `fill`\r\n\r\n``` js\r\nArray(100).fill(1)\r\n```",
      "star": {
        "totalCount": 1
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDg4MzUzMDY=",
    "number": 171,
    "title": "【Q170】什么是文件描述符 (file descriptor)",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
        "name": "os"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU3MzU5OTE0MA==",
      "body": "`fd` 在内核中通常表示为非负整数，当进程新建或者打开文件时，内核将会返回一个文件描述符，使用它可以用来读写文件。\r\n\r\n另外，新建 `socket` 时也会产生一个文件描述符。\r\n\r\n另外，有三个特殊的文件描述符，用以表示标准输入，标准输出及标准错误\r\n\r\n+ `STDIN_FILENO`: 0\r\n+ `STDOUT_FILENO`: 1\r\n+ `STDERR_FILENO`: 2",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDkzNTkzNjc=",
    "number": 172,
    "title": "【Q171】在服务器内如何得知自己的公网IP",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU3NDAyMzI2NQ==",
      "body": "有现成的公网IP服务提供，根据 TCP 连接获得真实 IP 地址\r\n\r\n``` bash\r\n$ curl ifconfig.me\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDk0MTQ3MjE=",
    "number": 173,
    "title": "【Q172】C语言中 printf 与 puts 有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzQ1MjU2MzU2",
        "name": "c"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU3NDA2NjU1Ng==",
      "body": "```c\r\n// 支持各种格式\r\nint printf(const char *__restrict__ __format, ...);\r\n\r\n// 只支持字符串输出到 stdout，适用于只有字符串时\r\nint puts(const char *__s);\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDk0NTk5NDI=",
    "number": 174,
    "title": "【Q173】简述 UDP socket 建立的过程",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
        "name": "network"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU3NDA5OTY3MQ==",
      "body": "一图胜千言\r\n\r\n![image](https://user-images.githubusercontent.com/13389461/72334798-e3365700-36f8-11ea-9bd8-1bfd59118c01.png)\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDk1MjUwMzc=",
    "number": 175,
    "title": "【Q174】TCP 三次握手发生在 socket 建立的哪一步",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
        "name": "network"
      },
      {
        "id": "MDU6TGFiZWwxNzQ1MjU2MzU2",
        "name": "c"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NDk1MjUzNDA=",
    "number": 176,
    "title": "【Q175】如何使用 css 写一个魔方",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NDk1NzgyNjA=",
    "number": 177,
    "title": "【Q176】如何在数组中找出三个数之和为N",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
        "name": "algorithm"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NDk2MjY5NjQ=",
    "number": 178,
    "title": "【Q177】如何在 url 中传递数组",
    "body": "可以参考 [arrays in query params](https://medium.com/raml-api/arrays-in-query-params-33189628fa68)",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc0NDQwMjE0Ng==",
      "body": "在 URL 中如何传递数组这种复杂的数据，完全**取决于项目中前后端成员关于复杂数据在 URL 中传输的约定**，一般情况下可以使用以下方式来传递数组\r\n\r\n``` js\r\na=3&a=4&a=5\r\n\r\na=3,4,5\r\n\r\na[]=3&a[]=4&a[]=5\r\n\r\na[0]=3&a[1]=4&a[2]=5\r\n```\r\n\r\n但同样，需要后端开发者写一个 `querystring.parse` 来对指定的格式解析进行支持，同时也有对各种复杂 qs 支持较好的 package，比如：\r\n\r\n+ [qs: 据说是对 querystring 复杂对象解析最好的库](https://github.com/ljharb/qs#parsing-arrays)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NTAwMjQ0NjM=",
    "number": 179,
    "title": "【Q178】如何使用 css 写一个有 3D 效果的立方体",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY1NjQ0NDE0Mw==",
      "body": "`<div class=\"warp\">\r\n\t<div class=\"box box1\">1</div>\r\n    <div class=\"box box2\">2</div>\r\n    <div class=\"box box3\">3</div>\r\n    <div class=\"box box4\">4</div>\r\n    <div class=\"box box5\">5</div>\r\n    <div class=\"box box6\">6</div>\r\n</div>`\r\n`* {\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n}\r\n\r\nbody {\r\n\tperspective: none;\r\n\tperspective-origin: 50% 50%;\r\n}\r\n\r\n.warp {\r\n\twidth: 500px;\r\n\theight: 500px;\r\n\tmargin: 100px auto;\r\n\t\r\n\tposition: relative;\r\n\t\r\n\ttransform-style: preserve-3d;\r\n\t\r\n\ttransform: rotateX(45deg) rotateY(45deg);\r\n\t\r\n\tanimation: play 5s linear infinite;\r\n}\r\n\r\n.box {\r\n\twidth: 200px;\r\n\theight: 200px;\r\n\tborder: 2px solid #ccc;\r\n\t\r\n\ttext-align: center;\r\n\tline-height: 200px;\r\n\tfont-size: 150px;\r\n\tfont-weight: bold;\r\n\tcolor: #fff;\r\n\t\r\n\tposition: absolute;\r\n\ttop: 150px;\r\n\tleft: 150px;\r\n}\r\n\r\n.box1 {\r\n\tbackground: rgba(135,135,135,.3);\r\n\ttransform: rotateY(90deg) translateZ(100px);\r\n}\r\n\r\n.box2 {\r\n\tbackground: rgba(135,0,255,.3);\r\n\ttransform: rotateY(90deg) translateZ(-100px);\r\n}\r\n\r\n.box3 {\r\n\tbackground: rgba(255,125,125,.3);\r\n\ttransform: rotateX(90deg) translateZ(-100px);\r\n}\r\n\r\n.box4 {\r\n\tbackground: rgba(125,255,125,.3);\r\n\ttransform: rotateX(90deg) translateZ(100px);\r\n}\r\n\r\n.box5 {\r\n\tbackground: rgba(30,150,189,.3);\r\n\ttransform: translateZ(100px);\r\n}\r\n\r\n.box6 {\r\n\tbackground: rgba(169,150,189,.3);\r\n\ttransform: translateZ(-100px);\r\n}\r\n\r\n@keyframes play {\r\n\tfrom{ transform: rotateX(0) rotateY(0) rotateZ(0);}\r\n\tto {transform: rotateX(360deg) rotateY(180deg) rotateZ(90deg);}\r\n}`",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "lihan1k",
        "url": "https://github.com/lihan1k"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NTAxNzM3ODM=",
    "number": 180,
    "title": "【Q179】ssh 如何设置 IP whiteList",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NTAyNDUxMTk=",
    "number": 181,
    "title": "【Q180】当执行 SQL 语句 select * from user where id = 1 时发什么了什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NTA4NjI4NDc=",
    "number": 182,
    "title": "【Q181】如何实现 compose 函数，进行函数合成",
    "body": "实现一个 compose 函数，进行函数合成，比如 redux 中的 compose，react 高阶组件连续调用时的 compose\r\n\r\n\r\n``` js\r\nconst add10 = x => x + 10\r\nconst mul10 = x => x * 10\r\nconst add100 = x => x + 100\r\n\r\n// (10 + 100) * 10 + 10 = 1110\r\ncompose(add10, mul10, add100)(10)\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2MTU2NDM1NA==",
      "body": "```\r\nfunction compose() {\r\n\r\n  let fns = [...arguments];\r\n\r\n  return function() {\r\n    let args = [...arguments];\r\n    let result = fns.reduce((ret, fn) => {\r\n      ret = fn.apply(this, ret);\r\n      return Array.isArray(ret) ? ret : [ret];\r\n    }, args);\r\n    \r\n    return result;\r\n  }\r\n}\r\n\r\nlet toUpperCase = (x) => x.toUpperCase();\r\nlet exclaim = (x) => x + '!';\r\nlet shout = compose(toUpperCase,exclaim);\r\nlet str = shout('hello world');\r\nconsole.log(str);\r\n```\r\n\r\n第一次试着写，简单查了一下compose是什么意思，竟然拼凑出来了。请各位指正。  :smile:",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "RainMaker-Q",
        "url": "https://github.com/RainMaker-Q"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NTEyNzc0MDg=",
    "number": 183,
    "title": "【Q182】简述 TCP 的四次挥手，三次挥手可以吗",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
        "name": "network"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU3NTU3MjAwNQ==",
      "body": "第一次挥手 客户端 发送 fin 给服务端 \r\n第二次回收 服务端 发送 ack 给客户端\r\n中间服务端 可能还有数据传输\r\n第三次挥手 服务端 发送 fin 给客户端\r\n第四次挥手 客户端 发送 ack 给 客户端\r\n上述四个挥手 分别 类比 两人再打电话\r\nA对B说 我说完了\r\nB对A说 我知道了\r\n中间 b还有话说\r\nB再对A说 我也说完了\r\nA再对B说 我知道了\r\n双方挂断电话\r\n\r\n如果只有两次 即A对B说我说完了 而没有ack, A不确定B是否知道\"A我说完了\"这句话B听到没有\r\n同理,第三次挥手 B对A说我说完了, 还没等A回答我知道了就挂断,有可能A不知道B已经说完.\r\n\r\ntcp协议之所以可靠 就是由于 三次握手四次挥手 建立的连接, 以及ack回执机制,\r\n如果传输过程中连接断开 又会重新三次握手建立连接, 如果一直没收到ack, 发送方会一直发送相同的消息,等待另一方发ack回执回来",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "manondidi",
        "url": "https://github.com/manondidi"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NTEyOTEwMjA=",
    "number": 184,
    "title": "【Q183】tcp 中 time_wait 堆积过多会有什么问题，为什么它超时时间这么长",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
        "name": "network"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NTE3NzQ4OTE=",
    "number": 185,
    "title": "【Q184】有没有使用过 css variable，它解决了哪些问题",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU5NTY3ODE3MQ==",
      "body": "css变量减少样式重复定义，比如同一个颜色值要在多个地方重复使用，以前通过less和sass预处理做到，现在css变量也可以做到，方便维护，提高可读性\r\n```\r\n:root{\r\n  --bgcolor: blue;\r\n  --color: red;\r\n}\r\np {\r\n  color: var(--color);\r\n}\r\ndiv {\r\n  backgroung-color: var(--bgcolor);\r\n  color: var(--color)\r\n}\r\n```\r\n在媒体查询中使用，精简代码，减少冗余\r\n```\r\n.box {\r\n  --base-size: 10;\r\n  width: calc(var(--base-size)* 10px);\r\n  height: clac(var(--base-size)* 5px);\r\n  padding:calc(var(--base-size) * 1px);\r\n}\r\n@media screen and (min-width: 1480px) {\r\n  .box{\r\n    --base-size: 8;\r\n  }\r\n}\r\n```\r\n方便在js中使用\r\n```\r\n// 设置变量\r\ndocument.getElementById(\"box\").style.setPropertyValue('--color', 'pink')\r\n// 读取变量\r\ndoucment.getElementById('box').style.getPropertyValue('--color').trim()    //pink\r\n// 删除变量\r\ndocument.getElementById('box').style.removeProperty('--color')\r\n```",
      "star": {
        "totalCount": 1
      },
      "author": {
        "login": "Cicelychen",
        "url": "https://github.com/Cicelychen"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NTE3ODAwOTM=",
    "number": 186,
    "title": "【Q185】谈谈你对 styled-component 的看法",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg0NjA3MzM3Nw==",
      "body": "最为流行的 CSS-in-JS 方案",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NTE5MTYyNTY=",
    "number": 187,
    "title": "【Q186】写一个关于全排列，全组合的函数",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
        "name": "algorithm"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU3NjAwMTMxOA==",
      "body": "## `Arragement`\r\n\r\n## `Combination`",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NTIyOTkyODU=",
    "number": 188,
    "title": "【Q187】当编辑 graphql 的 query 时，如何在编辑器中自动补全",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkyOTk0Mjk2",
        "name": "graphql"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NTUwNTI0NjY=",
    "number": 189,
    "title": "【Q188】大数乘法和大数加法",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
        "name": "algorithm"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs40xWcg",
      "body": "TODO",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NTU0Mjk3NTE=",
    "number": 190,
    "title": "【Q189】performance API 中什么指标可以衡量首屏时间",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDczNjU2ODYxOA==",
      "body": "window.performance.timing,详细的可以看下这篇文章[前端性能优化衡量指标](https://serverless-action.com/fontend/fe-optimization/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%A1%A1%E9%87%8F%E6%8C%87%E6%A0%87.html#performance-api)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "nieyao",
        "url": "https://github.com/nieyao"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NTU1MjcyMDY=",
    "number": 191,
    "title": "【Q190】使用 CSS 如何画一个三角形",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYxMTQ0NDc2OA==",
      "body": "`\r\n.triangle {\r\n    width: 0px;\r\n    height: 0px;\r\n    border: 100px solid;\r\n    border-color: transparent transparent rgba(134, 241, 143,1) transparent;\r\n}\r\n`",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "Sumarina",
        "url": "https://github.com/Sumarina"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NTU1NDIxNjg=",
    "number": 192,
    "title": "【Q191】什么是 Open Graph 协议，用来做什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY1NTI0NjQwNQ==",
      "body": "Open Graph 协议可以让任何一个网页集成到社交图谱中。例如，facebook就是一种社交图谱(social graph)。\r\n一旦一个网页按照该协议进行集成，这个网页就像是社交图谱的一个节点，例如，你的网页集成了open graph协议，\r\n按照协议加入了网页的标题，描述以及图片信息等等，那么你在facebook中分享这个网页的时候，facebook就会按照\r\n你定义的内容来展示这个网页。\r\n\r\n这个协议其实很简单，主要是通过在html中加入一些元数据（meta）标签来实现，例如\r\n在head中加入meta标签，property是以og(open graph)开头, 后面跟着具体属性，content里面是属性的值，\r\n下面这段描述的就是一个类型为 video.movie，标题为 The rock，以及url和图片信息。这个例子就可以当做是\r\n为 https://www.imdb.com/title/tt0117500/ 实现了Open Graph协议、\r\n\r\n```\r\n<html prefix=\"og: http://ogp.me/ns#\">\r\n<head>\r\n<title>The Rock (1996)</title>\r\n<meta property=\"og:title\" content=\"The Rock\" />\r\n<meta property=\"og:type\" content=\"video.movie\" />\r\n<meta property=\"og:url\" content=\"http://www.imdb.com/title/tt0117500/\" />\r\n<meta property=\"og:image\" content=\"http://ia.media-imdb.com/images/rock.jpg\" />\r\n...\r\n</head>\r\n...\r\n</html>\r\n```\r\n结论：\r\n这个协议主要是Facebook提出来的，为了更好的展示用户分享的网页的内容，实现这个协议，有助于SEO优化，告诉google该网页有哪些内容，以及关键词等。\r\n\r\n可以快速实现Open Graph协议的工具有：\r\nWordpress的SEO plugin\r\n使用Facebook的Facebook Page功能\r\n\r\n \r\nReference:\r\n1. The Open Graph Protocol https://ogp.me/\r\n2. Open Graph Protocol for Facebook Explained with Examples  https://www.optimizesmart.com/how-to-use-open-graph-protocol/",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "grace-shi",
        "url": "https://github.com/grace-shi"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NTg1MjgwMzI=",
    "number": 193,
    "title": "【Q192】简述你们前端项目中资源的缓存配置策略",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      },
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NjAyNzUyNzM=",
    "number": 194,
    "title": "【Q193】如何加速 npm install",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU5NzQyOTg5Mw==",
      "body": "换成taobao源?",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "CaicoLeung",
        "url": "https://github.com/CaicoLeung"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NjAzMjk5NTM=",
    "number": 195,
    "title": "【Q194】npm i 与 npm ci 的区别是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY4MTcwOTcwOQ==",
      "body": "npm ci  (6.0版本以上)\r\n   1。会删除项目中的 `node_modules` 文件夹；\r\n   2.  会依照项目中的`package.json` 来安装确切版本的依赖项；\r\n   3. 不像 npm install, `npm ci` 不会修改你的 `package-lock.json` 但是它确实期望你的项目中有一个 - package-lock.json 文件 - 如果你没有这个文件， npm ci 将不起作用，此时必须使用 npm install",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "fariellany",
        "url": "https://github.com/fariellany"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NjA0NjEwNzY=",
    "number": 196,
    "title": "【Q195】package-lock.json 有什么作用，如果项目中没有它会怎么样，举例说明",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg0MjMzMzYyNg==",
      "body": "`packagelock.json`/`yarn.lock` 用以锁定版本号，保证开发环境与生产环境的一致性，避免出现不兼容 API 导致生产环境报错\r\n\r\n在这个问题之前，需要了解下什么是 `semver`: [什么是 semver](https://github.com/shfshanyue/Daily-Question/issues/534)。\r\n\r\n当我们在 `npm i` 某个依赖时，默认的版本号是最新版本号 `^1.2.3`，以 `^` 开头可最大限度地使用新特性，但是某些库不遵循该依赖可能出现问题。\r\n\r\n> `^1.2.3` 指 *>=1.2.3 <2.0.0*，可查看 [semver checker](https://devtool.tech/semver)\r\n\r\n*一个问题: 当项目中没有 lock 文件时，生产环境的风险是如何产生的?*\r\n\r\n演示风险过程如下:\r\n\r\n1. `pkg 1.2.3`: 首次在开发环境安装 pkg 库，为此时最新版本 `1.2.3`，`dependencies` 依赖中显示 `^1.2.3`，实际安装版本为 `1.2.3`\r\n1. `pkg 1.19.0`: 在生产环境中上线项目，安装 pkg 库，此时最新版本为 `1.19.0`，满足 `dependencies` 中依赖 `^1.2.3` 范围，实际安装版本为 `1.19.0`，**但是 `pkg` 未遵从 semver 规范，在此过程中引入了 Breaking Change**，因此此时生产环境中的 `1.1.0` 导致了 bug，且难以调试\r\n\r\n而当有了 lock 文件时，每一个依赖的版本号都被锁死在了 lock 文件，每次依赖安装的版本号都从 lock 文件中进行获取，避免了不可测的依赖风险。\r\n\r\n1. `pkg 1.2.3`: 首次在开发环境安装 pkg 库，为此时最新版本 `1.2.3`，`dependencies` 依赖中显示 `^1.2.3`，实际安装版本为 `1.2.3`，**在 lock 中被锁定版本号**\r\n1. `pkg 1.2.3`: 在生产环境中上线项目，安装 pkg 库，此时 lock 文件中版本号为 `1.2.3`，符合 `dependencies` 中 `^1.2.3` 的范围，将在生产环境安装 `1.2.3`，完美上线。",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NjI1OTIxMjI=",
    "number": 197,
    "title": "【Q196】前端中遇到过处理二进制的场景吗",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYxMzg2NDA4MA==",
      "body": "[JavaScript二进制数据处理](http://coinfaces.me/posts/handling-binary-data-using-javascript/)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "DoubleRayWang",
        "url": "https://github.com/DoubleRayWang"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NjI2NDMyNTU=",
    "number": 198,
    "title": "【Q197】什么是 TypedArray",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs408Xzx",
      "body": "[ArrayBuffer，二进制数组](https://zh.javascript.info/arraybuffer-binary-arrays)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "haotie1990",
        "url": "https://github.com/haotie1990"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NjMxNzkxMDU=",
    "number": 199,
    "title": "【Q198】如何实现类似 lodash.get 函数",
    "body": "使用 `get` 函数可避免长链的 key 时获取不到属性而出现问题，此时进行异常避免时及其服务，如 `o.a && o.a.b && o.a.b.c && o.a.b.c.d`\r\n\r\n实现类似[lodash.get](https://lodash.com/docs/4.17.15#get)，有以下测试用例:\r\n\r\n``` js\r\nconst object = { 'a': [{ 'b': { 'c': 3 } }] };\r\n \r\n//=> 3\r\nget(object, 'a[0].b.c');\r\n\r\n//=> 3\r\nget(object, 'a[0][\"b\"][\"c\"]')\r\n\r\n//=> 10086\r\nget(object, 'a[100].b.c', 10086);\r\n```\r\n\r\n问题追问:\r\n\r\n**1. 如何使用 ts 写法来实现 lodash.get 函数？**",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc1NDU0MjMzNA==",
      "body": "function lodashGet(obj,exps){\r\n    if(typeof exps !== 'string') return obj\r\n    if(typeof obj !== 'object') return obj\r\n   let res = obj\r\n   const arr = exps.split('.')\r\n    for(let i=0;i<arr.length;i++){\r\n        const exp = arr[i]\r\n        if(res[exp]){\r\n        res = res[exp]\r\n        } else{\r\n        return undefined\r\n        }\r\n    }\r\nreturn res\r\n}\r\n\r\nvar obj = {test:{arr:[{name:1}]}}\r\n\r\n\r\nlodashGet(obj,'test.arr.0.name')\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "miaooow",
        "url": "https://github.com/miaooow"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NjQ0Mzk3Mzk=",
    "number": 200,
    "title": "【Q199】如何判断文件中的换行符是 LF 还是 CRLF",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1Njg0MDM2MzU=",
    "number": 201,
    "title": "【Q200】前端如何进行多分支部署",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1Njg2NTM0NTY=",
    "number": 202,
    "title": "【Q201】js 中什么是可选链操作符，如何访问数组",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU4OTQzODU3Mw==",
      "body": "> 文档见 [可选链操作符 - MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Optional_chaining) \r\n\r\n\r\n`?.` 操作符，可以嵌套获取对象的属性值。通过获取对象属性获得的值可能是 undefined 或 null 时，可选链操作符提供了一种方法来简化被连接对象的值访问。\r\n\r\n``` javascript\r\nconst o = {}\r\n\r\n// 添加可选链之前\r\no && o.a && o.a.b && o.a.b.c && o.a.b.c.d\r\n\r\n// 添加可选链之后\r\no?.a?.b?.c?.d\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1Njg5NTUzMjc=",
    "number": 203,
    "title": "【Q202】如何实现一个深拷贝 (cloneDeep)",
    "body": "``` js\r\nconst obj = {\r\n  re: /hello/,\r\n  f () {},\r\n  date: new Date(),\r\n  map: new Map(),\r\n  list: [1, 2, 3],\r\n  a: 3,\r\n  b: 4\r\n}\r\n\r\ncloneDeep(obj)\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcyODc3MTU1NQ==",
      "body": "```js\r\nconst oldJson = { a: 1 }\r\nconst newJson = JSON.parse(JSON.stringify(oldJson))\r\noldJson.a = 2\r\nconsole.log(oldJson) // {a: 2}\r\nconsole.log(newJson) // {a: 1}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "coderwuhe",
        "url": "https://github.com/coderwuhe"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NjkzMjAxNTM=",
    "number": 204,
    "title": "【Q203】对于已经 import 但未实际使用的模块使用 webpack 还会对它打包吗？",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
        "name": "webpack"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYzNTQyOTMwMw==",
      "body": "如果开启了tree shaking应该不会打包。",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "blank121",
        "url": "https://github.com/blank121"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1Njk4NzQ5Nzg=",
    "number": 205,
    "title": "【Q204】Node 中如何判断一个路径是文件还是文件夹",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYxMTI5MTU0Ng==",
      "body": "const  statInfo = fs.lstatSync(\"./xx\").\r\nstatInfo.isDirectory()",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "PlutoCA",
        "url": "https://github.com/PlutoCA"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1Njk5ODMyNTU=",
    "number": 206,
    "title": "【Q205】Code Splitting 的原理是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
        "name": "webpack"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU5MTMzODg1MA==",
      "body": "https://www.toutiao.com/i6790221102615364108/",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "yt253284494",
        "url": "https://github.com/yt253284494"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NzE0NjE5MTU=",
    "number": 207,
    "title": "【Q206】no-cache 与 no-store 的区别是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU5OTE5MjU5MA==",
      "body": "no-cache 可以在本地缓存，可以在代理服务器缓存，但是这个缓存要服务器验证才可以使用 \r\nno-store 是禁用缓冲，本地和代理服务器都不缓冲，每次都从服务器获取",
      "star": {
        "totalCount": 1
      },
      "author": {
        "login": "lijiayi01",
        "url": "https://github.com/lijiayi01"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NzMyNDkxODA=",
    "number": 208,
    "title": "【Q207】什么是隔离级",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NzM1Njk3MTI=",
    "number": 209,
    "title": "【Q208】在 postgres 中如何查看慢查询语句",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NzM5ODUxMzc=",
    "number": 210,
    "title": "【Q209】如何得知一条 SQL 执行的时长？",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NzQ2NTEyMDc=",
    "number": 211,
    "title": "【Q210】如何判断当前环境是移动端还是PC端",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU5Mzk1MjgzNg==",
      "body": "判断 `navigator.userAgent`，对于 Android/iPhone 可以匹配以下正则\r\n\r\n``` js\r\nconst appleIphone = /iPhone/i;\r\nconst appleIpod = /iPod/i;\r\nconst appleTablet = /iPad/i;\r\nconst androidPhone = /\\bAndroid(?:.+)Mobile\\b/i; // Match 'Android' AND 'Mobile'\r\nconst androidTablet = /Android/i;\r\n```\r\n\r\n当然，不要重复造轮子，推荐一个库: <https://github.com/kaimallea/isMobile>\r\n\r\n``` js\r\nimport isMobile from 'ismobilejs'\r\n\r\nconst mobile = isMobile()\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NzQ3MzIxNzM=",
    "number": 212,
    "title": "【Q211】React hooks 中 useCallback 的使用场景是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcyNTMzMDE1Nw==",
      "body": "能想到的只有两个场景\r\n1. 作为props传递的函数，集合memo一起使用；\r\n2. 作为更新触发的依赖项\r\n主要目的是为了避免高昂的计算和不必要的重复渲染",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "newwangyiyang",
        "url": "https://github.com/newwangyiyang"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NzUxNTEzNTk=",
    "number": 213,
    "title": "【Q212】在 postgres/mysql 中如何判断当前版本是多少",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU5NDMzODQ4Mw==",
      "body": "使用 `select version()`\r\n\r\npostgres 示例如下:\r\n\r\n``` sql\r\npostgres@db:school> select version()\r\n+---------------------------------------------------------------------------------------+\r\n| version                                                                               |\r\n|---------------------------------------------------------------------------------------|\r\n| PostgreSQL 12.1 on x86_64-pc-linux-musl, compiled by gcc (Alpine 8.3.0) 8.3.0, 64-bit |\r\n+---------------------------------------------------------------------------------------+\r\nSELECT 1\r\nTime: 0.028s\r\n```\r\n\r\nmysql 示例如下：\r\n\r\n``` sql\r\n> select version()\r\n+-------------+\r\n| version()   |\r\n|-------------|\r\n| 5.6.16-log  |\r\n+-------------+\r\n1 row in set\r\nTime: 0.003s\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NzUzNjc3NTg=",
    "number": 214,
    "title": "【Q213】什么是隔离级，都有哪些隔离级",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU5NDU0ODU5Mg==",
      "body": "隔离级事关并发事务的隔离机制，ANSI SQL 中定义了四种隔离级，分别是\r\n\r\n+ Read Uncommited\r\n+ Read Committed\r\n+ Repetable Read\r\n+ Serializable",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NzU1MzU2NjM=",
    "number": 215,
    "title": "【Q214】input 中监听值的变化是在监听什么事件",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU5NDY0NTQxNg==",
      "body": "可以**实时**监听值的变化的事件有以下几种\r\n\r\n+ keypress\r\n+ keydown\r\n+ keyup\r\n+ input\r\n\r\n注: `onChange` 无法做到实时监听，因为 onChange 需要失去焦点才能触发",
      "star": {
        "totalCount": 2
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NzU5MjIyOTI=",
    "number": 216,
    "title": "【Q215】什么是跨域，如何解决跨域问题",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU5NDk3MjkzOA==",
      "body": "## 跨域\r\n\r\n**协议**，**域名**，**端口**，三者有一不一样，就是跨域\r\n\r\n案例一：`www.baidu.com` 与 `zhidao.baidu.com` 是跨域\r\n\r\n## 如何解决跨域\r\n\r\n目前有两种最常见的解决方案：\r\n\r\n1. CORS，在服务器端设置几个响应头，如 `Access-Control-Allow-Origin: *`\r\n1. Reverse Proxy，在 nginx/traefik/haproxy 等反向代理服务器中设置为同一域名\r\n1. JSONP，详解见 [JSONP 的原理是什么，如何实现](https://github.com/shfshanyue/Daily-Question/issues/447)\r\n\r\n附代码: nginx 关于跨域的配置\r\n\r\n``` conf\r\nserver {\r\n  listen 80;\r\n  server_name shanyue.tech;\r\n\r\n  location / {\r\n    # 避免非root路径404\r\n    try_files $uri $uri/ /index.html;\r\n  }\r\n\r\n  # 解决跨域\r\n  location /api {\r\n    # 或者是 http://localhost:8080\r\n    proxy_pass http://api.shanyue.tech;\r\n  }\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NzU5MjQxNDM=",
    "number": 217,
    "title": "【Q216】你对未来的工作有什么期待",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs45c2hl",
      "body": "没有期待",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "Carrie999",
        "url": "https://github.com/Carrie999"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NzU5MjQ3NTA=",
    "number": 218,
    "title": "【Q217】你对未来的三年规划和五年规划是什么样的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc4MTc3MzYzNw==",
      "body": "三年高级五年架构",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "Bob4F",
        "url": "https://github.com/Bob4F"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NzU5MjUwMTM=",
    "number": 219,
    "title": "【Q218】当你入职后发现压力过大怎么办",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs45c2cV",
      "body": "没有过大，只有钱给的少",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "Carrie999",
        "url": "https://github.com/Carrie999"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NzU5MzE2OTI=",
    "number": 220,
    "title": "【Q219】工作中你有没有很佩服的人",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NzU5MzQ0NjQ=",
    "number": 221,
    "title": "【Q220】请简述一下 event loop",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc4Njk5MDU2Ng==",
      "body": "![image](https://user-images.githubusercontent.com/19162008/109372242-850c0980-78e3-11eb-8fe6-ecb15fa5e480.png)\r\n\r\nheap（堆）：对象被分配在堆中，堆是一个用来表示一大块（通常是非结构化的）内存区域的计算机术语。\r\nstack（栈）：函数调用形成了一个由若干帧组成的栈。\r\nWebAPIS：囊括 Web 强大脚本能力的每个 API 参考资料， 包括 DOM 、所有相关的 APIs 及可以用来构建 Web 的相关接口。\r\n队列（event queue || Callback Queue）：一个 JavaScript 运行时包含了一个待处理消息的消息队列。每一个消息都关联着一个用以处理这个消息的回调函数\r\n\r\n\r\n[event loop 运行图解](http://latentflip.com/loupe/?code=c2V0VGltZW91dChmdW5jdGlvbigpewogICAgY29uc29sZS5sb2coJzEnKQp9LDApOwoKbmV3oCBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpewoKoCBjb25zb2xlLmxvZygnMicpOwoKoCByZXNvbHZlKCk7Cgp9KS50aGVuKGZ1bmN0aW9uKCl7Cgpjb25zb2xlLmxvZygnMycpCgp9KTsKCmNvbnNvbGUubG9nKCc0Jyk7Cg%3D%3D!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D)\r\n\r\n```\r\nsetTimeout(() => {\r\n    console.log(1)\r\n}, 100)\r\nconsole.log(2);\r\nsetTimeout(() => {\r\n    console.log(3)\r\n}, 0)\r\n// 2\r\n// 1\r\n// 3\r\n```\r\n\r\n![未标题-1](https://user-images.githubusercontent.com/19162008/109375818-9c0a2600-78fa-11eb-8a0f-1d65394fb6a6.gif)\r\n\r\n\r\n\r\n看图我们可以了解到，setTimeout(() => {console.log(1)}, 0) 会在Stack执行，在放入WebAPIs中当成一个匿名函数执行，匿名函数执行完毕之后会放入Callback Queue 中。\r\nconsole.log(2) 则直接被推入Stack 中执行。\r\n\r\nsetTimeout(() => {console.log(3)}, 0) 同样的执行后放入WebAPIs中当成一个匿名函数执行，在放入Callback Queue中。当同步任务执行完之后，才会将Callback Queue 队列中的方法推入Stack中。\r\n\r\n**因为JS是单线程的，单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。为了解决排除等待问题，JS的任务分为同步任务（synchronous）和异步任务（asynchronous）。\r\n所有同步任务都在主线程上执行，形成一个Stac）。异步任务（如果是WebAPI 则会进入WebAPI，例如ajax setTimeout）不进入主线程，而是进入另一 Callback Queue。同步任务顺序执行，只有执行栈中的同步任务执行完了，系统才回读取任务队列中可以执行的异步任务，才会把此异步任务从事件队列中放入执行栈中执行，如此循环，直至所有任务执行完毕。**\r\n\r\n**这就是EventLoop**\r\n\r\n\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "martin-yin",
        "url": "https://github.com/martin-yin"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NzU5MzgwOTU=",
    "number": 222,
    "title": "【Q221】作为技术负责人，你每天的工作是什么样的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NzU5Mzg0NTU=",
    "number": 223,
    "title": "【Q222】数据库中如何查看当前的连接数",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2NDgwNDEwOA==",
      "body": "**PostgresSQL 的最大连接数与当前连接数**\r\n\r\n``` sql\r\n-- 最大连接数\r\nshow max_connections;\r\n\r\n-- 当前连接数\r\nselect count(*) from pg_stat_activity;\r\n```\r\n\r\n**mysql 的最大连接数与当前连接数**\r\n\r\n``` sql\r\n-- 最大连接数\r\nshow variables like 'max_connections';\r\n\r\n-- 当前连接数\r\nshow full processlist;\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NzYyMzA2MTA=",
    "number": 224,
    "title": "【Q223】数据库查询如何更好地利用数据库缓存进行优化",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NzYyMzQ1MDM=",
    "number": 225,
    "title": "【Q224】误操作了一个 delete from 语句，如何恢复数据",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NzYzNjY1MzE=",
    "number": 226,
    "title": "【Q225】你相比去年，有哪些成长",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc5OTg3NzYwNw==",
      "body": "体重有所成长，胖了不少",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "Akishimo",
        "url": "https://github.com/Akishimo"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NzYzNzQyNDI=",
    "number": 227,
    "title": "【Q226】数据库死锁是怎么产生的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU5NTMyMDc1Mw==",
      "body": "多个事务对资源的交替顺序访问，如\r\n\r\n事务1，访问A表，A表锁住，访问B表，此时B表却被事务2锁住，等待\r\n事务2，访问B表，B表锁住，访问A表，此时A表却被事务1锁住，等待\r\n\r\n由此观之，此死锁出现的条件极为苛刻\r\n\r\n1. 并发，产生多个事务\r\n1. 顺序，对相同资源的不同顺序访问 (干嘛要不同顺序呀)\r\n1. 时机，恰好两个事物都刚刚走完了第一步\r\n\r\n[更多示例](https://www.cnblogs.com/wezheng/p/8366029.html)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NzYzODE4ODY=",
    "number": 228,
    "title": "【Q227】你如何看待996",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2OTI3NzMxOQ==",
      "body": "1. 违法\r\n2. 开历史的倒车\r\n3. 容易使员工养成加班文化。最近一新闻提到苏州微软抵制从阿里离职的在职员工搞 996、在工作群里互相攀比加班时间的现象\r\n4. 使员工更不值钱。996 工作制下只有拿到当前工资的 2.275 倍，才在经济账上不吃亏。\r\n5. 对遵循八小时工作制的员工不公平\r\n6. [工作 996，生病 ICU](https://996.icu/#/zh_CN)",
      "star": {
        "totalCount": 0
      },
      "author": null
    }
  },
  {
    "id": "MDU6SXNzdWU1NzY3MzE4MjE=",
    "number": 229,
    "title": "【Q228】如何实现一个 flatMap 函数 (头条)",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYxMzg5MTUwMg==",
      "body": "没说不让用flat；所以有个取巧的办法\r\nconst flatMap = arr => arr.flat().map(_ => _);",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "DoubleRayWang",
        "url": "https://github.com/DoubleRayWang"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NzY4Mzc5Njg=",
    "number": 230,
    "title": "【Q229】在数据库中一个字段如果是字符串类型的，那应该设置哪种数据类型",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU5NjIwNDExNg==",
      "body": "以下答案仅说明在 postgres 中的情况：\r\n\r\n在 postgres 有三种 `varchar`，`char` 以及 `text`，其中三者没有性能差异，见官方文档\r\n\r\n> Different from other database systems, in PostgreSQL, there is no performance difference among three character types. In most situation, you should use text or varchar, and varchar(n) if you want PostgreSQL to check for the length limit\r\n\r\n所以，选择 `text` 是最好的方案",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NzcyNDEyNjQ=",
    "number": 231,
    "title": "【Q230】如何裁剪图片 (情景：选择头像)",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc5MzUyMTk4Mw==",
      "body": "```\r\nvar path = 'https://static-zh.wxb.com.cn/customer/form/2020/11/1758696796d.jpg'\r\nfunction clipImage(path){\r\n    const canvas = document.createElement('canvas')\r\n    canvas.width = 200\r\n    canvas.height = 100\r\n    const ctx = canvas.getContext('2d')\r\n    const img = document.createElement('img')\r\n    img.src = path\r\n    img.setAttribute(\"crossOrigin\",'Anonymous')\r\n    img.onload = function (){\r\n        ctx.drawImage(this,0,0,200,100)\r\n        console.log(canvas.toDataURL())\r\n    }\r\n}\r\nclipImage(path)\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "guanwanxiao",
        "url": "https://github.com/guanwanxiao"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NzcyNTQwMTQ=",
    "number": 232,
    "title": "【Q231】你周末都喜欢做些什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU5Njk1NDQxNA==",
      "body": "打篮球，看电影，看不下书怎么办",
      "star": {
        "totalCount": 1
      },
      "author": {
        "login": "HoweZhang",
        "url": "https://github.com/HoweZhang"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NzczMDExOTI=",
    "number": 233,
    "title": "【Q232】当有大量的文本库时，如何做一个字云",
    "body": "如果对去重的每个字都做计数的话，会不会性能过差",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NzczMTIyNzY=",
    "number": 234,
    "title": "【Q233】一个关于并发更新的事务以及隔离级的问题",
    "body": "当多并发场景下有以下事务执行 (计数器自增)，会出现什么问题\r\n\r\n``` sql\r\nbegin;\r\n\r\n-- select count from counter;\r\n\r\nupdate counter set count = count + 1 where id = 1;\r\n\r\ncommit;\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU5NjA3MDY3OA==",
      "body": "如果在 pg 下:\r\n\r\n如果隔离级为 RC，则多个事务在更新同一行时，会受到阻塞 (Row Lock)\r\n如果隔离级为 RR，则多个事务在更新同一行时，会报错\r\n\r\n```\r\ncould not serialize access due to concurrent update\r\n```\r\n\r\nmysql 未测试",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NzczMzAzMTE=",
    "number": 235,
    "title": "【Q234】以下 SQL 语句会有什么问题 (悲观锁)",
    "body": "一个计数器，自增一\r\n\r\n``` sql\r\nbegin;\r\nselect count from user;\r\n\r\n-- 根据以上 SQL 查询出来的 count 来进行自增\r\n-- 如果在此次事务中，已有多次事务对 count 进行了多次更改怎么办？\r\nupdate user set count = $count + 1 where id = 1;\r\ncommit;\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU5NjA4NjI3MA==",
      "body": "在并发情况下会出现问题，先查看本次事务的流程\r\n\r\n1. 查询当前计数 -> 此时为 10\r\n1. 对当前计数自增 -> 此时为 11？**在自增时，有可能被多并发的其它事务已经自增到 100 了，此时若设置为 11，肯定有问题**\r\n\r\n**如何解决？**\r\n\r\n要在第一步时加锁，同一时间只放行一个事务，可以设置分布式锁和悲观锁\r\n\r\n+ **分布式锁** (redis)：`SET LOCK_KEY RANDOM_VALUE EX 100 NX`\r\n+ **悲观锁**：`select count from user for update`",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1Nzg1NjUwNTU=",
    "number": 236,
    "title": "【Q235】useEffect 中如何使用 async/await",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU5NzA3ODA5NQ==",
      "body": "``` ts\r\nfunction useEffect(effect: EffectCallback, deps?: DependencyList): void;\r\ntype EffectCallback = () => (void | (() => void | undefined));\r\n```\r\n\r\n根据文档及 ts 的提示来看，`useEffect` 的回调参数返回的是一个清除副作用的 `clean-up` 函数。因此无法返回 `Promise`，更无法使用 `async/await`\r\n\r\n``` js\r\nuseEffect(() => {\r\n  const subscription = props.source.subscribe();\r\n  return () => {\r\n    // Clean up the subscription\r\n    subscription.unsubscribe();\r\n  };\r\n});\r\n```\r\n\r\n**此时可以选择再包装一层 async 函数，置于 useEffect 的回调函数中，变相使用 async/await**\r\n\r\n``` jsx\r\nasync function fetchMyAPI() {\r\n  let response = await fetch('api/data')\r\n  response = await res.json()\r\n  dataSet(response)\r\n}\r\n\r\nuseEffect(() => {\r\n  fetchMyAPI();\r\n}, []);\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1Nzg3MDc0MTI=",
    "number": 237,
    "title": "【Q236】主域名的 SEO 是否比二级域名要更好",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2OTMxMTY1OA==",
      "body": "看场景的。请补充场景。再说这个和前端工程化有啥关系？",
      "star": {
        "totalCount": 0
      },
      "author": null
    }
  },
  {
    "id": "MDU6SXNzdWU1NzkxOTExOTg=",
    "number": 238,
    "title": "【Q237】以下代码，koa 会返回什么数据",
    "body": "根据有无 `await next()` 判断以下代码输出结果\r\n\r\n``` js\r\nconst Koa = require('koa')\r\nconst app = new Koa()\r\n\r\napp.use(async (ctx, next) => {\r\n  ctx.body = 'hello, 1'\r\n})\r\n\r\napp.use(ctx => {\r\n  ctx.body = 'hello, 2'\r\n})\r\n\r\napp.listen(3000)\r\n```\r\n\r\n``` js\r\nconst Koa = require('koa')\r\nconst app = new Koa()\r\n\r\napp.use(async (ctx, next) => {\r\n  ctx.body = 'hello, 1'\r\n  await next()\r\n})\r\n\r\napp.use(ctx => {\r\n  ctx.body = 'hello, 2'\r\n})\r\n\r\napp.listen(3000)\r\n```\r\n\r\n``` js\r\nconst Koa = require('koa')\r\nconst app = new Koa()\r\n\r\napp.use(async (ctx, next) => {\r\n  await next()\r\n  ctx.body = 'hello, 1'\r\n})\r\n\r\napp.use(ctx => {\r\n  ctx.body = 'hello, 2'\r\n})\r\n\r\napp.listen(3000)\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU5NzU4MDQyOA==",
      "body": "根据 koa 的洋葱模型，返回结果是\r\n\r\n```\r\nhello, 1\r\n\r\nhello, 2\r\n\r\nhello, 1\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1Nzk5NDY4NTQ=",
    "number": 239,
    "title": "【Q238】什么是服务雪崩，如何避免",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
        "name": "micro-service"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1ODA5NjAxMzY=",
    "number": 240,
    "title": "【Q239】Node 如何进行进程间通信 ",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU5ODk5MTU4MQ==",
      "body": "对于 spawn/fork 出来的父子进程来说，可以通过 pipe 的方式\r\n\r\n+ `process.on('message')`/`process.send`\r\n+ `stdin.on/stdout.write`\r\n\r\n对于并无相关的进程\r\n\r\n+ `socket`\r\n+ `message queue`",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1ODA5NzUxNjc=",
    "number": 241,
    "title": "【Q240】如何实现一个 async/await ",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYwODU3Mzc2Mg==",
      "body": "```js\r\n/**\r\n * async的执行原理\r\n * 其实就是自动执行generator函数\r\n * 暂时不考虑genertor的编译步骤（更复杂）\r\n */\r\n\r\nconst getData = () =>\r\n  new Promise(resolve => setTimeout(() => resolve(\"data\"), 1000))\r\n\r\n// 这样的一个async函数 应该再1秒后打印data\r\nasync function test() {\r\n  const data = await getData()\r\n  console.log('data: ', data);\r\n  const data2 = await getData()\r\n  console.log('data2: ', data2);\r\n  return 'success'\r\n}\r\n\r\n// async函数会被编译成generator函数 (babel会编译成更本质的形态，这里我们直接用generator)\r\nfunction* testG() {\r\n  // await被编译成了yield\r\n  const data = yield getData()\r\n  console.log('data: ', data);\r\n  const data2 = yield getData()\r\n  console.log('data2: ', data2);\r\n  return 'success'\r\n}\r\n\r\nfunction asyncToGenerator(generatorFunc) {\r\n  return function() {\r\n    const gen = generatorFunc.apply(this, arguments)\r\n\r\n    return new Promise((resolve, reject) => {\r\n      function step(key, arg) {\r\n        let generatorResult\r\n        try {\r\n          generatorResult = gen[key](arg)\r\n        } catch (error) {\r\n          return reject(error)\r\n        }\r\n\r\n        const { value, done } = generatorResult\r\n\r\n        if (done) {\r\n          return resolve(value)\r\n        } else {\r\n          return Promise.resolve(value).then(\r\n            function onResolve(val) {\r\n              step(\"next\", val)\r\n            },\r\n            function onReject(err) {\r\n              step(\"throw\", err)\r\n            },\r\n          )\r\n        }\r\n      }\r\n      step(\"next\")\r\n    })\r\n  }\r\n}\r\n\r\nconst testGAsync = asyncToGenerator(testG)\r\ntestGAsync().then(result => {\r\n  console.log(result)\r\n})\r\n```",
      "star": {
        "totalCount": 1
      },
      "author": {
        "login": "sl1673495",
        "url": "https://github.com/sl1673495"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1ODA5ODQxNjI=",
    "number": 242,
    "title": "【Q241】如何使用 async/await 实现 Promise.all 的效果",
    "body": "如获取三个用户的信息，使用 `Promise.all` 的写法\r\n\r\n``` js\r\nconst users = await Promise.all(getUser(1), getUser(2), getUser(3))\r\n```\r\n\r\n那如何不使用 `Promise.all` 实现以上效果",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU5OTA3OTQ4Mw==",
      "body": "使用 `async`/`await` 实现\r\n\r\n``` js\r\nconst user1 = getUser(1)\r\nconst user2 = getUser(2)\r\nconst user3 = getUser(3)\r\n\r\nconst u1 =  await user1\r\nconst u2 =  await user2\r\nconst u3 =  await user3\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1ODEyNDc5ODc=",
    "number": 244,
    "title": "【Q242】有没有用过 continuous local storage，用在了哪里",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1ODEyNTE3NTg=",
    "number": 245,
    "title": "【Q243】有没有遇到 js 捕捉不到异常堆栈信息的情况",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs45c2k2",
      "body": "有啊，网络错误，就捕捉不到",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "Carrie999",
        "url": "https://github.com/Carrie999"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1ODE1OTc0MTM=",
    "number": 246,
    "title": "【Q244】Promise 在异步资源的生命周期 (async_hooks) 中是如何被销毁的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1ODE3NDY4MDQ=",
    "number": 247,
    "title": "【Q245】有没有用过 Promise.allSettled() ，它是干什么的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg2OTczMzcyNQ==",
      "body": "接收一个可迭代对象，其中每个成员都是`Promise`。在所有给定的`Promise`都已经`fulfilled`或`rejected`后返回一个`Promise`，并带有一个对象数组，每个对象表示对应的`Promise`结果\r\n相较于`Promise.all`，后者会在任何一个`Promise`为`rejected`时立即结束\r\n简单实现\r\n``` js\r\nconst myPromiseSettled = (items) => {\r\n  const onResolved = (value) => ({ status: 'fulfilled', value });\r\n  const onRejected = (reason) => ({ status: 'rejected', reason });\r\n  return Promise.all(items.map((item) => Promise.resolve(item).then(onResolved, onRejected)));\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "mrrs878",
        "url": "https://github.com/mrrs878"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1ODE3NDY5ODg=",
    "number": 248,
    "title": "【Q246】谈谈你对微服务的理解，试着画一个脑图",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
        "name": "micro-service"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1ODQzOTE5NTQ=",
    "number": 249,
    "title": "【Q247】在 node 中如何监听异步资源的生命周期",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1ODg0MTkwNDY=",
    "number": 250,
    "title": "【Q248】测试中 TDD 与 BDD 有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1ODk3MDc2NjE=",
    "number": 251,
    "title": "【Q249】使用 js 实现一个 lru cache",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg2OTc0MjkxMQ==",
      "body": "可以借助`Map`实现\r\n\r\n``` js\r\nclass LRUCache {\r\n  constructor(limit) {\r\n    this.limit = limit;\r\n    this.cache = new Map();\r\n  }\r\n\r\n  get(key) {\r\n    if (!this.cache.has(key)) return undefined;\r\n    const value = this.cache.get(key);\r\n    this.cache.delete(key);\r\n    this.cache.set(key, value);\r\n    return value;\r\n  }\r\n\r\n  put(key, value) {\r\n    if (this.cache.has(key)) this.cache.delete(key);\r\n    else if (this.cache.size >= this.limit) {\r\n      this.cache.delete(this.cache.keys().next().value);\r\n    }\r\n    this.cache.set(key, value);\r\n  }\r\n}\r\n\r\n// [\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\r\n// [[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]\r\nconst lruCache = new LRUCache(2);\r\nlruCache.put(1, 1);\r\nlruCache.put(2, 2);\r\nconst res1 = lruCache.get(1);\r\nlruCache.put(3, 3);\r\nconst res2 = lruCache.get(2);\r\nlruCache.put(4, 4);\r\nconst res3 = lruCache.get(1);\r\nconst res4 = lruCache.get(3);\r\nconst res5 = lruCache.get(4);\r\n\r\nconsole.log(res1, res2, res3, res4, res5);\r\n// 1 undefined undefined 3 4\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "mrrs878",
        "url": "https://github.com/mrrs878"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1ODk3MzI3NDk=",
    "number": 252,
    "title": "【Q250】刚刚启动了一个服务，如何知道这个服务对应的端口号是多少",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
        "name": "devops"
      },
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcyNDU5NjU0Mg==",
      "body": "在linux系统中，我通常通过 `ps -aux |grep 服务名` 查看服务端口",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "edisonwd",
        "url": "https://github.com/edisonwd"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1ODk5NDAwODU=",
    "number": 253,
    "title": "【Q251】node --max-old-space-size=4096 是什么意思",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1OTAyNTk3MzU=",
    "number": 254,
    "title": "【Q252】https 中如何保证证书是可信任的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1OTAyNzAzODE=",
    "number": 255,
    "title": "【Q253】cookie 有哪些字段",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYwOTQxNTkwOA==",
      "body": "+ path\r\n+ domain\r\n+ key\r\n+ value\r\n+ httpOnly\r\n+ simeSite",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1OTAyNzQzOTc=",
    "number": 256,
    "title": "【Q254】进程与线程的区别是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
        "name": "os"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1OTE3NDIzMzU=",
    "number": 257,
    "title": "【Q255】图片防盗链原理是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYwNzEyMzkzNw==",
      "body": "请求头中的 refer 来判断是否屏蔽图片",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1OTI0MjYzNzE=",
    "number": 258,
    "title": "【Q256】如何理解 Node 的异步非阻塞IO",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1OTI3MTQ1Mjk=",
    "number": 259,
    "title": "【Q257】爬虫中如何实现一个调度器",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxOTU2NjA5OTU2",
        "name": "爬虫"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1OTI3MTQ5ODE=",
    "number": 260,
    "title": "【Q258】如何实现一个分布式的爬虫",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxOTU2NjA5OTU2",
        "name": "爬虫"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYwODk2Nzk5NQ==",
      "body": "可以通过 redis 实现一个分布式的 url 调度器 (Set)，多个分布式爬虫的爬取器从调度器中统一取地址进行爬取",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1OTI3MTU0Nzg=",
    "number": 261,
    "title": "【Q259】爬虫如何实现一个去重器",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxOTU2NjA5OTU2",
        "name": "爬虫"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1OTMzMjQ0NjA=",
    "number": 262,
    "title": "【Q260】如何实现单点登录",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYwODk2Njg0NA==",
      "body": "一张来 [单点登录原理与简单实现](https://images2015.cnblogs.com/blog/797930/201612/797930-20161203152650974-276822362.png) 的图\r\n\r\n![](https://images2015.cnblogs.com/blog/797930/201612/797930-20161203152650974-276822362.png)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1OTMzNzMyODk=",
    "number": 263,
    "title": "【Q261】当写爬虫时，因爬取过多被禁掉 IP 怎么解决",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxOTU2NjA5OTU2",
        "name": "爬虫"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYwODk2MTMxMA==",
      "body": "可以维护一个 IP 地址池，通过 Proxy 的方式去爬取网页",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1OTM3MzY5NzA=",
    "number": 264,
    "title": "【Q262】当一个排期五天的任务需要在两天后上线如何解决",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2OTI0NDM2Mg==",
      "body": "1. 分析任务\r\n这个任务是活动页面开发？还是常规需求？\r\n如果是常规需求，可以考虑延期\r\n如果是活动页面，尤其是节假日、特殊纪念日的活动，可以考虑降低用户体验、砍需求等从而降低工作量，继而保证正常上线。因为运营活动的时效性较高\r\n2. 在排期阶段多估算时间，预计是常规工作时间的 1.5 倍\r\n3. 通过加班等方式弥补工期的缺失",
      "star": {
        "totalCount": 0
      },
      "author": null
    }
  },
  {
    "id": "MDU6SXNzdWU1OTM3NTQyOTY=",
    "number": 265,
    "title": "【Q263】你们项目的测试覆盖率是怎么做的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1OTM3NzI3Mjk=",
    "number": 266,
    "title": "【Q264】当 Node 应用发生 gc 时，如何监控",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1OTQyOTM1NTE=",
    "number": 267,
    "title": "【Q265】Node 应用中如何查看 gc 的日志",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYwOTM3NjExNg==",
      "body": "通过开启参数 `--trace-gc` 与 `--trace-gc-verbose`\r\n\r\n``` bash\r\n$ node --trace-gc index.js\r\n\r\n[10711:0x3507b20]    36425 ms: Mark-sweep 28.6 (48.2) -> 19.3 (46.7) MB, 3.9 / 0.0 ms  (+ 10.4 ms in 8 steps since start of marking, biggest step 6.9 ms, walltime since start of marking 77 ms) (average mu = 0.997, current mu = 0.997) finalize incremental marking via task GC in old space requested\r\n[10711:0x3507b20]    36434 ms: Scavenge 21.0 (46.7) -> 5.7 (46.7) MB, 1.0 / 0.0 ms  (average mu = 0.997, current mu = 0.997) allocation failure\r\n[10711:0x3507b20]    36494 ms: Scavenge 21.1 (46.7) -> 6.2 (46.7) MB, 2.3 / 0.0 ms  (average mu = 0.997, current mu = 0.997) allocation failure\r\n[10711:0x3507b20]    36562 ms: Scavenge 21.1 (46.7) -> 6.0 (46.7) MB, 2.8 / 0.0 ms  (average mu = 0.997, current mu = 0.997) allocation failure\r\n```\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1OTQ0NTExNDU=",
    "number": 268,
    "title": "【Q266】bind 与 call/apply 的区别是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYwOTQxNTUzNg==",
      "body": "他们都是绑定 this 的，但是\r\n\r\n1. `bind` 返回函数\r\n1. `call/apply` 直接执行函数",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1OTUxNDcwNDg=",
    "number": 269,
    "title": "【Q267】CSP 是干什么用的了",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      },
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYxMzkxNjc5MQ==",
      "body": "http://www.ruanyifeng.com/blog/2016/09/csp.html",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "DoubleRayWang",
        "url": "https://github.com/DoubleRayWang"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1OTU4NjcwMjA=",
    "number": 270,
    "title": "【Q268】你如何看待 serverless",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1OTcyNjcyMzE=",
    "number": 271,
    "title": "【Q269】什么是 XSS 攻击，如何避免",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY3ODc4MTc2NA==",
      "body": "CSS (Cross Site Scripting)，跨站脚本攻击。可使用以下脚本在指定网站上进行攻击\r\n\r\n``` html\r\n<script>alert('XSS')</script>\r\n\r\n<img src=\"https://devtool.tech/notfound.png\" onerror=\"alert('XSS')\">\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1OTczMzI4OTc=",
    "number": 272,
    "title": "【Q270】一张员工表，一个字段代表它的上级，如何查询该员工的所有上级",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1OTc4ODU4NjY=",
    "number": 273,
    "title": "【Q271】react hooks 的原理是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcyNTMzMTg2OA==",
      "body": "闭包 ➕ 链表",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "newwangyiyang",
        "url": "https://github.com/newwangyiyang"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1OTkzMjk2NjE=",
    "number": 274,
    "title": "【Q272】如何查看你们 JS 项目中应采用的 node 版本",
    "body": "当入职新公司，接手一个新的项目时，如何知道这个项目需要的 node 版本是多少",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYxMzkxMjU5NQ==",
      "body": "如果项目使用的yarn和typescript，可以查看yarn.lock里的@types/node@* 的version",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "DoubleRayWang",
        "url": "https://github.com/DoubleRayWang"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MDAyODAyMjA=",
    "number": 275,
    "title": "【Q273】http2 中的首部压缩的实现原理是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYxNDAzMTYyOA==",
      "body": "`HPACK` 协议，其中原理是**哈夫曼编码**及**索引表** (看来常用的数据结构及算法要有所了解)，以下内容摘自 [谷歌开发者文档：http2](https://developers.google.com/web/fundamentals/performance/http2/)\r\n\r\n> 每个 HTTP 传输都承载一组标头，这些标头说明了传输的资源及其属性。 在 HTTP/1.x 中，此元数据始终以纯文本形式，通常会给每个传输增加 500–800 字节的开销。如果使用 HTTP Cookie，增加的开销有时会达到上千字节。 （请参阅测量和控制协议开销。） 为了减少此开销和提升性能，HTTP/2 使用 HPACK 压缩格式压缩请求和响应标头元数据，这种格式采用两种简单但是强大的技术：\r\n>\r\n> 1. 这种格式支持通过静态霍夫曼代码对传输的标头字段进行编码，从而减小了各个传输的大小。\r\n> 1. 这种格式要求客户端和服务器同时维护和更新一个包含之前见过的标头字段的索引列表（换句话说，它可以建立一个共享的压缩上下文），此列表随后会用作参考，对之前传输的值进行有效编码。\r\n\r\n实践出真知，通过 `wireshark` 抓包分析 http2 的报文对理解 http2 收益颇多。\r\n\r\n> 你要有知识，你就得参加变革现实的实践。你要知道梨子的滋味，你就得变革梨子，亲口吃一吃。你要知道原子的组织同性质，你就得实行物理学和化学的实验，变革原子的情况。你要知道革命的理论和方法，你就得参加革命。\r\n\r\n以下是关于抓包信息的截图\r\n\r\n**http2 通过 `Settings` 帧设置 header table size，进行首部压缩**\r\n\r\n![HTTP2 Settings](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f1a9d380a4d47a4aabbbd98af4d3f90~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n**http2 通过首部压缩后，:method 伪标头在索引表中的 Index 为 2**\r\n\r\n![HTTP2 Index](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b1281937b584bffaa0bbcb9d5621341~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n关于**常用的标头会存储在静态索引表固定的位置**，详见 <https://httpwg.org/specs/rfc7541.html#static.table.definition>\r\n\r\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cef31dd10e64340b49caf35cbc01759~tplv-k3u1fbpfcp-zoom-1.image)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MDEyMDEwNDQ=",
    "number": 276,
    "title": "【Q274】如何获取你们 Node 项目的 cpu profile 快照",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MDEyMzM5NDg=",
    "number": 277,
    "title": "【Q275】解释下 OLTP 与 OLAP",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MDI2NjM4NTQ=",
    "number": 278,
    "title": "【Q276】如何查看 node_modules(某一文件夹) 的体积有多大",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      },
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYxNjA4MjUxNQ==",
      "body": "`du` (disk usage) 命令可以查看磁盘的使用情况，从它可以看出来文件及目录的大小\r\n\r\n``` bash\r\n# -d 搜索深度，0 指当前目录\r\n# -h 以可读性的方式显示大小\r\n$ du -hd 0 node_modules\r\n132M    node_modules\r\n```\r\n\r\n同理，可以使用以下命令查看 `node_modules` 下每个目录所占的大小\r\n\r\n``` bash\r\n$ du -hd 1 node_modules\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MDI2OTQ3MDQ=",
    "number": 279,
    "title": "【Q277】redux 解决什么问题，还有什么其他方案",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcyNTMzMjM5MQ==",
      "body": "1. mobx\r\n2. useContext ➕ useReducer",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "newwangyiyang",
        "url": "https://github.com/newwangyiyang"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MDI2OTQ4NTg=",
    "number": 280,
    "title": "【Q278】为什么不能在表达式里面定义 react hooks",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2MDkyNDk4Mg==",
      "body": "https://zh-hans.reactjs.org/docs/hooks-rules.html#explanation",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "Kffhi",
        "url": "https://github.com/Kffhi"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MDU2MzU3MTc=",
    "number": 281,
    "title": "【Q279】display: inline 的元素设置 margin 和 padding 会生效吗",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYxODQ3MjE4MQ==",
      "body": "可参考文章 http://maxdesign.com.au/articles/inline/\r\n\r\ninline 元素的 margin 与 padding 左右生效，上下生效，**准确说在上下方向不会使其它元素受到挤压，仿佛不生效**，如下图设置 border 会发现它其实生效了\r\n\r\n![image](https://user-images.githubusercontent.com/13389461/119799247-7ba83280-bf0e-11eb-82ce-3cf6cab2ea41.png)\r\n\r\n代码为，可见于 [行内元素的padding与margin - codepen](https://codepen.io/shanyue/pen/poeraWQ)\r\n\r\n``` html\r\n<div class=\"container\">\r\n  我是<span class=\"item\">行内元素</span>白日依山尽，黄河入海流。欲穷千里目，更上一层楼。白日依山尽，黄河入海流。欲穷千里目，更上一层楼。白日依山尽，黄河入海流。欲穷千里目，更上一层楼。白日依山尽，黄河入海流。欲穷千里目，更上一层楼。\r\n</div>\r\n```\r\n\r\n为 `.item` 行内元素设置样式，观察效果:\r\n\r\n``` css\r\n.item {\r\n  padding: 1rem;\r\n  border: 1px solid red;\r\n}\r\n\r\n.container {\r\n  margin: 3rem;\r\n  background-color: #ccc;\r\n  height: 10rem;\r\n}\r\n```\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MDYxNDk5ODQ=",
    "number": 282,
    "title": "【Q280】html 的默认 display 属性是多少",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY4MTc4ODU5Nw==",
      "body": "block      ",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "fariellany",
        "url": "https://github.com/fariellany"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MDYyNjg3NTA=",
    "number": 283,
    "title": "【Q281】响应式布局需要注意哪一些",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2NjI2NTUyOQ==",
      "body": "栅格布局？",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "Innocentw",
        "url": "https://github.com/Innocentw"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MDYyNzU0MDU=",
    "number": 284,
    "title": "【Q282】对一个非定长宽的块状元素如何做垂直水平居中",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2OTc3MTE2Ng==",
      "body": "flex布局",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "huxiamei",
        "url": "https://github.com/huxiamei"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MDg4NjE3NzM=",
    "number": 285,
    "title": "【Q283】http 请求头中的 X-Forwarded-For 代表什么意思",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYyMTA2MzMzOQ==",
      "body": "`X-Forwarded-For` 被反向代理器生成，如 nginx，traefik 等，一般用作标识客户端真实的 IP 地址，目前已成为事实上的标准。",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MDk0MzQwODA=",
    "number": 286,
    "title": "【Q284】prefetch 与 preload 的区别是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      },
      {
        "id": "MDU6TGFiZWwzMDkwODMwMjI5",
        "name": "perf"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYyMTUyODQ5OQ==",
      "body": "``` html\r\n<link rel=\"prefetch\" href=\"style.css\" as=\"style\">\r\n<link rel=\"preload\" href=\"main.js\" as=\"script\">\r\n```\r\n\r\n1. `preload` 加载当前路由必需资源，优先级高。一般对于 Bundle Spliting 资源与 Code Spliting 资源做 preload\r\n1. `prefetch` 优先级低，在浏览器 idle 状态时加载资源。一般用以加载其它路由资源，如当页面出现 Link，可 prefetch 当前 Link 的路由资源。（next.js 默认会对 link  做懒加载+prefetch，即当某条 Link 出现页面中，即自动 prefetch 该 Link 指向的路由资源\r\n\r\n> prefetch - Prefetch the page in the background. Defaults to true. Any <Link /> that is in the viewport (initially or through scroll) will be preloaded.\r\n\r\n更多信息可参考以下链接：\r\n\r\n+ [用 preload 预加载页面资源](https://juejin.im/post/5a7fb09bf265da4e8e785c38)\r\n+ [Using Preload and Prefetch in Your HTML to Load Assets](https://alligator.io/html/preload-prefetch/)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MDk3MTU2NjE=",
    "number": 287,
    "title": "【Q285】有没有做过裁剪头像图片的需求，如何实现",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MDk3NDM2NTY=",
    "number": 288,
    "title": "【Q286】在服务端应用中如何获得客户端 IP",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYyMTcxNTI4NA==",
      "body": "**如果有 `x-forwarded-for` 的请求头，则取其中的第一个 IP，否则取建立连接 socket 的 remoteAddr。**\r\n\r\n而 `x-forwarded-for` 基本已成为了基于 proxy 的标准HTTP头，格式如下，可见第一个 IP 代表其真实的 IP，可以参考 MDN [X-Forwarded-For](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For)\r\n\r\n``` js\r\nX-Forwarded-For: 203.0.113.195, 70.41.3.18, 150.172.238.178\r\nX-Forwarded-For: <client>, <proxy1>, <proxy2>\r\n```\r\n\r\n以下是 `koa` 获取 IP 的方法\r\n\r\n``` js\r\n  get ips() {\r\n    const proxy = this.app.proxy;\r\n    const val = this.get(this.app.proxyIpHeader);\r\n    let ips = proxy && val\r\n      ? val.split(/\\s*,\\s*/)\r\n      : [];\r\n    if (this.app.maxIpsCount > 0) {\r\n      ips = ips.slice(-this.app.maxIpsCount);\r\n    }\r\n    return ips;\r\n  },\r\n\r\n  get ip() {\r\n    if (!this[IP]) {\r\n      this[IP] = this.ips[0] || this.socket.remoteAddress || '';\r\n    }\r\n    return this[IP];\r\n  },\r\n```\r\n\r\n参见源码: <https://github.com/koajs/koa/blob/master/lib/request.js#L433>",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MTE5NDk0NDE=",
    "number": 289,
    "title": "【Q287】在 redis 中如何查看版本号",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjY2OTk3OTM5",
        "name": "redis"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYyMzUyMTQ0OA==",
      "body": "``` bash\r\n$ redis-server -v\r\nRedis server v=5.0.7 sha=00000000:0 malloc=jemalloc-5.1.0 bits=64 build=fbc6fab733127977\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MTI1OTQ4Nzc=",
    "number": 290,
    "title": "【Q288】如何求数组中的 TOP k",
    "body": "求数组中的前 N 个最大的数",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
        "name": "algorithm"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYyNDA1NDE1Nw==",
      "body": "1. 取数组中前 k 个数做小顶堆，堆化\r\n1. 数组中的其它数逐一与堆顶元素比较，若大于堆顶元素，则插入该数\r\n\r\n时间复杂度 O(nlg(k))",
      "star": {
        "totalCount": 1
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MTQ4MTcxNzQ=",
    "number": 291,
    "title": "【Q289】Node 中循环引用会发生什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg3MDY4MTUyNg==",
      "body": "在 CommonJS 规范中，当遇到`require()`语句时，会执行`require`模块中的代码，并缓存执行的结果，当下次再次加载时不会重复执行，而是直接取缓存的结果。正因为此，出现循环依赖时才不会出现无限循环调用的情况。\r\n\r\n``` js\r\n// a.js\r\nconst { b } = require(\"./b\");\r\n\r\nconst a = 11;\r\n\r\nconsole.log('b in a.js', b);\r\n\r\nmodule.exports = { a };\r\n```\r\n\r\n``` js\r\n// b.js\r\nconst { a } = require(\"./a\");\r\n\r\nconst b = 12;\r\n\r\nconsole.log('a in b.js', a);\r\nsetTimeout(() => {\r\n  console.log('a in b.js', a);\r\n}, 1000);\r\n\r\nmodule.exports = { b };\r\n```\r\n\r\n当执行`node a.js`时：\r\n``` shell\r\na in b.js is undefined\r\nb in a.js is 12\r\n(node:23352) Warning: Accessing non-existent property 'a' of module exports inside circular dependency    \r\n(Use `node --trace-warnings ...` to show where the warning was created)\r\na in b.js is undefined\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "mrrs878",
        "url": "https://github.com/mrrs878"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MTQ4MTc0Nzg=",
    "number": 292,
    "title": "【Q290】Node 中 require 时发生了什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs4074Kq",
      "body": "[http://nodejs.cn/api/modules.html#modules_all_together](http://nodejs.cn/api/modules.html#modules_all_together)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "haotie1990",
        "url": "https://github.com/haotie1990"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MTU4MjgwMzc=",
    "number": 293,
    "title": "【Q291】简述 node/v8 中的垃圾回收机制",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2MzkzMjE3OA==",
      "body": "`v8` 中的垃圾回收机制分为三种\r\n\r\n1. `Scavenge`，工作在新生代，把 `from space` 中的存活对象移至 `to space`\r\n1. `Mark-Sweep`，标记清除。新生代的某些对象由于过度活跃会被移至老生代，此时对老生代中活对象进行标记，并清理死对象\r\n1. `Mark-Compact`，标记整理。\r\n\r\n## 相关链接\r\n\r\n1. [主流的垃圾回收机制都有哪些?](https://www.zhihu.com/question/32373436)\r\n1. [各种编程语言的实现都采用了哪些垃圾回收算法](https://www.zhihu.com/question/20018826)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MjMwNjE1NDk=",
    "number": 294,
    "title": "【Q292】peerDependency 是为了解决什么问题",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYzMjc3NDYyOA==",
      "body": "<https://indepth.dev/npm-peer-dependencies/>",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MjMzMTk4NDM=",
    "number": 295,
    "title": "【Q293】semver 指什么，试图解释一下",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MjM4NDQzODI=",
    "number": 296,
    "title": "【Q294】optionalDependencies 的使用场景是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYzMzIxOTM3Mg==",
      "body": "当一个包是可依赖可不依赖时，可采用 `optionalDependencies`，但需要在代码中做好异常处理。\r\n\r\n如 [chokidar](https://github.com/paulmillr/chokidar) 对 `fsevents` 的引入\r\n\r\n``` json\r\n{\r\n  \"optionalDependencies\": {\r\n    \"fsevents\": \"~2.1.2\"\r\n  }\r\n}\r\n```\r\n\r\n``` js\r\nlet fsevents;\r\ntry {\r\n  fsevents = require('fsevents');\r\n} catch (error) {\r\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MjQ2OTc5NDY=",
    "number": 297,
    "title": "【Q295】fetch 中 crendentials 指什么意思，可以取什么值",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYzMzg4ODYyNQ==",
      "body": "`credentials` 指在使用 `fetch` 发送请求时是否应当发送 `cookie`\r\n\r\n+ `omit`: 从不发送 `cookie`.\r\n+ `same-origin`: 同源时发送 `cookie`  (浏览器默认值)\r\n+ `include`: 同源与跨域时都发送 `cookie`",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MjQ5NDM2NDc=",
    "number": 298,
    "title": "【Q296】package-lock.json 与 yarn.lock 有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MjUzODM5MzY=",
    "number": 299,
    "title": "【Q297】服务器的平均负载如何计算",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYzNDQzNTExOA==",
      "body": "`load average` 指单位时间内运行态进程及不可中断进程的平均进程数，运行态进程指正在使用或者\r\n 等待使用 CPU 的进程，不可中断进程指正等待一些 IO 操作的进程。可使用 `uptime` 查看此指标。\r\n\r\n ```bash\r\n $ uptime\r\n  16:48:09 up 2 days, 23:43,  2 users,  load average: 0.01, 0.21, 0.20\r\n ```\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MjU0NzI2ODk=",
    "number": 300,
    "title": "【Q298】如何创建一个进程",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
        "name": "os"
      },
      {
        "id": "MDU6TGFiZWwxNzQ1MjU2MzU2",
        "name": "c"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYzNTA1NTY0NQ==",
      "body": "+ `exec`\r\n+ `fork`",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MjU1NjAzNTQ=",
    "number": 301,
    "title": "【Q299】serverless 中如何得知目前扩容了多少个实例",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMDkxMTQ2MDM3",
        "name": "serverless"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MjU1NjEwMzM=",
    "number": 302,
    "title": "【Q300】node 中 exec，fork 与 spawn 有何区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MjYyMjAyMjg=",
    "number": 303,
    "title": "【Q301】base64 由哪64个字符构成",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYzNTEwNjk2NQ==",
      "body": "`A-Z`，`a-z`，`0-9`，`+`，`/`",
      "star": {
        "totalCount": 1
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MjYyNTg4NDQ=",
    "number": 304,
    "title": "【Q302】多服务器的系统时间不一致如何解决",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      },
      {
        "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
        "name": "micro-service"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYzNTIzODU5OA==",
      "body": "ntp服务",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "sk-xie",
        "url": "https://github.com/sk-xie"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MjYyNzY4MDA=",
    "number": 305,
    "title": "【Q303】在 k8s 中如何自定义 CRD 资源",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjYwMTIxNDcw",
        "name": "k8s"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MjYyNzc5OTc=",
    "number": 306,
    "title": "【Q304】service mesh 是什么，能够解决什么问题",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjYwMTIxNDcw",
        "name": "k8s"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MjgxMzczMzQ=",
    "number": 307,
    "title": "【Q305】如何删除项目中没有使用到的 package",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYzNjYwMjUzMQ==",
      "body": "可以采用 [depcheck](https://github.com/depcheck/depcheck) 来完成这件事\r\n\r\n``` js\r\n$ npm install depcheck -g\r\n\r\n$ depcheck\r\nUnused dependencies\r\n* underscore\r\nUnused devDependencies\r\n* jasmine\r\nMissing dependencies\r\n* lodash\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MjkwOTQ1OTU=",
    "number": 308,
    "title": "【Q306】如何实现左右固定，中间自适应布局",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2MDYxMTkzOA==",
      "body": "可以参考 [【Q017】css 如何实现左侧固定300px，右侧自适应的布局](https://github.com/shfshanyue/Daily-Question/issues/18)\r\n\r\n\r\n``` pug\r\n.container\r\n  .left\r\n  .main\r\n  .right\r\n```\r\n\r\n``` css\r\n.container {\r\n  display: flex;\r\n}\r\n\r\n.left {\r\n  flex-basis: 300px;\r\n  flex-shrink: 0;\r\n}\r\n\r\n.right {\r\n  flex-basis: 300px;\r\n  flex-shrink: 0;\r\n}\r\n\r\n.main {\r\n  flex-grow: 1;\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MjkwOTU0MjE=",
    "number": 309,
    "title": "【Q307】如何实现表格单双行条纹样式",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYzNzQ1MjAyOA==",
      "body": "通过 `css3` 中伪类 `:nth-child` 来实现。其中 `:nth-child(an+b)` 匹配下标 `{ an + b; n = 0, 1, 2, ...} ` 且结果为整数的子元素\r\n\r\n+ `nth-child(2n)`/`nth-child(even)`: 双行样式\r\n+ `nth-child(2n+1)`/`nth-child(odd)`: 单行样式\r\n\r\n其中 `tr` 在表格中代表行，实现表格中单双行样式就很简单了：\r\n\r\n``` css\r\ntr:nth-child(2n) {\r\n  background-color: red;\r\n}\r\n\r\n\r\ntr:nth-child(2n+1) {\r\n  background-color: blue;\r\n}\r\n```\r\n\r\n同理：\r\n\r\n1. 如何匹配最前三个子元素: `:nth-child(-n+3)`\r\n1. 如何匹配最后三个子元素: `:nth-last-child(-n+3)`",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MjkxMDIxMjI=",
    "number": 310,
    "title": "【Q308】node 中 dns.resolve 及 dns.lookup 有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs44t5J5",
      "body": "`dns.resolve` 返回指定类型或全部类型的dns解析记录，如`A记录`, `CNAME`记录, `MX`记录\r\n`dns.lookup`返回`A记录`(IPv4)或`AAAA记录`(IPv6)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "thundernet8",
        "url": "https://github.com/thundernet8"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MjkxMTMxNDk=",
    "number": 311,
    "title": "【Q309】简述下 css specificity",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2MDYxNjUyMA==",
      "body": "`css specificity` 即 css 中关于选择器的权重，以下三种类型的选择器依次下降\r\n\r\n1. `id` 选择器，如 `#app`\r\n1. `class`、`attribute` 与 `pseudo-classes` 选择器，如 `.header`、`[type=\"radio\"]` 与 `:hover`\r\n1. `type` 标签选择器和伪元素选择器，如 `h1`、`p` 和 `::before`\r\n\r\n其中通配符选择器 `*`，组合选择器 `+ ~ >`，否定伪类选择器 `:not()` 对优先级无影响\r\n\r\n另有内联样式 `<div class=\"foo\" style=\"color: red;\"></div>` 及 `!important`(最高) 具有更高的权重\r\n\r\n> [`:not` 的优先级影响 - codepen](https://codepen.io/shanyue/pen/dyGQqBe) 可以看出 `:not` 对选择器的优先级无任何影响\r\n\r\n> [CSS Specificity - codepen](https://codepen.io/shanyue/pen/XWMRQOw) 可以看出十几个 class 选择器也没有一个 id 选择器权重高",
      "star": {
        "totalCount": 2
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MjkyNzA3MDM=",
    "number": 312,
    "title": "【Q310】Node 中 require json 文件数据时，如何当文件更新时，重新 require",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs44t5bG",
      "body": "```js\r\nfunction requireUncached(module) {\r\n    delete require.cache[require.resolve(module)];\r\n    return require(module);\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "thundernet8",
        "url": "https://github.com/thundernet8"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2Mjk3NzA2MTI=",
    "number": 313,
    "title": "【Q311】当 cookie 没有设置 maxage 时，cookie 会存在多久",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2MjI2OTQ2OQ==",
      "body": "不设置max-age和expires，此cookie就是会话级别的，浏览器关闭就没了\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "lznbuild",
        "url": "https://github.com/lznbuild"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2Mjk4NTYxMjY=",
    "number": 314,
    "title": "【Q312】如何实现 Promise.race",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc1Nzc3MDg3MQ==",
      "body": "`Promise.race = function (promises) {\r\n   return new Promise((resolve, reject) => {\r\n     promises.forEach((p,index) => {\r\n         Promise.resolve(p).then(\r\n            value => {resolve(value)},\r\n            reason => {\r\n              reject(reason)\r\n            }\r\n         )\r\n     })\r\n  })\r\n}`",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "codelou",
        "url": "https://github.com/codelou"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MzA0NjU4MTY=",
    "number": 315,
    "title": "【Q313】在浏览器中如何监听剪切板中内容",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
        "name": "html"
      },
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY0MDk4NTczMg==",
      "body": "通过 `Clipboard API` 可以获取剪切板中内容，但需要获取到 `clipboard-read` 的权限，以下是关于读取剪贴板内容的代码：\r\n\r\n``` js\r\n// 是否能够有读取剪贴板的权限\r\n// result.state == \"granted\" || result.state == \"prompt\"\r\nconst result = await navigator.permissions.query({ name: \"clipboard-read\" })\r\n\r\n// 获取剪贴板内容\r\nconst text = await navigator.clipboard.readText()\r\n```\r\n\r\n > 注: 该方法在 `devtools` 中不生效\r\n\r\n相关问题: [【Q019】如何实现选中复制的功能](https://github.com/shfshanyue/Daily-Question/issues/20)\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MzA2ODYyNDE=",
    "number": 316,
    "title": "【Q314】source 与 sh 执行脚本时有何区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMTA5NjQyNTA2",
        "name": "shell"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs42wuOI",
      "body": "source 执行是在当前环境下执行\r\nsh执行会新开一个子运行环境，结束后子脚本中的变量无法访问\r\n因此当配置.zshrc这种文件时，通常会source一下",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "Asarua",
        "url": "https://github.com/Asarua"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MzA3NDY1OTY=",
    "number": 317,
    "title": "【Q315】'+' 与 '~' 选择器有什么不同",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY0MTMzNDkzOQ==",
      "body": "+ `+` 选择器匹配紧邻的兄弟元素\r\n+ `~` 选择器匹配随后的所有兄弟元素",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MzA3NDg1MTU=",
    "number": 318,
    "title": "【Q316】node 中如何查看函数异步调用栈",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzA3NTAzMTY=",
    "number": 319,
    "title": "【Q317】有哪些 css 属性不能展示动画效果",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzA3NTI3ODk=",
    "number": 320,
    "title": "【Q318】如何设计 prometheus 中的 metric",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
        "name": "micro-service"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzA3NTMxNzg=",
    "number": 321,
    "title": "【Q319】css 动画与 js 动画哪个性能更好",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY4NTQzNjIzMQ==",
      "body": "CSS3的动画：\r\n　　1.在性能上会稍微好一些，浏览器会对CSS3的动画做一些优化（比如专门新建一个图层用来跑动画）\r\n　　2.代码相对简单\r\n　　3.在动画控制上不够灵活\r\n　　4.兼容性不好\r\n　　5.部分动画功能无法实现（如滚动动画，视差滚动等）\r\nJavaScript的动画：\r\n      正好弥补了css缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容IE6，并且功能强大。\r\n总结：\r\n       对于一些复杂控制的动画，使用javascript会比较好。而在实现一些小的交互动效的时候，可以多考虑CSS",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "1178518969",
        "url": "https://github.com/1178518969"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MzA3NTQzNzI=",
    "number": 322,
    "title": "【Q320】如何衡量 serverless 的冷启动时间",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMDkxMTQ2MDM3",
        "name": "serverless"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzA3NTk1Njk=",
    "number": 323,
    "title": "【Q321】 css 中属性选择器及类选择器的权重哪个高",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY4NTQ0Nzc2Mw==",
      "body": ".box  权重是10  ，div[class=box]权重可以看成11\r\ndiv .box 和 div[class=box]权重是一样的",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "1178518969",
        "url": "https://github.com/1178518969"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MzA4NjYwNDg=",
    "number": 324,
    "title": "【Q322】有没有接触过 fs-extra，它是解决什么问题的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzE1MDA4MzQ=",
    "number": 325,
    "title": "【Q323】在 k8s 中如何通过日志查看某条请求进入的 pod",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjYwMTIxNDcw",
        "name": "k8s"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzQyNTk1NjY=",
    "number": 327,
    "title": "【Q324】为什么会发生样式抖动",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzQzMjgzOTQ=",
    "number": 328,
    "title": "【Q325】关于 cors 的响应头有哪些",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      },
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY0MTYxNjcwNQ==",
      "body": "- `Access-Control-Allow-Origin`\r\n- `Access-Control-Allow-Methods`\r\n- `Access-Control-Allow-Headers`\r\n- `Access-Control-Allow-Credentials`\r\n- `Access-Control-Expose-Headers`\r\n- `Access-Control-Max-Age`\r\n\r\n关于如何写一个 `cors` 的中间件可以参考 [koajs/cors](https://github.com/koajs/cors)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MzUwODMwMTU=",
    "number": 329,
    "title": "【Q326】如何发现 redis 中的 bigkey",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjY2OTk3OTM5",
        "name": "redis"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzUzMzk3NTg=",
    "number": 330,
    "title": "【Q327】如何避免 CDN 为 PC 端缓存移动端页面",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY1NzE1NTk1OA==",
      "body": "如果 PC 端和移动端是一套代码则不会出现这个问题。**这个问题出现在 PC 端和移动端是两套代码，却共用一个域名。**\r\n\r\n使用 `nginx` 配置如下，根据 UA 判断是否移动端，而走不同的逻辑 (判断UA是否移动端容易出问题)\r\n\r\n``` conf\r\nlocation / {\r\n    // 默认 PC 端\r\n    root /usr/local/website/web;\r\n    \r\n    # 判断 UA，访问移动端\r\n    if ( $http_user_agent ~* \"(Android|webOS|iPhone|iPad|BlackBerry)\" ){ \r\n        root /usr/local/website/mobile;\r\n    }\r\n \r\n    index index.html index.htm;\r\n}\r\n```\r\n\r\n解决方案通常使用 `Vary` 响应头，来控制 CDN 对不同请求头的缓存。\r\n\r\n**此处可以使用 `Vary: User-Agent` ，代表如果 User-Agent 不一样，则重新发起请求，而非从缓存中读取页面**\r\n\r\n``` txt\r\nVary: User-Agent\r\n```\r\n\r\n当然，`User-Agent` 实在过多，此时缓存失效就会过多。\r\n\r\n## 简答\r\n\r\n使用 `Vary: User-Agent`，根据 UA 进行缓存。\r\n\r\n``` txt\r\nVary: User-Agent\r\n```\r\n\r\n但最好不要出现这种情况，PC 端和移动端如果是两套代码，建议用两个域名，理由如下\r\n\r\n1. `nginx` 判断是否移动端容易出错\r\n1. 对缓存不友好\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MzUzNDI3Mzk=",
    "number": 331,
    "title": "【Q328】简述 bloomfilter，及它的使用场景是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMTI1MDM5MzMx",
        "name": "data-structure"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzU0ODUwMTQ=",
    "number": 332,
    "title": "【Q329】什么是一致性哈希，可以解决什么问题",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMTI1MDM5MzMx",
        "name": "data-structure"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzU0OTU1NDQ=",
    "number": 333,
    "title": "【Q330】mysql 如何开启及查看慢查询日志",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzU0OTcwMDI=",
    "number": 334,
    "title": "【Q331】当分页10000页时数据库查询 offset 过大如何解决性能问题",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzU0OTg5MTA=",
    "number": 335,
    "title": "【Q332】当数据库进行版本升级时，如何进行数据迁移",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzYxNzY0NTM=",
    "number": 336,
    "title": "【Q333】mysql 是如何实现 MVCC 的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzYxNzk4NTc=",
    "number": 337,
    "title": "【Q334】position: sticky 如何工作，适用于哪些场景",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY0MTk0OTUzMA==",
      "body": "`position: sticky` 可理解为 `relative` 与 `fixed` 的结合体",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MzYxODE2NDM=",
    "number": 338,
    "title": "【Q335】什么是层叠上下文 (stacking contect)，谈谈对它的理解",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzYxODgzNDQ=",
    "number": 339,
    "title": "【Q336】你用 css 实现过什么不错的效果",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzYxODkzNzY=",
    "number": 340,
    "title": "【Q337】你做前端有多少时间花在写 css 上",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      },
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2NjE5NzQ4NQ==",
      "body": "非常多",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "Innocentw",
        "url": "https://github.com/Innocentw"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MzYxOTAwNTA=",
    "number": 341,
    "title": "【Q338】js 中在 new 的时候发生了什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDczMzQ0Mzk5NQ==",
      "body": "1. 创建了一个新对象\r\n2. 链接到原型\r\n3. 绑定this指向\r\n4.返回这个对象\r\n\r\n```js\r\nfunction _new() {\r\n let obj = {}\r\n let Con = [].shift.call(arguments)\r\n obj.__proto__ = Con.prototype\r\n let result = Con.apply(obj, arguments)\r\n return typeof obj === 'object' ? obj : {}\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "XJHxjh0118",
        "url": "https://github.com/XJHxjh0118"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MzYxOTEwMjE=",
    "number": 342,
    "title": "【Q339】伪类与伪元素有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2MDYxNzY4OQ==",
      "body": "1. 伪类使用单冒号，而伪元素使用双冒号。如 `:hover` 是伪类，`::before` 是伪元素\r\n1. 伪元素会在文档流生成一个新的元素，并且可以使用 `content` 属性设置内容\r\n\r\n参考 <https://www.w3.org/TR/CSS2/selector.html#pseudo-elements>",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MzYxOTM5MjU=",
    "number": 343,
    "title": "【Q440】试着讲述数据库的几个范式",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzYxOTUyNTQ=",
    "number": 344,
    "title": "【Q341】为什么在 mysql 不能够使用 = null",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzYxOTkwMDQ=",
    "number": 345,
    "title": "【Q342】`A, B` 复合索引时，`A=? and B=?` 与 `B=? and A=?` 效果是否一致",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzY3NDk0Nzc=",
    "number": 346,
    "title": "【Q343】如何查找地图中某个点两公里内的餐厅",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMTI1MDM5MzMx",
        "name": "data-structure"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzY3Nzg5NjA=",
    "number": 347,
    "title": "【Q344】如何列出所有已合并到 master 的分支并删除",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzE2ODAxMDI2",
        "name": "git"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY0MjQ2MTk3MQ==",
      "body": "``` bash\r\n# 列出所有已合并到 master 的分支\r\n$ git branch --merged master\r\n\r\n# 删除所有已合并到 master 的分支\r\n$ git branch --merged master | grep -v '^\\*' | xargs git branch -d\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MzY5NzcxNjU=",
    "number": 348,
    "title": "【Q345】postgres 中 Index Scan 与 Index Only Scan 有何区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY0MjY3MjcyOQ==",
      "body": "假设在 `user` 表简历索引 (name, age)\r\n\r\nIndex Scan 指查询中除利用索引外还有额外的查询条件，如 (name, age) 是索引，但是 sex 不是\r\n\r\n``` sql\r\nselect * from user where name = '张三' and age = 10 and sex = 'MALE'\r\n```\r\n\r\nIndex Only Scan 指查询中可以全部利用索引，如 (name, age) 都是索引\r\n\r\n``` sql\r\nselect * from user where name = '张三' and age = 10\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2Mzc1NTM2Njk=",
    "number": 349,
    "title": "【Q346】Sentry 中 `withScope`，`configureScope` 与 直接 setTags 有何区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
        "name": "micro-service"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2Mzc2NzEwNTE=",
    "number": 350,
    "title": "【Q347】在 node 中如何开启 https",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY0MzIxMjcxMw==",
      "body": "在 `express` 中开启 https，如下代码所示\r\n\r\n``` js\r\nimport path from 'path'\r\nimport fs from 'fs'\r\nimport express from 'express'\r\nimport http from 'http'\r\nimport https from 'https'\r\n\r\nconst app = express();\r\n\r\nconst cred = {\r\n  key: fs.readFileSync(path.resolve(__dirname, '../key.pem')),\r\n  cert: fs.readFileSync(path.resolve(__dirname, '../cert.pem'))\r\n}\r\nconst httpServer = http.createServer(app)\r\nconst httpsServer = https.createServer(cred, app)\r\n\r\nhttpServer.listen(8000);\r\nhttpsServer.listen(8888);\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MzgwODI1NDU=",
    "number": 351,
    "title": "【Q348】node 中 module.exports 与 exports 有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2MTA5NzQzMQ==",
      "body": "**一句话：`exports` 是 `module.exports` 的引用，如果 `exports` 没有重赋值，则二者没有任何区别**\r\n\r\n类似如下所示\r\n\r\n``` js\r\nconst exports = module.exports\r\n```\r\n\r\n那如下结果会如何导出？\r\n\r\n``` js\r\nmodule.exports = 100\r\nexports = 3\r\n```\r\n\r\n很显然会导出 100，毕竟 `exports` 进行了重赋值。\r\n\r\n**那在 node 源码中如何实现的呢？** 从源码里可以看出 **exports** 的实质\r\n\r\n![module wrapper](https://shanyue.tech/assets/img/module-wrapper.70557e4e.png)\r\n\r\n详见源码: <https://github.com/nodejs/node/blob/master/lib/internal/modules/cjs/loader.js#L1252>，可以看出符合猜想\r\n\r\n众所周知，node 中所有的模块代码都被包裹在这个函数中\r\n\r\n``` js\r\nexports = module.exports\r\n(function(exports, require, module, __filename, __dirname) {\r\n  exports.a = 3\r\n});\r\n```\r\n\r\n而以下源码指出，`exports` 是如何得来\r\n\r\n``` js\r\nconst dirname = path.dirname(filename);\r\nconst require = makeRequireFunction(this, redirects);\r\nlet result;\r\n// 从这里可以看出来 exports 的实质\r\nconst exports = this.exports;\r\nconst thisValue = exports;\r\nconst module = this;\r\nif (requireDepth === 0) statCache = new Map();\r\nif (inspectorWrapper) {\r\n  result = inspectorWrapper(compiledWrapper, thisValue, exports,\r\n                            require, module, filename, dirname);\r\n} else {\r\n\r\n  // 这里是模块包装函数\r\n  result = compiledWrapper.call(thisValue, exports, require, module,\r\n                                filename, dirname);\r\n}\r\n```\r\n\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MzgxMzY2ODg=",
    "number": 352,
    "title": "【Q349】如何把 json 数据转化为 demo.json 并下载文件",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
        "name": "html"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY0MzYwMzAyNA==",
      "body": "json 视为字符串，可以利用 `DataURL` 进行下载\r\n\r\n`Text -> DataURL`\r\n\r\n除了使用 DataURL，还可以转化为 Object URL 进行下载\r\n\r\n`Text -> Blob -> Object URL`\r\n\r\n可以把以下代码直接粘贴到控制台下载文件\r\n\r\n``` js\r\nfunction download (url, name) {\r\n  const a = document.createElement('a')\r\n  a.download = name\r\n  a.rel = 'noopener'\r\n  a.href = url\r\n  // 触发模拟点击\r\n  a.dispatchEvent(new MouseEvent('click'))\r\n  // 或者 a.click()\r\n}\r\n\r\nconst json = {\r\n  a: 3,\r\n  b: 4,\r\n  c: 5\r\n}\r\nconst str = JSON.stringify(json, null, 2)\r\n\r\n// 方案一：Text -> DataURL\r\nconst dataUrl = `data:,${str}`\r\ndownload(dataUrl, 'demo.json')\r\n\r\n// 方案二：Text -> Blob -> ObjectURL\r\nconst url = URL.createObjectURL(new Blob(str.split('')))\r\ndownload(url, 'demo1.json')\r\n```\r\n\r\n## 总结\r\n\r\n1. 模拟下载，可以通过新建一个 `<a href=\"url\" download><a>` 标签并设置 `url` 及 `download` 属性来下载\r\n2. 可以通过把 `json` 转化为 `dataurl` 来构造 URL\r\n3. 可以通过把 `json` 转换为 `Blob` 再转化为 `ObjectURL` 来构造 URL",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MzgxODI2ODI=",
    "number": 353,
    "title": "【Q350】如何实现一个 timeout 的中间件",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      },
      {
        "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
        "name": "micro-service"
      },
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzgzMTkyNDk=",
    "number": 354,
    "title": "【Q351】如何得知目前 node 版本的 v8 版本号",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY0Mzc0MzQ5MQ==",
      "body": "在 `process.versions` 中可以查看 node 及相关依赖的版本号\r\n\r\n``` js\r\n> process.versions\r\n{\r\n  node: '12.16.3',\r\n  v8: '7.8.279.23-node.35',\r\n  uv: '1.34.2',\r\n  zlib: '1.2.11',\r\n  brotli: '1.0.7',\r\n  ares: '1.16.0',\r\n  modules: '72',\r\n  nghttp2: '1.40.0',\r\n  napi: '5',\r\n  llhttp: '2.0.4',\r\n  http_parser: '2.9.3',\r\n  openssl: '1.1.1g',\r\n  cldr: '36.0',\r\n  icu: '65.1',\r\n  tz: '2019c',\r\n  unicode: '12.1'\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2Mzg0OTQ3MjU=",
    "number": 355,
    "title": "【Q352】k8s 中如何删除所有 Evicted 状态的 pod",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjYwMTIxNDcw",
        "name": "k8s"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY0Mzg3MDI2OQ==",
      "body": "``` bash\r\n$ kubectl get pods\r\nNAME                                             READY   STATUS             RESTARTS   AGE\r\ncert-manager-5d8fd69d88-4nxw5                    1/1     Running            0          63d\r\ncert-manager-5d8fd69d88-f7f2w                    0/1     Evicted            0          63d\r\ncert-manager-5d8fd69d88-mpgqq                    0/1     Evicted            0          63d\r\ncert-manager-5d8fd69d88-s7dtg                    0/1     Evicted            0          232d\r\ncert-manager-5d8fd69d88-vdmrx                    0/1     Evicted            0          63d\r\ncert-manager-5d8fd69d88-zlpv4                    0/1     Evicted            0          63d\r\ncert-manager-cainjector-755bbf9c6b-455nm         0/1     Evicted            0          63d\r\n```\r\n\r\n可通过 `kubectl get pods` 来找到 `Evicted` 状态的 POD，通过 `awk` 和 `kubectl delete pod` 选中目标 pod 并删除，命令如下\r\n\r\n``` bash\r\n$  kubectl get pods | grep Evicted | awk '{print $1}' | xargs kubectl delete pod\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2Mzg2NjQ5OTc=",
    "number": 356,
    "title": "【Q353】k8s 中 Deployment 与 StatefulSet 有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjYwMTIxNDcw",
        "name": "k8s"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2NDExMTc0NDg=",
    "number": 357,
    "title": "【Q354】在 node 中如何判断一个对象是 stream",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2NzY4NTczNg==",
      "body": "`stream` 可以通过缓冲区来高效利用内存，从而提高性能。常用场景如读写大文件、http-server 中的大静态文件渲染。\r\n\r\n**每一个 stream 都有 `pipe` 函数，可以用来判断一个对象是否 `stream`**。\r\n\r\n代码如下，摘自 [is-stream](https://github.com/sindresorhus/is-stream/blob/master/index.js): 一个周下载量两千万的 npm package。\r\n\r\n``` js\r\nconst isStream = stream =>\r\n\tstream !== null &&\r\n\ttypeof stream === 'object' &&\r\n\ttypeof stream.pipe === 'function';\r\n\r\nisStream.writable = stream =>\r\n\tisStream(stream) &&\r\n\tstream.writable !== false &&\r\n\ttypeof stream._write === 'function' &&\r\n\ttypeof stream._writableState === 'object';\r\n\r\nisStream.readable = stream =>\r\n\tisStream(stream) &&\r\n\tstream.readable !== false &&\r\n\ttypeof stream._read === 'function' &&\r\n\ttypeof stream._readableState === 'object';\r\n\r\nisStream.duplex = stream =>\r\n\tisStream.writable(stream) &&\r\n\tisStream.readable(stream);\r\n\r\nisStream.transform = stream =>\r\n\tisStream.duplex(stream) &&\r\n\ttypeof stream._transform === 'function' &&\r\n\ttypeof stream._transformState === 'object';\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2NDEyMTEzNTY=",
    "number": 358,
    "title": "【Q355】什么是 Iterable 对象，与 Array 有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY0Njk5MTA4Mw==",
      "body": "实现了 `[Symbol.iterator]` 属性的对象即是 `Iterable` 对象，然后可以使用操作符 `for...of` 进行迭代\r\n\r\n``` js\r\n> l = [1, 2, 3, 4]\r\n< (4) [1, 2, 3, 4]\r\n> l[Symbol.iterator]\r\n< ƒ values() { [native code] }\r\n```\r\n\r\n详细参考 <https://javascript.info/iterable>",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2NDI0NzczMTE=",
    "number": 360,
    "title": "【Q356】在 node 端如何向服务器上传文件",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      },
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2NDU2MTg2MDg=",
    "number": 361,
    "title": "【Q357】js 如何全部替代一个子串为另一个子串",
    "body": "假设有一个字符串 `hello. hello. hello. ` 需要替换为 `AAA`，即把 `hello. ` 替换为 `A`",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY1MTU2NDM3Ng==",
      "body": "如果需要全量替换字符串，可以使用 `String.prototype.replace(re, replacer)`，其中正则表达式需要开启 `global` flag\r\n\r\n``` js\r\nconst s = 'foo foo foo'\r\ns.replce(/foo/g, 'bar')\r\n```\r\n\r\n那如题中，**是否可以使用正则表达式来替代子串**\r\n\r\n答：**不可以，因为使用子串构建正则时，有可能有特殊字符，就有可能出现问题**，如下\r\n\r\n``` js\r\n// 期待结果: 'AhelloX hello3 '\r\n> 'hello. helloX hello3 '.replace(new RegExp('hello. ', 'g'), 'A')\r\n< \"AAA\"\r\n```\r\n\r\n而在 `javascript` 中替换子串只能使用一种巧妙的办法：`str.split('foo').join('bar')`\r\n\r\n``` js\r\n> 'hello. hello. hello. '.split('hello. ').join('A')\r\n< \"AAA\"\r\n```\r\n\r\n真是一个巧(笨)妙(拙)的办法啊！！！！！**大概 TC39 也意识到了一个问题，于是出了一个新的 API**，在 `ESNext` 中\r\n\r\n``` js\r\nString.prototype.replaceAll()\r\n\r\n'aabbcc'.replaceAll('b', '.'); \r\n// 'aa..cc'\r\n```\r\n\r\n详细文档在 [String.prototype.replaceAll](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll)\r\n\r\n## 总结(及直接答案)\r\n\r\n两种办法\r\n\r\n+ `str.split('foo').join('bar')`\r\n+ `str.replaceAll('foo', 'bar')`，在 `ESNext` 中，目前支持性不好",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2NTMxOTc1Njk=",
    "number": 363,
    "title": "【Q358】什么情况下会发送 OPTIONS 请求",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      },
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY1NjUyMzIyNQ==",
      "body": "[搬运地址](https://blog.csdn.net/kahhy/article/details/81563063)\r\n1:请求的方法不是GET/HEAD/POST\r\n2:POST请求的Content-Type 异常\r\n3:请求设置了自定义的header字段\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "nextprops",
        "url": "https://github.com/nextprops"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2NTMzMzY1MjQ=",
    "number": 364,
    "title": "【Q359】CORS 如果需要指定多个域名怎么办",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY1NTg2Mjg2NA==",
      "body": "`CORS` 通过控制 `Access-Control-Allow-Origin` 控制哪些域名可以共享资源，取值如下\r\n\r\n``` bash\r\nAccess-Control-Allow-Origin: <origin> | *\r\n```\r\n\r\n其中 `*` 代表所有域名，`origin` 代表指定特定域名，那如何设置多个域名了？\r\n\r\n此时需要通过代码实现，**根据请求头中的 `Origin` 来设置响应头 `Access-Control-Allow-Origin`**，那 Origin 又是什么东西？\r\n\r\n## 请求头: Origin\r\n\r\n并不是所有请求都会自动带上 `Origin`，在浏览器中带 `Origin` 的逻辑如下\r\n\r\n1. 如果存在跨域，则带上 `Origin`，值为当前域名\r\n1. 如果不存在跨域，则不带 `Origin`\r\n\r\n逻辑理清楚后，关于服务器中对于 `Access-Control-Allow-Origin` 设置多域名的逻辑也很清晰了\r\n\r\n1. 如果请求头不带有 `Origin`，证明未跨域，则不作任何处理\r\n1. 如果请求头带有 `Origin`，证明跨域，根据 `Origin` 设置相应的 `Access-Control-Allow-Origin: <Origin>`\r\n\r\n使用伪代码实现如下:\r\n\r\n``` js\r\n// 获取 Origin 请求头\r\nconst requestOrigin = ctx.get('Origin');\r\n\r\n// 如果没有，则跳过\r\nif (!requestOrigin) {\r\n  return await next();\r\n}\r\n\r\n// 设置响应头\r\nctx.set('Access-Control-Allow-Origin', requestOrigin)\r\n```\r\n\r\n## Vary: Origin\r\n\r\n此时可以给多个域名控制 CORS，但此时假设有两个域名访问 `static.shanyue.tech` 的跨域资源\r\n\r\n1. `foo.shanyue.tech`，响应头中返回 `Access-Control-Allow-Origin: foo.shanyue.tech`\r\n1. `bar.shanyue.tech`，响应头中返回 `Access-Control-Allow-Origin: bar.shanyue.tech`\r\n\r\n看起来一切正常，但如果中间有缓存怎么办？\r\n\r\n1. `foo.shanyue.tech`，响应头中返回 `Access-Control-Allow-Origin: foo.shanyue.tech`，被 CDN 缓存\r\n1. **`bar.shanyue.tech`，因由缓存，响应头中返回 `Access-Control-Allow-Origin: foo.shanyue.tech`，跨域出现问题**\r\n\r\n此时，`Vary: Origin` 就上场了，代表为不同的 `Origin` 缓存不同的资源\r\n\r\n## 总结 (简要答案)\r\n\r\nCORS 如何指定多个域名？\r\n\r\n**根据请求头中的 `Origin` 来设置响应头 `Access-Control-Allow-Origin`**，思路如下\r\n\r\n1. 总是设置 `Vary: Origin`，避免 CDN 缓存破坏 CORS 配置\r\n1. 如果请求头不带有 `Origin`，证明未跨域，则不作任何处理\r\n1. 如果请求头带有 `Origin`，证明浏览器访问跨域，根据 `Origin` 设置相应的 `Access-Control-Allow-Origin: <Origin>` \r\n\r\n使用伪代码实现如下\r\n\r\n``` js\r\n// 获取 Origin 请求头\r\nconst requestOrigin = ctx.get('Origin');\r\n\r\nctx.set('Vary', 'Origin')\r\n\r\n// 如果没有，则跳过\r\nif (!requestOrigin) {\r\n  return await next();\r\n}\r\n\r\n// 设置响应头\r\nctx.set('Access-Control-Allow-Origin', requestOrigin)\r\n```\r\n\r\n>  相关问题：[如何避免 CDN 为 PC 端缓存移动端页面](https://github.com/shfshanyue/Daily-Question/issues/330)",
      "star": {
        "totalCount": 1
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2NTQ0ODg0NjQ=",
    "number": 365,
    "title": "【Q360】localhost 与 127.0.0.1 有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
        "name": "network"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY1NjUyMDM1Ng==",
      "body": "localhost 可以更改后指向其它地址。\r\n127.0.0.1 是约定的本机IP。\r\n类似互联网中域名与服务器IP的关系。",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "nextprops",
        "url": "https://github.com/nextprops"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2NTQ1NzUyMDE=",
    "number": 366,
    "title": "【Q361】既然 cors 配置可以做跨域控制，那可以防止 CSRF 攻击吗 ",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY1NjY5NzU2Nw==",
      "body": "**对 CORS 一点用也没有**\r\n\r\n1. **`form` 提交不通过 `CORS` 检测**，你可以在本地进行测试\r\n1.  即使通过 `xhr` 及 `fetch` 进行提交被 CORS 拦住，**但是对于简单请求而言，请求仍被发送**，已造成了攻击\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2NTU3ODEwMjg=",
    "number": 367,
    "title": "【Q362】js 动画和 css 动画那个性能比较好",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2NTU3ODM0NDM=",
    "number": 368,
    "title": "【Q363】如何获取当前系统中的在线用户数 (并发用户数)",
    "body": "一些 SaaS 系统基于 Pricing 的考虑，会限制团队人数及同时在线数，如何实现",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY1NzUxMzc5Mw==",
      "body": "> 一些 SaaS 系统基于定价策略的考虑，会限制团队人数及同时在线数，如何实现？\r\n\r\n通过 `redis` 的 `zset` 可实现并发用户数。\r\n\r\n当一个用户请求任何接口时，实现一个 middleware，处理以下逻辑\r\n\r\n``` js\r\n// 当一个用户访问任何接口时，对该用户Id，写入 zset\r\nawait redis.zadd(`Organization:${organizationId}:concurrent`, Date.now(), `User:${userId}`)\r\n\r\n// 查询当前机构的并发数\r\n// 通过查询一分钟内的活跃用户来确认并发数，如果超过则抛出特定异常\r\nconst activeUsers = await redis.zrangebyscore(`Organization:${organizationId}:concurrent`, Date.now() - 1000 * 60, Date.now())\r\n\r\n// 查出并发数\r\nconst count = activeUsers.length\r\n\r\n// 删掉过期的用户\r\nawait redis.zrembyscore(`Organization:${organizationId}:concurrent`, Date.now() - 1000 * 60, Date.now())\r\n```\r\n\r\n## 总结\r\n\r\n1. 每当用户访问服务时，把该用户的 ID 写入优先级队列，权重为当前时间\r\n1. 根据权重(即时间)计算一分钟内该机构的用户数\r\n1. 删掉一分钟以上过期的用户\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2NTk4Njk1NTk=",
    "number": 369,
    "title": "【Q364】css 如何匹配前N个子元素及最后N个子元素",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2MDQxODQwNA==",
      "body": "见 [【Q307】如何实现表格单双行条纹样式](https://github.com/shfshanyue/Daily-Question/issues/309)\r\n\r\n+ 如何匹配最前三个子元素: `:nth-child(-n+3)`\r\n+ 如何匹配最后三个子元素: `:nth-last-child(-n+3)`",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2NjM1NjM3NTM=",
    "number": 370,
    "title": "【Q365】node 中 nextTick 与 setTimeout 有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs44uNzx",
      "body": "`nextTick`属于微任务，`setTimeout`属于宏任务，在事件循环中执行的优先级不一样",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "thundernet8",
        "url": "https://github.com/thundernet8"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2Njg4MTI1Nzc=",
    "number": 371,
    "title": "【Q366】如何保存数据库与缓存的双写一致性",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      },
      {
        "id": "MDU6TGFiZWwxNjY2OTk3OTM5",
        "name": "redis"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2Njk0OTUzMTE=",
    "number": 372,
    "title": "【Q367】redux 和 mobx 有什么不同",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2Njk1NjkyMzQ=",
    "number": 373,
    "title": "【Q368】关于 React hooks 的 caputre value，以下输出多少",
    "body": "``` js\r\nfunction App() {\r\n  const [count, setCount] = useState(0);\r\n  const incr = () => {\r\n    setTimeout(() => {\r\n      setCount(count + 1);\r\n    }, 3000);\r\n  };\r\n  return <h1 onClick={incr}>{count}</h1>;\r\n}\r\n```\r\n\r\n当连续点击 10 次时，会输出多少",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDczODUyMTA3OA==",
      "body": "应该是1吧，在state被update之前count一直还是0",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "zckpp",
        "url": "https://github.com/zckpp"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2Njk2MjU4MTY=",
    "number": 374,
    "title": "【Q369】在 React 项目中 immutable 是优化性能的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2Njk5NDE0NzQ=",
    "number": 375,
    "title": "【Q370】如何使用 CSS 实现网站的暗黑模式 (Dark Mode)",
    "body": "可参考以下文章:\r\n\r\n1. [Dark mode in 5 minutes, with inverted lightness variables](https://lea.verou.me/2021/03/inverted-lightness-variables/)",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc3MTM2MDkyMw==",
      "body": "``` css\r\n@media (prefers-color-scheme: dark) {\r\n    :root{\r\n    }\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2Njk5NDgzNTg=",
    "number": 376,
    "title": "【Q371】在 redux 中如何发送请求",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2NzAzODU1NTE=",
    "number": 377,
    "title": "【Q372】redis 是如何删掉过期数据的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjY2OTk3OTM5",
        "name": "redis"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2NzA0NzM1NDE=",
    "number": 378,
    "title": "【Q373】如何为你们的前端项目选择状态管理器",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2NzA5MTA1MDE=",
    "number": 379,
    "title": "【Q374】简单介绍 requestIdleCallback 及使用场景",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
        "name": "html"
      },
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2ODA0ODk4MQ==",
      "body": "`requestIdleCallback` 维护一个队列，将在浏览器空闲时间内执行。它属于 [Background Tasks API](https://developer.mozilla.org/zh-CN/docs/Web/API/Background_Tasks_API)，你可以使用 `setTimeout` 来模拟实现\r\n\r\n``` js\r\nwindow.requestIdleCallback = window.requestIdleCallback || function(handler) {\r\n  let startTime = Date.now();\r\n \r\n  return setTimeout(function() {\r\n    handler({\r\n      didTimeout: false,\r\n      timeRemaining: function() {\r\n        return Math.max(0, 50.0 - (Date.now() - startTime));\r\n      }\r\n    });\r\n  }, 1);\r\n}\r\n```\r\n\r\n以上实现过于复杂以及细节化，也可以像 [swr](https://github.com/vercel/swr) 一样做一个简单的模拟实现，以下代码见 <https://github.com/vercel/swr/blob/8670be8072b0c223bc1c040deccd2e69e8978aad/src/use-swr.ts#L33>\r\n\r\n``` js\r\nconst rIC = window['requestIdleCallback'] || (f => setTimeout(f, 1))\r\n```\r\n\r\n在 `rIC` 中执行任务时需要注意以下几点：\r\n\r\n1. 执行重计算而非紧急任务\r\n1. 空闲回调执行时间应该小于 50ms，最好更少\r\n1. 空闲回调中不要操作 DOM，因为它本来就是利用的重排重绘后的间隙空闲时间，重新操作 DOM 又会造成重排重绘\r\n\r\nReact 的时间分片便是基于类似 `rIC` 而实现，然而因为 `rIC` 的兼容性及 50ms 流畅问题，React 自制了一个实现: [scheduler](https://github.com/facebook/react/tree/master/packages/scheduler)\r\n\r\n[use-swr](https://github.com/vercel/swr) 中进行资源的 `revalidate` 时，也是通过 `rIC` 来提高性能\r\n\r\n## 参考\r\n\r\n**强烈推荐 MDN 与 w3c 上的两篇介绍**\r\n\r\n+ [Background Tasks API - MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Background_Tasks_API)\r\n+ [requestIdleCallback - W3C](https://w3c.github.io/requestidlecallback/#idle-periods)",
      "star": {
        "totalCount": 1
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2NzE2MzgwNjI=",
    "number": 380,
    "title": "【Q375】在 redux 中如何写一个记录状态变更的日志插件",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2NzE2MzgzNzA=",
    "number": 381,
    "title": "【Q376】TCP 四次挥手时为什么需要 2MSL",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
        "name": "network"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2ODk0MDc5OA==",
      "body": "**我们先来看看什么是 2MSL ？**\r\nMSL: Maximum Segment Lifetime, 最长报文段寿命\r\n意思是，需要等候 2 * MSL 时间，才会进入关闭状态\r\n\r\n\r\n------------\r\n\r\n\r\n**然后再来看哪个阶段需要 2MSL ？**\r\n\r\n![image](https://user-images.githubusercontent.com/8110936/89364080-470b8600-d704-11ea-9bc7-edd882481c1e.png)\r\n从上图来看，是在 [发送方] 发送完 ACK 后，进入 **TIME_WAIT** 阶段，这个阶段需要等候 2*MSL，才将 TCP 关闭\r\n\r\n------------\r\n\r\n**为什么要等候 2*MSL ？**\r\n\r\n1. 用足够长的等候时间，来确保 [接收方] 能收到 ACK 包\r\n\r\n\t- 如果 [接收方] 在一定时间没收到 (ACK)，会重发 (FIN, ACK)，[发送方] 收到后，会重发 (ACK)，再重置 2*MSL 定时器\r\n\t.\r\n\r\n\r\n2. 防止当前连接延迟到达的数据段，被新的 TCP 连接收到\r\n\r\n\t- 新的 TCP 连接：相同端口，相同地址\r\n\r\n\r\n------------\r\n\r\n**TIME_WAIT 等候时间长短问题**\r\n\r\n1. 等候时间过短\r\n \r\n\t- 可能会收到上一个 TCP 连接延迟到达的数据段\r\n\t.\r\n\r\n2. 等候时间过长\r\n\r\n \t- TCP 连接一直占用着端口，需要关闭后才能建立新的连接，高并发下压力比较大\r\n\r\n",
      "star": {
        "totalCount": 1
      },
      "author": {
        "login": "zzetao",
        "url": "https://github.com/zzetao"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2NzE3NTQ0NTE=",
    "number": 382,
    "title": "【Q377】在 js 中如何实现继承",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY4NzUwNjIzMQ==",
      "body": "有以下两种方法可实现继承\r\n\r\n## `class`/`extends`\r\n\r\n``` js\r\nclass Animal {\r\n  constructor (name) {\r\n    this.name = name\r\n  }\r\n\r\n  hello () {\r\n    console.log('hello')\r\n  }\r\n}\r\n\r\nclass Dog extends Animal {\r\n  constructor (name, say) {\r\n    super(name)\r\n    this.say = say\r\n  }\r\n}\r\n```\r\n\r\n## `function`/`new`\r\n\r\n``` js\r\nfunction Animal (name) {\r\n  this.name = name\r\n}\r\n\r\nAnimal.prototype.hello = () => {\r\n  console.log('hello')\r\n}\r\n\r\nfunction Dog (name, say) {\r\n  // 01 继承属性\r\n  Animal.call(this, name)\r\n  this.say = say\r\n}\r\n\r\n// 02 通过连接原型链完成继承\r\nDog.prototype = Object.create(Animal.prototype)\r\n\r\n// 03 再加上 constructor\r\nDog.prototype.constructor = Dog\r\n// Reflect.defineProperty(Dog.prototype, \"constructor\", {\r\n//  value: Dog,\r\n//  enumerable: false, // 不可枚举\r\n//  writable: true\r\n// })\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2NzIwOTEzNDI=",
    "number": 383,
    "title": "【Q378】React 在 setState 时发生了什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcyMDg3MTg1OA==",
      "body": "react16\r\n1.setstae 以后会把update队列加入到mount 里面 如果他在生命周期里面 其实他是进行批量去更新的 如果他是在生命周期里面去set 其实数据同步的。如果想要拿到最新的就需要脱离react生命周期，和react事件流 比如在setTimeout里面set值 他拿到的数据就是最新的。",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "hqylss111",
        "url": "https://github.com/hqylss111"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2NzI3MzYwMTU=",
    "number": 384,
    "title": "【Q379】你们的后端项目的数据库索引做了哪些优化",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      },
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2NzI3MzcyNjM=",
    "number": 385,
    "title": "【Q380】如何设计一个UI组件库",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      },
      {
        "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
        "name": "vue"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2NzI3Mzc3Njc=",
    "number": 386,
    "title": "【Q381】什么是覆盖索引",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2ODY3NjUxMw==",
      "body": "假设一个用户表 `User(id primary, name unique, age)`，此时 name 为唯一索引。\r\n\r\n聚合索引: `select * from User where id in (1, 2, 3, 4, 5)`，由于 id 都在 `B+ tree` 的叶子节点，不需要去磁盘进一步 IO，称作聚合索引\r\n\r\n假设有一个需求: 根据 name 查询该人对应的 age，在现有情况下是这样的：\r\n\r\n1. 根据 name 上的 `B+ tree` 快速找到该行对应的 id\r\n1. 根据 id 上的 `B+ tree` 快速找到该行对应的 age，此时需要通过主键 id 进一步 IO，称作回表\r\n\r\n**如果建立一个联合索引 (name, age)，直接在 name 上的 `B+ tree` 就可以找到它对应的 age，省了回表操作，称为覆盖索引**",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2NzI4MTg0Mzg=",
    "number": 387,
    "title": "【Q382】你有没有造过轮子",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2NzI5MDExNDM=",
    "number": 388,
    "title": "【Q000】你最近学习了哪些新技术",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2OTA1NzU0OA==",
      "body": "##  20200804\r\n\r\n今天看到了 `tailwindcss`，感觉贼好用，很喜欢。基本上是 `class 即 style`，相比 `css modules`，`style-jsx`，可以说是更高层的抽象。虽然从 `bootstrap` 既可以看到这种雏形，但是 `tailwindcss` 做的更彻底，与现代框架集成的也更好\r\n\r\n<https://tailwindcss.com/docs/installation/>\r\n\r\n## 20200805\r\n\r\n`next.js` 最近升级到了 `v9.5.0`，已正式支持了 `custom-routes` 的配置文件写法，详情可以参考文档 [Next.js rewrites](https://nextjs.org/docs/api-reference/next.config.js/rewrites)。而在以前，只能在 `server.js` 中使用 `koa/express` 进行路由拦截来达成目的。\r\n\r\n有时原理虽说比较重要，但此时往往忽略了 API Design 的重要性，假设你要设计一个 Route 的 rewrite/redirect，你会怎么设计 API？可以参考 `nginx`、`koa-routes`、`react-routes` 等\r\n\r\n由于 `next.js` 升级，因为也升级了我的 `next app` 的模板: <https://github.com/shfshanyue/next-app>\r\n\r\n<https://github.com/vercel/next.js/releases/tag/v9.5.0>",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2NzI5MDM3MTE=",
    "number": 389,
    "title": "【Q384】python 中的 self 与 javascript 中的 this 有何不同",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2NzQzNzUzNzU=",
    "number": 390,
    "title": "【Q385】什么是缓存穿透，如何解决",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjY2OTk3OTM5",
        "name": "redis"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY3MDgzNDY3NQ==",
      "body": "**当访问数据库中不存在的数据时，此时由于不恰当的缓存策略，每次查询都会穿透缓存打在数据库上，这样在高并发下可能造成缓存穿透**，此时的解决方案：\r\n\r\n1. 当应用访问缓存不存在时，应用继续去访问数据库，即便数据库中不存在数据，此时应用再在缓存中把该值设为空，过期时间以短时间为主\r\n1. 使用过滤器做进一步的过滤，如redis 中的 bitmap 或 set，当不存在该值时，直接返回",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2NzQzNzYwMjk=",
    "number": 391,
    "title": "【Q386】什么是浏览器的关键渲染路径",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY3MDAwNTAzMQ==",
      "body": "## 01 DOM\r\n\r\n生成 DOM 会从远程下载 Byte，并根据相应的编码 (如 `utf8`) 转化为字符串，通过 AST 解析为 Token，生成 Node 及最后的 DOM。\r\n\r\n> 以下图片来自于 [构建 OM - Google Developers](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model)\r\n\r\nAST 解析过程可以查看 <https://astexplorer.net/>\r\n\r\n![HTML Parse](https://q.shanyue.tech/assets/html-parse.png)\r\n\r\n可以通过 devtools 中查看该过程\r\n\r\n![HTML Parse By devtools](https://q.shanyue.tech/assets/html-parse-devtool.png)\r\n\r\n## 02 CSSOM\r\n\r\n当解析 CSS 文件时，最终会生成 CSSOM\r\n\r\n![CSSOM Image](https://q.shanyue.tech/assets/cssom.png)\r\n\r\n## 03 Render Tree\r\n\r\nDOM 与 CSSOM 会一起生成 Render Tree，只包含渲染网页所需的节点。\r\n\r\n![render tree](https://q.shanyue.tech/assets/render-tree.png)\r\n\r\n## 04 Layout\r\n\r\n计算每一个元素在设备视口内的确切位置和大小\r\n\r\n> 以下图片来自于 [关键渲染路径 - 掘金](https://juejin.im/post/6844903756820119560)\r\n\r\n![Layout](https://q.shanyue.tech/assets/layout.png)\r\n\r\n## 05 Paint\r\n\r\n将渲染树中的每个节点转换成屏幕上的实际像素，这一步通常称为绘制或栅格化\r\n\r\n![Paint](https://q.shanyue.tech/assets/paint.png)\r\n\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2NzQ0MDk5Nzk=",
    "number": 392,
    "title": "【Q387】http2 中 server push 与 websocket 有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcxNTkzOTU0MQ==",
      "body": "+ HTTP2 Server Push，一般用以服务器根据解析 `index.html` 同时推送 `JPG/JS/CSS` 等资源，而免了服务器发送多次请求\r\n+ websocket，用以服务器与客户端手动编写代码去推送进行数据通信",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2NzUxMjY1NTU=",
    "number": 393,
    "title": "【Q388】简述下 TLS 握手过程",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY3MjkxMTU1OQ==",
      "body": "TLS 握手的详细过程可参考下图：\r\n\r\n![TLS handshake](https://www.oreilly.com/library/view/high-performance-browser/9781449344757/images/hpbn_0402.png)\r\n\r\n> 以上图片来自 [high-performance-browser](https://www.oreilly.com/library/view/high-performance-browser/9781449344757/ch04.html)\r\n\r\n从 `wireshark` 抓包，也可以看到握手的详细流程，建议抓包加强理解，以下是抓包 `https://q.shanyue.tech` 时的握手流程\r\n\r\n通过 `curl -vvv --head` 来查看握手信息:\r\n\r\n``` bash\r\n$ curl -vvv --head  https://q.shanyue.tech\r\n*   Trying 111.6.180.235...\r\n* TCP_NODELAY set\r\n* Connected to q.shanyue.tech (111.6.180.235) port 443 (#0)\r\n* ALPN, offering h2\r\n* ALPN, offering http/1.1\r\n* successfully set certificate verify locations:\r\n*   CAfile: /etc/ssl/cert.pem\r\n  CApath: none\r\n* TLSv1.2 (OUT), TLS handshake, Client hello (1):\r\n* TLSv1.2 (IN), TLS handshake, Server hello (2):\r\n* TLSv1.2 (IN), TLS handshake, Certificate (11):\r\n* TLSv1.2 (IN), TLS handshake, Server key exchange (12):\r\n* TLSv1.2 (IN), TLS handshake, Server finished (14):\r\n* TLSv1.2 (OUT), TLS handshake, Client key exchange (16):\r\n* TLSv1.2 (OUT), TLS change cipher, Change cipher spec (1):\r\n* TLSv1.2 (OUT), TLS handshake, Finished (20):\r\n* TLSv1.2 (IN), TLS change cipher, Change cipher spec (1):\r\n* TLSv1.2 (IN), TLS handshake, Finished (20):\r\n* SSL connection using TLSv1.2 / ECDHE-RSA-AES128-GCM-SHA256\r\n* ALPN, server accepted to use h2\r\n* Server certificate:\r\n*  subject: CN=q.shanyue.tech\r\n*  start date: Dec  2 00:00:00 2019 GMT\r\n*  expire date: Dec  1 12:00:00 2020 GMT\r\n*  subjectAltName: host \"q.shanyue.tech\" matched cert's \"q.shanyue.tech\"\r\n*  issuer: C=US; O=DigiCert Inc; OU=www.digicert.com; CN=Encryption Everywhere DV TLS CA - G1\r\n*  SSL certificate verify ok.\r\n* Using HTTP2, server supports multi-use\r\n* Connection state changed (HTTP/2 confirmed)\r\n* Copying HTTP/2 data in stream buffer to connection buffer after upgrade: len=0\r\n* Using Stream ID: 1 (easy handle 0x7f95ba80dc00)\r\n\r\n``` \r\n\r\n## 握手过程\r\n\r\n在 TLS 1.2 中，握手协议过程需要耗费两个 RTT，过程如下\r\n\r\n1. [OUT] Client Hello，客户端选出自身支持的 TLS 版本号、`cipher suites`、一个随机数、SessionId 传送给服务器端 (有可能可服用 Session)\r\n1. [IN] Server Hello，服务器端选出双方都支持的 TLS 版本，`cipher suite` 、一个随机数、SeesionId 给客户端\r\n1. [IN] Certificate，服务器端给客户端发送证书，用以身份验证及提供公钥\r\n1. [IN] Server Key Exchange，服务器端给客户端发送秘钥交换算法的一些参数\r\n1. [IN] Server Finished\r\n1. [OUT] Client Key Exchange，客户端给服务器端发送秘钥交换算法的一些参数，计算出预备主密钥 (pre master key)，作为随机数传递给服务器端 (这个随机数是安全的)。双方根据三个随机数生成对称加密中的秘钥\r\n1. [OUT] Change Cipher Spec，告知对方以后的消息将要使用TLS记录层协议进行加密\r\n1. [OUT] Finished，发送第一条加密的消息并完整性验证\r\n1. [IN] Change Cipher Spec，告知以后的消息将要使用TLS记录层协议进行加密\r\n1. [IN] Finished，发送第一条加密的消息并完整性验证\r\n\r\n## 相关链接\r\n\r\n+ [https握手流程详解](https://juejin.im/post/6844904135230390279#heading-10)\r\n+ [Chapter 4. Transport Layer Security (TLS)](https://www.oreilly.com/library/view/high-performance-browser/9781449344757/ch04.html)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2NzU5NTIyMTk=",
    "number": 396,
    "title": "【Q389】以下输出顺序多少 (setTimeout 与 promise 顺序)",
    "body": "``` js\r\nsetTimeout(() => console.log(0))\r\nnew Promise((resolve) => {\r\n  console.log(1)\r\n  resolve(2)\r\n  console.log(3)\r\n}).then(o => console.log(o))\r\n\r\nnew Promise(resolve => {\r\n  console.log(4)\r\n  resolve(5)\r\n}).then(o => console.log(o)).then(() => console.log(6))\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY3MTQxNTAyMw==",
      "body": "1 => 3 => 4 => 2 => 5 => 6 => 0",
      "star": {
        "totalCount": 3
      },
      "author": null
    }
  },
  {
    "id": "MDU6SXNzdWU2Nzc4MDY4MTU=",
    "number": 397,
    "title": "【Q390】简单介绍一下 RSA 算法",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
        "name": "network"
      },
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2Nzg1NDE4NDE=",
    "number": 398,
    "title": "【Q391】https 层可以做哪些性能优化",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY3MzU2MzE1Mg==",
      "body": "<https://time.geekbang.org/column/article/111287>",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2Nzg1NTEzMjM=",
    "number": 399,
    "title": "【Q392】ECDHE 与 RSA 有何区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2NzkxOTc4NDI=",
    "number": 400,
    "title": "【Q393】作为 TL 如何管理团队",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2NzkyMzk1Njc=",
    "number": 401,
    "title": "【Q394】https 中证书的格式化信息有哪些",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY3ODY0OTQ3Ng==",
      "body": "在 TLS 握手过程中，服务器端需要给客户端提供证书，**X.509 就是证书的标准格式。**\r\n\r\n![image](https://user-images.githubusercontent.com/13389461/90958724-cbae2080-e4c8-11ea-996e-3257721c89fc.png)\r\n\r\n以下是 github 的证书在 Mac 上显示的内容，可见：\r\n\r\n1. 序列号\r\n1. Subject Name\r\n1. Issuer Name\r\n1. 电子签名\r\n1. 签名算法\r\n1. 公钥\r\n1. 扩展\r\n\r\n\r\n\r\n## 相关链接\r\n\r\n+ [What Is an X.509 Certificate?](https://www.ssl.com/faqs/what-is-an-x-509-certificate/)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2Nzk0ODQ5NTg=",
    "number": 402,
    "title": "【Q395】https 连接时如何保证证书没被废弃掉",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY3NDQxNDI4OQ==",
      "body": "两种方式：\r\n\r\n1. CRL（Certificate Revocation List，证书撤销名单）。PKI 体系中由 CA 维护的一个被撤销证书的列表，浏览器会定时拉取这个文件。但这个文件的实时性及性能都可能有问题\r\n1. OCSP（Online Certificate Status Protocol，在线证书状态协议）。客户端通过 OSCP 服务请求接口来判断某个证书是否有效",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2Nzk0ODcxNjU=",
    "number": 403,
    "title": "【Q396】TLS1.3 相比 TLS1.2 有何不同",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY3NTIxNDAwMQ==",
      "body": "以下摘自 [RFC 5246: TLS 1.2](https://tools.ietf.org/html/rfc5246#section-7.3)\r\n\r\n``` txt\r\n      Client                                               Server\r\n\r\n      ClientHello                  -------->\r\n                                                      ServerHello\r\n                                                     Certificate*\r\n                                               ServerKeyExchange*\r\n                                              CertificateRequest*\r\n                                   <--------      ServerHelloDone\r\n      Certificate*\r\n      ClientKeyExchange\r\n      CertificateVerify*\r\n      [ChangeCipherSpec]\r\n      Finished                     -------->\r\n                                               [ChangeCipherSpec]\r\n                                   <--------             Finished\r\n      Application Data             <------->     Application Data\r\n\r\n             Figure 1.  Message flow for a full handshake\r\n\r\n   * Indicates optional or situation-dependent messages that are not\r\n   always sent.\r\n```\r\n\r\n以下摘自 [RFC 8446: TLS 1.3](https://tools.ietf.org/html/rfc8446)\r\n\r\n``` txt\r\n       Client                                           Server\r\n\r\nKey  ^ ClientHello\r\nExch | + key_share*\r\n     | + signature_algorithms*\r\n     | + psk_key_exchange_modes*\r\n     v + pre_shared_key*       -------->\r\n                                                  ServerHello  ^ Key\r\n                                                 + key_share*  | Exch\r\n                                            + pre_shared_key*  v\r\n                                        {EncryptedExtensions}  ^  Server\r\n                                        {CertificateRequest*}  v  Params\r\n                                               {Certificate*}  ^\r\n                                         {CertificateVerify*}  | Auth\r\n                                                   {Finished}  v\r\n                               <--------  [Application Data*]\r\n     ^ {Certificate*}\r\nAuth | {CertificateVerify*}\r\n     v {Finished}              -------->\r\n       [Application Data]      <------->  [Application Data]\r\n\r\n              +  Indicates noteworthy extensions sent in the\r\n                 previously noted message.\r\n\r\n              *  Indicates optional or situation-dependent\r\n                 messages/extensions that are not always sent.\r\n\r\n              {} Indicates messages protected using keys\r\n                 derived from a [sender]_handshake_traffic_secret.\r\n\r\n              [] Indicates messages protected using keys\r\n                 derived from [sender]_application_traffic_secret_N.\r\n\r\n               Figure 1: Message Flow for Full TLS Handshake\r\n\r\n```\r\n\r\n1. 握手时间从以前的 2RTT 缩短到 1RTT，通过 `Pre shared-key` 减少了单独的 ServerKeyExchange 与 ClientKeyExchange 消耗的一个 RTT\r\n1. 0-RTT Resumption",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2Nzk3NTMzNjY=",
    "number": 404,
    "title": "【Q397】什么是 oauth2，它解决了什么问题",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2Nzk3NTQwMTk=",
    "number": 405,
    "title": "【Q398】在 wireshark 中如何抓包 https/http2",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs40kCO5",
      "body": "参考: <https://imququ.com/post/http2-traffic-in-wireshark.html>",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2ODA2NTIzODA=",
    "number": 406,
    "title": "【Q399】实现一个 once 函数，记忆返回结果只执行一次",
    "body": "类似于 `lodash.once`\r\n\r\n``` js\r\nconst f = x => x\r\n\r\nconst onceF = once(f)\r\n\r\n//=> 3\r\nonceF(3)\r\n\r\n//=> 3\r\nonceF(4)\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      },
      {
        "id": "MDU6TGFiZWwzMDkwODMwMjI5",
        "name": "perf"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY3NTUxOTA0NQ==",
      "body": "简单实现如下：\r\n\r\n``` js\r\nfunction once (f) {\r\n  let result\r\n  let revoked = false\r\n  \r\n  return (...args) => {\r\n    if (revoked) return result\r\n    const r = f(...args)\r\n    revoked = true\r\n    result = r\r\n    return r\r\n  }\r\n}\r\n```\r\n\r\n测试一下\r\n\r\n``` js\r\n> const f = () => {console.log('call'); return 3;}\r\n< undefined\r\n\r\n> once_f = once(f)\r\n< (...args) => {\r\n    if (revoked) return result\r\n    const r = f(...args)\r\n    revoked = true\r\n    result = r\r\n  }\r\n\r\n// 第一次调用\r\n> once_f()\r\n< call\r\n< 3\r\n\r\n// 第二次调用，没有打印 call\r\n> once_f()\r\n< 3\r\n```\r\n\r\n[once](https://npm.devtool.tech/once) 是社区使用最广泛的一个库，代码实现与上大同小异，然而每月下载量可达上亿，比 vue/react/angular 三者一个月的下载量加起来还要高一倍",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2ODA2NjM1NDg=",
    "number": 407,
    "title": "【Q400】如何评估一台服务器的 CPU 性能",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
        "name": "devops"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY3ODcxNzQxMg==",
      "body": "## sysbench\r\n\r\n``` bash\r\n$ sysbench --threads=4 --time=30 cpu run\r\n\r\nsysbench 1.0.17 (using system LuaJIT 2.1.0-beta3)\r\n\r\nRunning the test with following options:\r\nNumber of threads: 4\r\nInitializing random number generator from current time\r\n\r\n\r\nPrime numbers limit: 10000\r\n\r\nInitializing worker threads...\r\n\r\nThreads started!\r\n\r\nCPU speed:\r\n    events per second:  3651.16\r\n\r\nGeneral statistics:\r\n    total time:                          30.0010s\r\n    total number of events:              109545\r\n\r\nLatency (ms):\r\n         min:                                    1.08\r\n         avg:                                    1.10\r\n         max:                                    5.78\r\n         95th percentile:                        1.12\r\n         sum:                               119955.35\r\n\r\nThreads fairness:\r\n    events (avg/stddev):           27386.2500/91.56\r\n    execution time (avg/stddev):   29.9888/0.00\r\n```\r\n\r\n## stress",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2ODEwNjA3NjY=",
    "number": 408,
    "title": "【Q401】在 TLS 层如何优化网站性能",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY3OTk0MzYzNg==",
      "body": "1. OSCP Stapling\r\n1. TLS 1.3",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2ODE1OTE1NDk=",
    "number": 409,
    "title": "【Q402】如何实现一个函数 isPlainObject 判断是否为纯对象",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY3NTk1MTQzOA==",
      "body": "``` js\r\nfunction isPlainObject(obj: any): boolean {\r\n  if (typeof obj !== 'object' || obj === null) return false\r\n\r\n  let proto = obj\r\n  while (Object.getPrototypeOf(proto) !== null) {\r\n    proto = Object.getPrototypeOf(proto)\r\n  }\r\n\r\n  return Object.getPrototypeOf(obj) === proto                                                  } \r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2ODE3MzAzOTM=",
    "number": 410,
    "title": "【Q403】React 中的 dom diff 算法如何从 O(n3) 优化到 O(n) 的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg2MzY3MDAxMA==",
      "body": "> 参考官方文档: [协调的设计动机](https://zh-hans.reactjs.org/docs/reconciliation.html#motivation)\r\n>\r\n> 此算法有一些通用的解决方案，即生成将一棵树转换成另一棵树的最小操作次数。然而，即使使用最优的算法，该算法的复杂程度仍为 O(n 3 )，其中 n 是树中元素的数量。\r\n> \r\n> 如果在 React 中使用该算法，那么展示 1000 个元素则需要 10 亿次的比较。这个开销实在是太过高昂。于是 React 在以下两个假设的基础之上提出了一套 O(n) 的启发式算法：\r\n> \r\n> 1. 两个不同类型的元素会产生出不同的树；\r\n> 1. 开发者可以通过设置 key 属性，来告知渲染哪些子元素在不同的渲染下可以保存不变；\r\n>\r\n> 在实践中，我们发现以上假设在几乎所有实用的场景下都成立。\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2ODI2MTk1MDM=",
    "number": 411,
    "title": "【Q404】在 React 应用中如何排查性能问题",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2ODI4NTI0NDc=",
    "number": 412,
    "title": "【Q405】你使用过哪些前端性能分析工具",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY3ODEyMDQ1OA==",
      "body": "chrome 自带的灯箱",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "zxhycxq",
        "url": "https://github.com/zxhycxq"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2ODMyMTk5NzM=",
    "number": 413,
    "title": "【Q406】在你们的后端应用中，redis 用在哪些场景",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjY2OTk3OTM5",
        "name": "redis"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY3ODcxNDk3NA==",
      "body": "1. 缓存\r\n1. 限流\r\n1. 队列\r\n1. 分布式锁\r\n1. 并发数控制\r\n1. bitmap\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2ODQxMTQ1ODU=",
    "number": 414,
    "title": "【Q407】什么是 CPU 缓存，如何查看缓存命中率",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      },
      {
        "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
        "name": "devops"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcyNDYwNTYyNg==",
      "body": "CPU 缓存介于 CPU 和内存之间，缓存的是热点的内存数据。这些缓存按照大小不同分为 L1、L2、L3 等三级缓存，其中 L1 和 L2 在同一个cpu核中， 而在同一个CPU插槽中的多个核共享一个 L3 缓存。\r\n\r\n缓存命中率，即直接通过缓存获取数据的请求次数，占所有数据请求次数的百分比。当可以直接通过缓存获取到需要的数据，则命中缓存；否则需要从磁盘等地方读取获取数据。缓存命中率越高，表示直接从缓存获取数据的次数越多，程序执行效率越高。\r\n使用cachestat 可以查看整个个操作系统缓存的读写命中情况：\r\ncachestat安装方式：\r\n`sudo apt install perf-tools-unstable`\r\n\r\n下面以1秒间隔输出三组缓存信息：\r\n```\r\n$ sudo cachestat 1\r\nCounting cache functions... Output every 1 seconds.\r\n    HITS   MISSES  DIRTIES    RATIO   BUFFERS_MB   CACHE_MB\r\n    1989        0       13   100.0%          501       2600\r\n   12969        0     1412   100.0%          501       2600\r\n   16798        0     2803   100.0%          501       2600\r\n```\r\n从结果可以看到，HITS 是缓存命中的次数；MISSES是缓存未命中的次数；DIRTIES是表示新增到缓存中的脏页数；BUFFERS_MB 表示 Buffers 的大小，单位为MB；CACHED_MB表示Cache 的大小，单位为MB。\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "edisonwd",
        "url": "https://github.com/edisonwd"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2ODQxODc1NjA=",
    "number": 415,
    "title": "【Q408】React 17.0 有什么变化",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2ODQxOTQxNDE=",
    "number": 416,
    "title": "【Q409】什么是 BNF 与 ABNF",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
        "name": "devops"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY5Njc1NDg2OQ==",
      "body": "`BNF` (巴克斯范式) 是一种描述编程语言语法的元语言\r\n\r\n`ABNF` (Augmented BNF)，扩展的 BNF，通过 <https://www.ietf.org/rfc/rfc5234.txt> 规范",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2ODQ1MDY3OTI=",
    "number": 417,
    "title": "【Q410】你最近看的三本书是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs42DzUd",
      "body": "1. 鸟哥的linux私房菜\r\n2. node.js 来一打c++扩展\r\n3. 深入理解Typescript",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "Asarua",
        "url": "https://github.com/Asarua"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2ODUwNzY3MDM=",
    "number": 418,
    "title": "【Q411】如何找到当前页面出现次数最多的HTML标签",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      },
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY4MDQxNjkxNw==",
      "body": "这是一道前端基础与编程功底具备的面试题：\r\n\r\n+ 如果你前端基础强会了解 `document.querySelector(*)` 能够列出页面内所有标签\r\n+ 如果你编程能力强能够用**递归**/**正则**快速实现同等的效果\r\n\r\n有三种 API 可以列出页面所有标签：\r\n\r\n1. `document.querySelector('*')`，标准规范实现\r\n1. `$$('*')`，devtools 实现\r\n1. `document.all`，非标准规范实现\r\n\r\n``` js\r\n> document.querySelectorAll('*')\r\n< NodeList(593) [html, head, meta, meta, meta, meta, meta, meta, meta, title, link#favicon, link, link#MainCss, link#mobile-style, link, link, link, script, script, script, script, script, script, script, link, script, link, link, script, input#_w_brink, body, a, div#home, div#header, div#blogTitle, a#lnkBlogLogo, img#blogLogo, h1, a#Header1_HeaderTitle.headermaintitle.HeaderMainTitle, h2, div#navigator, ul#navList, li, a#blog_nav_sitehome.menu, li, a#blog_nav_myhome.menu, li, a#blog_nav_newpost.menu, li, a#blog_nav_contact.menu, li, a#blog_nav_rss.menu, li, a#blog_nav_admin.menu, div.blogStats, span#stats_post_count, span#stats_article_count, span#stats-comment_count, div#main, div#mainContent, div.forFlow, div#post_detail, div#topics, div.post, h1.postTitle, a#cb_post_title_url.postTitle2.vertical-middle, span, div.clear, div.postBody, div#cnblogs_post_body.blogpost-body, p, p, strong, p, p, p, strong, div.cnblogs_code, pre, span, span, span, span, span, p, span, strong, pre, strong, span, strong, br, br, br, div.cnblogs_code, pre, span, span, p, p, …]\r\n[0 … 99]\r\n[100 … 199]\r\n[200 … 299]\r\n[300 … 399]\r\n[400 … 499]\r\n[500 … 592]\r\n__proto__: NodeList\r\n```\r\n\r\n使用 `document.querySelectorAll` 实现如下\r\n\r\n``` js\r\n// 实现一个 maxBy 方便找出出现次数最多的 HTML 标签\r\nconst maxBy = (list, keyBy) => list.reduce((x, y) => keyBy(x) > keyBy(y) ? x : y)\r\n\r\nfunction getFrequentTag () {\r\n  const tags = [...document.querySelectorAll('*')].map(x => x.tagName).reduce((o, tag) => { \r\n    o[tag] = o[tag] ? o[tag] + 1 : 1;\r\n    return o\r\n  }, {})\r\n  return maxBy(Object.entries(tags), tag => tag[1])\r\n}\r\n```\r\n\r\n使用 `element.children` 递归迭代如下 (最终结果多一个 document)\r\n\r\n``` js\r\nfunction getAllTags(el = document) {\r\n  const children = Array.from(el.children).reduce((x, y) => [...x, ...getAllTags(y)], [])\r\n  return children\r\n}\r\n\r\n// 或者通过 flatMap 实现\r\nfunction getAllTags(el = document) {\r\n  const children = Array.prototype.flatMap.call(el.children, x => getAllTags(x))\r\n  return [el, ...children]\r\n}\r\n```\r\n\r\n如果你已经快速答了上来，那么还有两道拓展的面试题在等着你\r\n\r\n1. 如何找到当前页面出现次数前三多的 HTML 标签\r\n2. 如过多个标签出现次数同样多，则取多个标签",
      "star": {
        "totalCount": 1
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2ODUwNzg4ODk=",
    "number": 419,
    "title": "【Q412】对以下字符串进行压缩编码",
    "body": "这是一道大厂常考的代码题\r\n\r\n+ Input: 'aaaabbbccd'\r\n+ Output: 'a4b3c2d1'，代表 a 连续出现四次，b连续出现三次，c连续出现两次，d连续出现一次\r\n\r\n有以下测试用例\r\n\r\n``` js\r\n//=> a4b3c2\r\nencode('aaaabbbcc')\r\n\r\n//=> a4b3a4\r\nencode('aaaabbbaaaa')\r\n\r\n//=> a2b2c2\r\nencode('aabbcc')\r\n```\r\n\r\n**如果代码编写正确，则可继续深入：**\r\n\r\n+ 如果只出现一次，不编码数字，如 aaab -> a3b\r\n+ 如果只出现两次，不进行编码，如 aabbb -> aab3\r\n+ 如果进行解码数字冲突如何解决",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
        "name": "algorithm"
      },
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY3OTYyNjgzMw==",
      "body": "编写函数 `encode` 实现该功能\r\n\r\n> 代码见 [【Q412】对以下字符进行压缩编码 - codepen](https://codepen.io/shanyue/pen/bGWrwWM?editors=0012)\r\n\r\n``` js\r\nfunction encode (str) {\r\n  const l = []\r\n  let i = 0\r\n  for (const s of str) {\r\n    const len = l.length\r\n    const lastChar = len > 0 ? l[len - 1][0] : undefined\r\n    if (lastChar === s) {\r\n      l[len - 1][1]++\r\n    } else {\r\n      l.push([s, 1])\r\n    }\r\n  }\r\n  return l.map(x => x.join('')).join('')\r\n}\r\n\r\n// 另外一种思路的解法\r\nfunction encode (str) {\r\n  const l = []\r\n  let i = -1;\r\n  let lastChar\r\n  for (const char of str) {\r\n    if (char !== lastChar) {\r\n      lastChar = char\r\n      i++\r\n      l[i] = [char, 1];\r\n    } else {\r\n      l[i][1]++\r\n    }\r\n  }\r\n  return l.flat().join('')\r\n}\r\n```\r\n\r\n测试通过\r\n\r\n``` js\r\n> encode('aaab')\r\n< \"a3b1\"\r\n```\r\n\r\n但是面试官往往会继续深入\r\n\r\n1. 如果只出现一次，不编码数字，如 `aaab -> a3b`\r\n1. 如果只出现两次，不进行编码，如 `aabbb -> aab3`\r\n1. 如果进行解码，碰到数字如何处理？\r\n\r\n以下是除数字外的进一步编码\r\n\r\n``` js\r\nfunction encode (str) {\r\n  const l = []\r\n  let i = -1;\r\n  let lastChar\r\n  for (const char of str) {\r\n    if (char !== lastChar) {\r\n      lastChar = char\r\n      i++\r\n      l[i] = [char, 1];\r\n    } else {\r\n      l[i][1]++\r\n    }\r\n  }\r\n  return l.map(([x, y]) => {\r\n    if (y === 1) {\r\n      return x\r\n    }\r\n    if (y === 2) {\r\n      return x + x\r\n    }\r\n    return x + y\r\n  }).join('')\r\n}\r\n```",
      "star": {
        "totalCount": 1
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2ODUwODAzMjA=",
    "number": 420,
    "title": "【Q413】如何在生产环境部署一个 Node 应用",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
        "name": "devops"
      },
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2ODUxMDM5Njg=",
    "number": 421,
    "title": "【Q414】git 如何添加与删除一个 submodule",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzE2ODAxMDI2",
        "name": "git"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY3OTYxOTEwMQ==",
      "body": "**添加 submodule**\r\n\r\n``` bash\r\n$ git submodule add :git-url dep\r\n```\r\n\r\n**删除 submodule**\r\n\r\n+ `vim .gitmodules`，找到该模块位置，删掉\r\n+ `vim .git/config`，找到该模块位置，删除\r\n+ `rm -rf .git/module/dep` \r\n+ `git rm --cached dep`",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2ODUxNjQwNTU=",
    "number": 422,
    "title": "【Q415】你有没有重客户端状态前端应用的经验",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2ODUxNjczMjc=",
    "number": 423,
    "title": "【Q416】apollo-client 与 react-apollo 在前端应用中扮演什么角色",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkyOTk0Mjk2",
        "name": "graphql"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2ODUyNjE0MzA=",
    "number": 424,
    "title": "【Q417】什么是 exit code",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      },
      {
        "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
        "name": "os"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDczODAwODA5Nw==",
      "body": "`exit code` 代表一个进程的返回码，通过系统调用 `exit_group` 来触发。在 `POSIX` 中，`0` 代表正常的返回码，`1-255` 代表异常返回码，一般主动抛出的错误码都是 `1`。\r\n\r\n这里有一张关于异常码的附表 [Appendix E. Exit Codes With Special Meanings](http://www.tldp.org/LDP/abs/html/exitcodes.html)。\r\n\r\n异常码在操作系统中随处可见，以下是一个关于 `cat` 命令的异常以及它的 `exit code`，并使用 `strace` 追踪系统调用。\r\n\r\n``` bash\r\n$ cat a\r\ncat: a: No such file or directory\r\n\r\n# 使用 strace 查看 cat 的系统调用\r\n# -e 只显示 write 与 exit_group 的系统调用\r\n$ strace -e write,exit_group cat a\r\nwrite(2, \"cat: \", 5cat: )                    = 5\r\nwrite(2, \"a\", 1a)                        = 1\r\nwrite(2, \": No such file or directory\", 27: No such file or directory) = 27\r\nwrite(2, \"\\n\", 1\r\n)                       = 1\r\nexit_group(1)                           = ?\r\n+++ exited with 1 +++\r\n```\r\n\r\n从系统调用的最后一行可以看出，该进行的 `exit code` 是 1，并把错误信息输出到 `stderr` (标准错误的 fd 为2) 中\r\n\r\n## 如何查看 exit code\r\n\r\n从 `strace` 中可以来判断进程的 `exit code`，但是不够方便过于冗余，特别身处 shell 编程环境中。\r\n\r\n**有一种简单的方法，通过 `echo $?` 来确认返回码**\r\n\r\n``` bash\r\n$ cat a\r\ncat: a: No such file or directory\r\n\r\n$ echo $?\r\n1\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2ODUzMjM3ODQ=",
    "number": 425,
    "title": "【Q418】什么是 coredump，如何配置与分析",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      },
      {
        "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
        "name": "os"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2ODU0Mzc2Nzk=",
    "number": 426,
    "title": "【Q419】DV、OV、EV 类的证书有何区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY4MzI3OTg2NA==",
      "body": "+ `Domain Validation`，最低级别的证书校验，Lets Encrypt 就是这种，因此也不怎么需要花钱\r\n+ `Organization Validation`，校验证书中组织身份，从中可以看出公司名称，所在地等信息\r\n+ `Extended Validation`，最高级别的证书校验",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2ODU0ODMzOTE=",
    "number": 427,
    "title": "【Q420】https 中是如何进行身份认证的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY4NzUwNzM3OQ==",
      "body": "电子签名",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2ODYyNTQyMjA=",
    "number": 428,
    "title": "【Q421】如何实现一个无限累加的 sum 函数",
    "body": "实现一个 sum 函数如下所示：\r\n\r\n``` js\r\nsum(1, 2, 3).valueOf() //6\r\nsum(2, 3)(2).valueOf() //7\r\nsum(1)(2)(3)(4).valueOf() //10\r\nsum(2)(4, 1)(2).valueOf() //9\r\nsum(1)(2)(3)(4)(5)(6).valueOf() // 21\r\n```\r\n\r\n追问:\r\n\r\n如果不使用 `valueOf`，可直接进行计算，如下示例，应如何处理。\r\n\r\n``` js\r\n//=> 15\r\nsum(1, 2, 3) + sum(4, 5)\r\n\r\n//=> 100\r\nsum(10) * sum(10)\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY4MDgzMzk1NA==",
      "body": "这是一个关于懒计算的函数，使用 `sum` 收集所有累加项，使用 `valueOf` 进行计算\r\n\r\n1. sum 返回一个函数，收集所有的累加项，使用递归实现\r\n1. 返回函数带有 `valueOf` 属性，用于统一计算\r\n\r\n代码见 [【Q421】如何实现无限累加的一个函数](https://codepen.io/shanyue/pen/LYymamZ?editors=0012)，方便测试与调试\r\n\r\n``` js\r\nfunction sum (...args) {\r\n  const f = (...rest) => sum(...args, ...rest)\r\n  f.valueOf = () => args.reduce((x, y) => x + y, 0)\r\n  return f\r\n}\r\n```",
      "star": {
        "totalCount": 2
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2ODY4NjEzMTI=",
    "number": 429,
    "title": "【Q422】JS 如何实现一个同步的 sleep 函数",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY4MTIwMjAyOA==",
      "body": "``` js\r\nconst sleep = ms => Atomics.wait(new Int32Array(new SharedArrayBuffer(4)), 0, 0, milliseconds)\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2ODY4NjIzODI=",
    "number": 430,
    "title": "【Q423】什么是安全的正则表达式",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      },
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcwNjg5OTA4OQ==",
      "body": "下边这个正则表达式能把 CPU 跑挂的正则表达式就是一个定时炸弹，回溯次数进入了指数爆炸般的增长。\r\n\r\n> 可以参考文章 [浅析 ReDos 原理与实践](https://www.freebuf.com/articles/network/124422.html)\r\n\r\n``` js\r\nconst safe = require('safe-regex')\r\nconst re = /(x+x+)+y/\r\n\r\n// 能跑死 CPU 的一个正则\r\nre.test('xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx')\r\n\r\n// 使用 safe-regex 判断正则是否安全\r\nsafe(re)   // false\r\n```\r\n\r\n[safe-regex](https://github.com/substack/safe-regex) 能够发现哪些不安全的正则表达式。",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2ODg1Mjc0Nzg=",
    "number": 431,
    "title": "【Q424】TCP 是如何进行流量控制的 (flow control)",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMzA5NzM0Njk0",
        "name": "tcp"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY4MzU3MDU2Ng==",
      "body": "TCP拥塞控制主要有两种。第一种是滑动窗口，保证以一定的速度传输数据，主要是方式数据丢包等问题。第二种是拥塞处理，主要是防止网络中的数据太过多，造成网络拥塞等问题。",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "buzuosheng",
        "url": "https://github.com/buzuosheng"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2OTEwNjQzMTM=",
    "number": 432,
    "title": "【Q425】什么是层叠上下文 (stacking context)",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDczODAwNDk1NQ==",
      "body": "> 我们假定用户正面向（浏览器）视窗或网页，而 HTML 元素沿着其相对于用户的一条虚构的 z 轴排开，层叠上下文就是对这些 HTML 元素的一个三维构想。众 HTML 元素基于其元素属性按照优先级顺序占据这个空间。\r\n\r\n其中，`z-index` 会影响这个层级的优先性",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2OTQzNjU5ODU=",
    "number": 433,
    "title": "【Q426】TCP 报文中的选项 Window scale 是什么意思",
    "body": "![image](https://user-images.githubusercontent.com/13389461/92325971-3f335e80-f081-11ea-8f6e-334d5d9e95f6.png)\r\n",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMzA5NzM0Njk0",
        "name": "tcp"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2OTQzNzQxMzI=",
    "number": 434,
    "title": "【Q427】TCP 报文中的 ack number 如何计算",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMzA5NzM0Njk0",
        "name": "tcp"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU3MDkwNTk1NTA=",
    "number": 435,
    "title": "【Q428】在 nginx 中如何配置负载均衡",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      },
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcwNzA4MDU0OQ==",
      "body": "通过 `proxy_pass` 与 `upstream` 即可实现最为简单的负载均衡。如下配置会对流量均匀地导向 `172.168.0.1`，`172.168.0.2` 与 `172.168.0.3` 三个服务器\r\n\r\n``` conf\r\nhttp {\r\n  upstream backend {\r\n      server 172.168.0.1;\r\n      server 172.168.0.2;\r\n      server 172.168.0.3;\r\n  }\r\n\r\n  server {\r\n      listen 80;\r\n      location / {\r\n          proxy_pass http://backend;\r\n      }\r\n  }\r\n}\r\n```\r\n\r\n关于负载均衡的策略大致有以下四种种\r\n\r\n1. round_robin，轮询\r\n1. weighted_round_robin，加权轮询\r\n1. ip_hash\r\n1. least_conn\r\n\r\n## Round_Robin\r\n\r\n轮询，`nginx` 默认的负载均衡策略就是轮询，假设负载三台服务器节点为 A、B、C，则每次流量的负载结果为 ABCABC\r\n\r\n## Weighted_Round_Robin\r\n\r\n加权轮询，根据关键字 weight 配置权重，如下则平均没来四次请求，会有八次打在 A，会有一次打在 B，一次打在 C\r\n\r\n``` conf\r\nupstream backend {\r\n  server 172.168.0.1 weight=8;\r\n  server 172.168.0.2 weight=1;\r\n  server 172.168.0.3 weight=1;\r\n}\r\n```\r\n\r\n## IP_hash\r\n\r\n对每次的 IP 地址进行 Hash，进而选择合适的节点，如此，每次用户的流量请求将会打在固定的服务器上，利于缓存，也更利于 AB 测试等。\r\n\r\n``` conf\r\nupstream backend {\r\n  server 172.168.0.1;\r\n  server 172.168.0.2;\r\n  server 172.168.0.3;\r\n  ip_hash;\r\n}\r\n```\r\n\r\n## Least Connection\r\n\r\n选择连接数最少的服务器节点优先负载\r\n\r\n``` conf\r\nupstream backend {\r\n  server 172.168.0.1;\r\n  server 172.168.0.2;\r\n  server 172.168.0.3;\r\n  least_conn;\r\n}\r\n```\r\n\r\n说到最后，**这些负载均衡策略对于应用开发者至关重要，而基础开发者更看重如何实现这些策略**，如这四种负载算法如何实现？请参考以后的文章",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3MDkwODUxMzQ=",
    "number": 436,
    "title": "【Q429】实现一个函数用来解析 URL 的 querystring",
    "body": "示例，如\r\n\r\n``` js\r\nconst url = 'https://shanyue.tech?a=3&b=4&c=5'\r\n\r\n// 解析后得到 qs 如下\r\nconst qs = {\r\n  a: 3,\r\n  b: 4,\r\n  c: 5\r\n}\r\n```\r\n\r\n镜像问题: [【Q440】实现一个函数用来对 URL 的 querystring 进行编码](https://github.com/shfshanyue/Daily-Question/issues/448)",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcwMzU2NjM0MQ==",
      "body": "关于路由中解析 querystring，无论前端开发还是后端开发都无时无刻在使用这项功能，即使几乎没有人手动解析过它。这里来实现一个简单粗暴的解析函数\r\n\r\n1. 如何使用正则解析 qs\r\n1. 如何正确转义汉字\r\n1. 如何正确处理数组\r\n1. **如何处理各种复杂的嵌套对象**\r\n\r\n> 关于如何实现复杂嵌套对象，边界条件过多，强烈推荐一个 npm 库 [qs](https://github.com/ljharb/qs)\r\n\r\n为此总结出以下用例用以检查解析函数的正确性\r\n\r\n``` js\r\n// {}\r\n'https://shanyue.tech' \r\n\r\n// {a: ''}\r\n'https://shanyue.tech?a' \r\n\r\n// {name: '山月'}\r\n'https://shanyue.tech?name=%E5%B1%B1%E6%9C%88'    \r\n\r\n// {name: '山月', a: 3}                \r\n'https://shanyue.tech?name=%E5%B1%B1%E6%9C%88&a=3'            \r\n\r\n// {name: '山月', a: [3, 4]}\r\n'https://shanyue.tech?name=%E5%B1%B1%E6%9C%88&a=3&a=4'   \r\n\r\n// {name: '山月', a: 3}\r\n'https://shanyue.tech?name=%E5%B1%B1%E6%9C%88&a=3#hash' \r\n\r\n// {name: '1+1=2'}\r\n'https://shanyue.tech?name=1%2B1%3D2' \r\n```\r\n\r\n纯碎使用 `javascript` 完成解析函数，而不利用浏览器 DOM 特性 API，代码如下所示，细节在注释中体现\r\n\r\n``` js\r\nfunction parse(url) {\r\n\r\n  // 一、夹杂在 ? 与 # 之前的字符就是 qs，使用 /\\?([^/?#:]+)#?/ 正则来抽取\r\n  // 使用正则从 URL 中解析出 querystring\r\n  // 二、通过 Optional Chain 来避免空值错误\r\n  const queryString = url.match(/\\?([^/?#:]+)#?/)?.[1]\r\n\r\n  if (!queryString) { return {} }\r\n\r\n  queryObj = queryString.split('&').reduce((params, block) => {\r\n    // 三、如果未赋值，则默认为空字符串\r\n    const [_k, _v = ''] = block.split('=')\r\n    // 四、通过 decodeURIComponent 来转义字符，切记不可出现在最开头，以防 ?tag=test&title=1%2B1%3D2 出错\r\n    const k = decodeURIComponent(_k)\r\n    const v = decodeURIComponent(_v)\r\n\r\n    if (params[k] !== undefined) {\r\n      // 处理 key 出现多次的情况，设置为数组\r\n      params[k] = [].concat(params[k], v)\r\n    } else {\r\n      params[k] = v\r\n    }\r\n    return params\r\n  }, {})\r\n  return queryObj\r\n}\r\n```\r\n\r\n如果引入浏览器特性 API，问题就简单很多迎刃而解，所涉及到的 API 有两个，这里不做展开\r\n\r\n1. `new URL(url)`\r\n1. `new URLSearchParams(paramsString)`",
      "star": {
        "totalCount": 1
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3MTg4MDAxODc=",
    "number": 437,
    "title": "【Q430】如何把 DOM 转化为图片",
    "body": "可参考npm package\r\n\r\n1. [html2canvas](https://html2canvas.hertzen.com/): Screenshots with JavaScript\r\n1. [dom-to-image](https://github.com/tsayen/dom-to-image): Generates an image from a DOM node using HTML5 canvas",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDczMDI1MDg5MA==",
      "body": "https://www.zhangxinxu.com/study/201708/svg-foreignobject-dom-to-image.html\r\n看到这样一篇文章",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "markgong-gd",
        "url": "https://github.com/markgong-gd"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3Mjc0NDkxNDg=",
    "number": 438,
    "title": "【Q431】http 状态码 401 和 403 有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg2ODk5MDI0MQ==",
      "body": "401 --- unAuthorized  \r\n403 --- forbidden\r\n区别：前者需要用户验证，验证成功之后服务器会执行请求。\r\n           后者是服务器理解请求，但是拒绝执行。跟用户验证没有关系，服务器主动拒绝执行请求。",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "Kiera569",
        "url": "https://github.com/Kiera569"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3Mjc4ODI0NzY=",
    "number": 439,
    "title": "【Q432】如何给 graphql 设计合理的 Rate Limit",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      },
      {
        "id": "MDU6TGFiZWwxNjkyOTk0Mjk2",
        "name": "graphql"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDczNzk5ODYyNQ==",
      "body": "对于 Rest API 而言可根据特定的 API 来进行*限流(Rate Limit)*设计\r\n\r\n然而，GraphQL 只有一个 API，无法根据此来限流，一般情况下根据 `Field` 来进行限流，为了更好地设计及声明限流条件，可自定义 `Directive`，如下所示\r\n\r\n``` gql\r\ntype Query {\r\n  todos: [Todo!]! @rateLimit(window: \"1s\", max: 100)\r\n}\r\n```\r\n\r\n可参考以下两个 npm package\r\n\r\n+ [graphql-rate-limit](https://github.com/teamplanes/graphql-rate-limit)\r\n+ [graphql-rate-limit-directive](https://github.com/ravangen/graphql-rate-limit)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3Mjc5MDU1MzQ=",
    "number": 440,
    "title": "【Q433】在C语言中，void 是什么意思",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzQ1MjU2MzU2",
        "name": "c"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcxNDkwNzMzOA==",
      "body": "`void`，空的意思，意即无需返回。\r\n\r\n``` c\r\n#include <stdio.h>\r\n\r\nvoid print() {\r\n  puts(\"hello, world\");\r\n  return;\r\n}\r\n\r\nint main() {\r\n  print();\r\n  return 0;\r\n}\r\n```\r\n\r\n代码如上所示: `return` 没有返回任何东西，为其简便可以省略不写，以下两者是等价的\r\n\r\n``` c\r\nvoid print() {\r\n  puts(\"hello, world\");\r\n  return;\r\n}\r\n\r\nvoid print() {\r\n  puts(\"hello, world\");\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3MzMyNjMxMjI=",
    "number": 441,
    "title": "【Q434】当服务器资源返回 304 时与那些 HTTP 响应头有关",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcxOTYzNTkyNg==",
      "body": "304 Not Modified，表示资源没有发生过改变。\r\n与协商缓存有关，也就是Last-Modify和Etag两个http响应头，在获取资源之前先判断缓存资源是否发生过改变。\r\nno-cache表示使用缓存资源时，都向服务器请求验证。\r\nno-store才表示不使用任何形式的缓存。",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "buzuosheng",
        "url": "https://github.com/buzuosheng"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3MzQxNTU5OTE=",
    "number": 442,
    "title": "【Q435】JS 如何实现一个 sleep/delay 函数",
    "body": "`sleep` 函数实现较为简单，也常作为对 `Promise` 的代码考察。在日常工作中，特别是 Node 写脚本时，常用它控制频率。\r\n\r\n实现一个 sleep 函数格式如下：\r\n\r\n``` ts\r\ntype sleep = (s: number) => Promise<void>\r\n```\r\n\r\n**追问:**\r\n\r\n实现一个 delay 函数格式如下，在 N 毫秒之后执行函数，并以函数结果作为返回值\r\n\r\n``` ts\r\nfunction delay (func, seconds, ...args) {\r\n\r\n}\r\n\r\n// 在 3s 之后返回 hello, world\r\nawait delay((str) => str, 3000, 'hello, world')\r\n\r\n// 在 3s 之后返回 hello, world，第一个函数可返回 promise\r\nawait delay((str) => Promise.resolve(str), 3000, 'hello, world')\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcyNTg2NzU3Nw==",
      "body": "```javascript\r\nfunction delay(time) {\r\n    return new Promise((resolve)=> {\r\n        setTimeout(() => {\r\n            resolve()\r\n        }, time)\r\n    })\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "yuuk",
        "url": "https://github.com/yuuk"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3NDEyMjEyMjM=",
    "number": 443,
    "title": "【Q436】如何实现一个 sample 函数，从数组中随机取一个元素",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcyODg0ODc5OQ==",
      "body": "function sample(arr){\r\n  const index = Math.floor(Math.random() * arr.length )\r\n  return arr[index]\r\n}",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "eriksyuan",
        "url": "https://github.com/eriksyuan"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3NDMwMDA4MzY=",
    "number": 444,
    "title": "【Q437】浏览器的剪切板中如何监听复制事件",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcyOTM0MzcxNw==",
      "body": "在HTML元素上\r\n```html\r\n<input oncopy='cb'>\r\n```\r\n在JS中获取具体元素\r\n```js\r\ndocument.querySelector('p').oncopy = cb\r\ndocument.oncopy = cb\r\n```\r\n或者\r\n```js\r\ndocument.querySelector('p').addEventListener('copy',cb)\r\ndocument.addEventListener('copy',cb)\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "nishuzumi",
        "url": "https://github.com/nishuzumi"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3NjEzNzkwNTI=",
    "number": 445,
    "title": "【Q438】数据库设计时 char 与 varchar 有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU3NjUyMTc2MDQ=",
    "number": 447,
    "title": "【Q439】JSONP 的原理是什么，如何实现",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      },
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc0Nzc5ODEyMg==",
      "body": "摘自山月的博客，原文地址: <https://shanyue.tech/code/jsonp/>\r\n\r\n\r\n## 一个正常的请求: JSON\r\n\r\n正常发请求时，`curl` 示例:\r\n\r\n``` bash\r\n$ curl https://shanyue.tech/api/user?id=100\r\n\r\n{\r\n  \"id\": 100,\r\n  \"name\": \"shanyue\",\r\n  \"wechat\": \"xxxxx\",\r\n  \"phone\": \"183xxxxxxxx\"\r\n}\r\n```\r\n\r\n使用 `fetch` 发送请求，示例:\r\n\r\n``` js\r\nconst data = await fetch('https://shanyue.tech/api/user?id=100', {\r\n  headers: {\r\n    'content-type': 'application/json',\r\n  },\r\n  method: 'GET',\r\n}).then(res => res.json())\r\n```\r\n\r\n请求数据后，使用一个函数来处理数据\r\n\r\n``` js\r\nhandleData(data)\r\n```\r\n\r\n## 一个 JSONP 请求\r\n\r\n`JSONP`，全称 `JSON with Padding`，为了解决跨域的问题而出现。虽然它只能处理 GET 跨域，虽然现在基本上都使用 CORS 跨域，但仍然要知道它，毕竟**面试会问**。\r\n\r\n`JSONP` 基于两个原理:\r\n\r\n1. 动态创建 `script`，使用 `script.src` 加载请求跨过跨域\r\n1. `script.src` 加载的脚本内容为 JSONP: 即 `PADDING(JSON)` 格式\r\n\r\n从上可知，使用 `JSONP` 跨域同样需要服务端的支持。`curl` 示例\r\n\r\n``` bash\r\n$ curl https://shanyue.tech/api/user?id=100&callback=padding\r\n\r\npadding({\r\n  \"id\": 100,\r\n  \"name\": \"shanyue\",\r\n  \"wechat\": \"xxxxx\",\r\n  \"phone\": \"183xxxxxxxx\"\r\n})\r\n```\r\n\r\n对于正常的请求有何不同一目了然: **多了一个 callback=padding, 并且响应数据被 padding 包围**，这就是 JSONP\r\n\r\n**那请求数据后，如何处理数据呢？此时的 padding 就是处理数据的函数**。我们只需要在前端实现定义好 padding 函数即可\r\n\r\n``` js\r\nwindow.padding = handleData\r\n```\r\n\r\n基于以上两个原理，这里实现一个简单 jsonp 函数：\r\n\r\n``` js\r\nfunction jsonp_simple ({ url, onData, params }) {\r\n  const script = document.createElement('script')\r\n\r\n  // 一、默认 callback 函数为 padding\r\n  script.src = `${url}?${stringify({ callback: 'padding', ...params })}`\r\n\r\n  // 二、使用 onData 作为 window.padding 函数，接收数据\r\n  window['padding'] = onData\r\n\r\n  // 三、动态加载脚本\r\n  document.body.appendChild(script)\r\n}\r\n\r\n// 发送 JSONP 请求\r\njsonp_simple({\r\n  url: 'http://localhost:10010',\r\n  params: { id: 10000 },\r\n  onData (data) {\r\n    console.log('Data:', data)\r\n  }\r\n})\r\n```\r\n\r\n此时会有一个问题: **window.padding 函数会污染全局变量，如果有多个 JSONP 请求发送如何处理？**\r\n\r\n**使 jsonp 的回调函数名作为一个随机变量，避免冲突**，代码如下\r\n\r\n``` js\r\nfunction jsonp ({ url, onData, params }) {\r\n  const script = document.createElement('script')\r\n\r\n  // 一、为了避免全局污染，使用一个随机函数名\r\n  const cbFnName = `JSONP_PADDING_${Math.random().toString().slice(2)}`\r\n\r\n  // 二、默认 callback 函数为 cbFnName\r\n  script.src = `${url}?${stringify({ callback: cbFnName, ...params })}`\r\n\r\n  // 三、使用 onData 作为 cbFnName 回调函数，接收数据\r\n  window[cbFnName] = onData;\r\n\r\n  document.body.appendChild(script)\r\n}\r\n\r\n// 发送 JSONP 请求\r\njsonp({\r\n  url: 'http://localhost:10010',\r\n  params: { id: 10000 },\r\n  onData (data) {\r\n    console.log('Data:', data)\r\n  }\r\n})\r\n```\r\n\r\n## 服务器端代码\r\n\r\n`JSONP` 需要服务端进行配合，返回 `JSON With Padding` 数据，代码如下:\r\n\r\n``` js\r\nconst http = require('http')\r\nconst url = require('url')\r\nconst qs = require('querystring')\r\n\r\nconst server = http.createServer((req, res) => {\r\n  const { pathname, query } = url.parse(req.url)\r\n  const params = qs.parse(query)\r\n\r\n  const data = { name: 'shanyue', id: params.id }\r\n\r\n  if (params.callback) {\r\n    // 服务端将要返回的字符串\r\n    str = `${params.callback}(${JSON.stringify(data)})`\r\n    res.end(str)\r\n  } else {\r\n    res.end()\r\n  }\r\n})\r\n\r\nserver.listen(10010, () => console.log('Done'))\r\n\r\n```\r\n\r\n## 完整代码附录\r\n\r\n完整代码可见[山月博客的 github 仓库](https://github.com/shfshanyue/blog/tree/master/code): <https://github.com/shfshanyue/blog/tree/master/code/jsonp/>\r\n\r\n**JSONP 实现完整代码:**\r\n\r\n``` js\r\nfunction stringify (data) {\r\n  const pairs = Object.entries(data)\r\n  const qs = pairs.map(([k, v]) => {\r\n    let noValue = false\r\n    if (v === null || v === undefined || typeof v === 'object') {\r\n      noValue = true\r\n    }\r\n    return `${encodeURIComponent(k)}=${noValue ? '' : encodeURIComponent(v)}`\r\n  }).join('&')\r\n  return qs\r\n}\r\n\r\nfunction jsonp ({ url, onData, params }) {\r\n  const script = document.createElement('script')\r\n\r\n  // 一、为了避免全局污染，使用一个随机函数名\r\n  const cbFnName = `JSONP_PADDING_${Math.random().toString().slice(2)}`\r\n  // 二、默认 callback 函数为 cbFnName\r\n  script.src = `${url}?${stringify({ callback: cbFnName, ...params })}`\r\n  // 三、使用 onData 作为 cbFnName 回调函数，接收数据\r\n  window[cbFnName] = onData;\r\n\r\n  document.body.appendChild(script)\r\n}\r\n```\r\n\r\n**JSONP 服务端适配相关代码:**\r\n\r\n``` js\r\nconst http = require('http')\r\nconst url = require('url')\r\nconst qs = require('querystring')\r\n\r\nconst server = http.createServer((req, res) => {\r\n  const { pathname, query } = url.parse(req.url)\r\n  const params = qs.parse(query)\r\n\r\n  const data = { name: 'shanyue', id: params.id }\r\n\r\n  if (params.callback) {\r\n    str = `${params.callback}(${JSON.stringify(data)})`\r\n    res.end(str)\r\n  } else {\r\n    res.end()\r\n  }\r\n\r\n})\r\n\r\nserver.listen(10010, () => console.log('Done'))\r\n```\r\n\r\n**JSONP 页面调用相关代码**\r\n\r\n``` html\r\n\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n  <meta charset=\"UTF-8\">\r\n  <title></title>\r\n</head>\r\n<body>\r\n  <script src=\"./index.js\" type=\"text/javascript\"></script>\r\n  <script type=\"text/javascript\">\r\n  jsonp({\r\n    url: 'http://localhost:10010',\r\n    params: { id: 10000 },\r\n    onData (data) {\r\n      console.log('Data:', data)\r\n    }\r\n  })\r\n  </script>\r\n</body>\r\n</html>\r\n```\r\n\r\n## JSONP 实现代码示例演示\r\n\r\n+ 从中克隆代码: [山月博客的 github 仓库](https://github.com/shfshanyue/blog/tree/master/code)\r\n+ 从中克隆代码: [山月博客的 github 仓库](https://github.com/shfshanyue/blog/tree/master/code)\r\n+ 从中克隆代码: [山月博客的 github 仓库](https://github.com/shfshanyue/blog/tree/master/code)\r\n\r\n### 文件结构\r\n\r\n+ `index.js`: jsonp 的简单与复杂实现\r\n+ `server.js`: 服务器接口形式\r\n+ `demo.html`: 前端如何调用 JSONP\r\n\r\n### 快速演示\r\n\r\n``` js\r\n// 开启服务端\r\n$ node server.js\r\n\r\n// 对 demo.html 起一个服务，并且按照提示在浏览器中打开地址，应该是 http://localhost:5000\r\n// 观察控制台输出 JSONP 的回调结果\r\n$ serve .\r\n```\r\n\r\n",
      "star": {
        "totalCount": 1
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3NjU0OTM2Mjg=",
    "number": 448,
    "title": "【Q440】实现一个函数用来对 URL 的 querystring 进行编码",
    "body": "示例，如\r\n\r\n``` js\r\nconst data = {\r\n  a: 3,\r\n  b: 4,\r\n  c: 5\r\n}\r\n\r\n// 对 data 编码后得到 querystring 如下\r\n//=> 'a=3&b=4&c=5'\r\nstringify(data)\r\n```\r\n\r\n镜像问题: [【Q429】实现一个函数用来解析 URL 的 querystring](https://github.com/shfshanyue/Daily-Question/issues/436)",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc0NDM0ODYwMw==",
      "body": "先上几个测试用例:\r\n\r\n``` js\r\n// a=3&b=4\r\nstringify({ a: 3, b: 4 })\r\n\r\n// a=3&b=\r\nstringify({ a: 3, b: null })\r\n\r\n// a=3&%E5%B1%B1=%E6%9C%88\r\nstringify({ a: 3, '山': '月' })\r\n```\r\n\r\n只做一些基本的功能，满足以下条件\r\n\r\n1. 对 null/undefined/object 编码为空字符\r\n1. 对 key/value 记得 encodeURIComponent\r\n1. 不考虑数组及嵌套对象等复杂操作\r\n\r\n``` js\r\nfunction stringify (data) {\r\n  const pairs = Object.entries(data)\r\n  const qs = pairs.map(([k, v]) => {\r\n    let noValue = false\r\n    if (v === null || v === undefined || typeof v === 'object') {\r\n      noValue = true\r\n    }\r\n    return `${encodeURIComponent(k)}=${noValue ? '' : encodeURIComponent(v)}`\r\n  }).join('&')\r\n  return qs\r\n}\r\n```\r\n\r\n这是一个最简单对 querystring 进行编码的函数，如果需要更复杂的需求如嵌套对象与数组可以参考 [qs](https://github.com/ljharb/qs)",
      "star": {
        "totalCount": 1
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3NzA1MTgzOTc=",
    "number": 449,
    "title": "【Q441】v8 是如何执行一段 JS 代码的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc0NzgzMzMyNA==",
      "body": "## 参考几篇文章\r\n\r\n+ [V8是如何执行JavaScript代码的？](https://zhuanlan.zhihu.com/p/96502646)\r\n+ [[译]JavaScript是如何工作的：深入V8引擎&编写优化代码的5个技巧](https://zhuanlan.zhihu.com/p/57898561)\r\n+ [JavaScript 引擎 V8 执行流程概述](https://zhuanlan.zhihu.com/p/111386872)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3NzA1MzU4MjY=",
    "number": 450,
    "title": "【Q442】http3 解决了什么问题",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc0Nzg0NDg2NA==",
      "body": "`http3` 基于 `UDP` 协议，这是与以前版本的 http 最大的不同，可以解决 http2 TCP 连接阻塞的问题。",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3NzA1MzcyMDk=",
    "number": 451,
    "title": "【Q443】实现一个数组扁平化的函数 flatten ",
    "body": "`flatten` 模拟 `Array.prototype.flat` 实现，默认展开一层，可传递参数用以展开多层\r\n\r\n``` js\r\n// [1, 2, 3, 4, [5, 6]]\r\nflatten([1, 2, 3, [4, [5, 6]]])\r\n\r\n// [1, 2, 3, 4, 5, 6]\r\nflatten([1, 2, 3, [4, [5, 6]]], 2)\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc1MjY3NDg4MQ==",
      "body": "在 ES2019 之前，可通过 **`reduce` + `concat`** 实现，由于 `Array.prototype.concat` 既可以连接数组又可以连接单项，十分巧妙\r\n\r\n``` js\r\nconst flatten = list => list.reduce( (a, b) => a.concat(b), [])\r\n```\r\n\r\n一个更简单的实现方式是 `Array.prototype.concat` 与 `...` 运算符\r\n\r\n``` js\r\nconst flatten = list => [].concat(...list)\r\n```\r\n\r\n如果要求深层数组打平，则如下实现\r\n\r\n``` js\r\nconst flatten = list => list.reduce((a, b) => a.concat(Array.isArray(b) ? flatten(b) : b), [])\r\n```\r\n\r\n如果要求如同原生 API `Array.prototype.flat` 一致的 API，可传入可扁平的深度。代码可见 [【Q443】实现一个数组扁平化的函数 flatten](https://codepen.io/shanyue/pen/xxdjQXG?editors=0012)\r\n\r\n``` js\r\nfunction flatten (list, depth = 1) {\r\n  if (depth === 0) return list\r\n  return list.reduce((a, b) => a.concat(Array.isArray(b) ? flatten(b, depth - 1) : b), [])\r\n}\r\n```\r\n\r\n在 ES2019 之后，可通过 **`Array.prototype.flat`** 直接实现！",
      "star": {
        "totalCount": 2
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3NzA1MzgyMDg=",
    "number": 452,
    "title": "【Q444】介绍 CSS 隐藏页面中某个元素的几种方法",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc1NTA0NDYyOQ==",
      "body": "CSS方法一：\r\n`display:none`\r\nCSS方法二：\r\n`position:absolute;top:-1000px;left:-1000px;`",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "borgle",
        "url": "https://github.com/borgle"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3NzA1Mzk1NzM=",
    "number": 453,
    "title": "【Q445】实现一个数组去重函数 unique",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc2MDc1MTgyNw==",
      "body": "```js\r\nfunction unique(arr) {\r\n  if (!Array.isArray(arr)) throw new TypeError();\r\n  return [...new Set(arr)];\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "justable",
        "url": "https://github.com/justable"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3NzA1NDA5Njk=",
    "number": 454,
    "title": "【Q446】如何实现页面文本不可复制",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc0Nzg1MDQ3Mg==",
      "body": "`user-select: none` 不可选中就不可复制👀",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "ssruoyan",
        "url": "https://github.com/ssruoyan"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3NzA5NjUyNDU=",
    "number": 455,
    "title": "【Q447】如何实现一个数组洗牌函数 shuffle",
    "body": "参考链接：https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle\r\n\r\n``` js\r\n// 打乱数组，有可能是 [1, 3, 2, 4]，但对原数组没有影响\r\nshuffle([1, 2, 3, 4])\r\n``` ",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc0ODE1MjU2Mw==",
      "body": "先来一个利用 `Array.prototype.sort` 的技巧解法\r\n\r\n``` js\r\nconst shuffle = (list) => list.sort((x, y) => Math.random() - 0.5)\r\n```\r\n\r\n使用以下算法可实现洗牌算法:\r\n\r\n1. 第 N 项数字与前 N 项数字随机选一相互交换\r\n2. 第 N-1 项数字与前 N-1 项数字随机选一相互交换\r\n3. ...\r\n3. 第 2 项数字与前 2 项数字随机选一相互交换\r\n\r\n代码调试及测试可见 [【Q447】如何实现一个数组洗牌函数 shuffle - codepen](https://codepen.io/shanyue/pen/KKmRqZJ?editors=0012)\r\n\r\n``` js\r\nfunction shuffle (list) {\r\n  const len = list.length\r\n  let result = [...list]\r\n  for (let i = len - 1; i > 0; i--) {\r\n    const swapIndex = Math.floor(Math.random() * (i + 1));\r\n    [result[i], result[swapIndex]] = [result[swapIndex], result[i]]\r\n  }\r\n  return result\r\n}\r\n```",
      "star": {
        "totalCount": 1
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3NzE2MTE4MzA=",
    "number": 456,
    "title": "【Q448】异步加载 JS 脚本时，async 与 defer 有何区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc0ODk5MzM5OA==",
      "body": "> 以下图片取自 whatwg 的规范，可以说是最权威的图文解释了，详细参考[原文](https://html.spec.whatwg.org/multipage/scripting.html#the-script-element)\r\n\r\n![async 与 defer 区别](https://html.spec.whatwg.org/images/asyncdefer.svg)\r\n\r\n在*正常情况下*，即 `<script>` 没有任何额外属性标记的情况下，有几点共识\r\n\r\n1. JS 的脚本分为**加载、解析、执行**几个步骤，简单对应到图中就是 `fetch` (加载) 和 `execution` (解析并执行)\r\n2. **JS 的脚本加载(fetch)且执行(execution)会阻塞 DOM 的渲染**，因此 JS 一般放到最后头\r\n\r\n而 `defer` 与 `async` 的区别如下:\r\n\r\n+ 相同点: **异步加载 (fetch)** \r\n+ 不同点:\r\n  + async 加载(fetch)完成后立即执行 (execution)，因此可能会阻塞 DOM 解析；\r\n  + defer 加载(fetch)完成后延迟到 DOM 解析完成后才会执行(execution)**，但会在事件 `DomContentLoaded` 之前\r\n\r\n## 拓展\r\n\r\n当以下 `index.js` 加载时，属性是 `async` 与 `defer` 时，输出有何不同？\r\n\r\n**index.html**\r\n\r\n``` html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n  <meta charset=\"UTF-8\">\r\n  <title></title>\r\n</head>\r\n<body>\r\n  <script src=\"./defer.js\" defer></script>\r\n  <script src=\"./async.js\" async></script>\r\n  <script>\r\n    console.log('Start')\r\n    document.addEventListener('DOMContentLoaded', () => {\r\n      console.log('DCL')\r\n    })\r\n  </script>\r\n</body>\r\n</html>\r\n```\r\n\r\n**derfer.js**\r\n\r\n``` js\r\nconsole.log('Defer Script')\r\n```\r\n\r\n\r\n**async.js**\r\n\r\n``` js\r\nconsole.log('Async Script')\r\n```\r\n\r\n答：defer 总是在 DCL 之前输出，但是 async 有可能之前也有可能之后",
      "star": {
        "totalCount": 1
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3NzIyMTMwMTQ=",
    "number": 457,
    "title": "【Q449】vue3 中，如何监听数组的变化",
    "body": "比如深层数组如何监听",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
        "name": "vue"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc3NTc3OTYzNA==",
      "body": "不需要额外监听，因为 Proxy 代理后的数据，数组的修改也是可以监听到的，reactive 之后直接修改即可。",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "18sby",
        "url": "https://github.com/18sby"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3NzIyMTUyNDE=",
    "number": 458,
    "title": "【Q450】Vue 中 nextTick 的实现原理是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
        "name": "vue"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc0OTAwOTQzMw==",
      "body": "+ Promise\r\n+ MutationObserver\r\n+ setImmediate\r\n+ setTimeout",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3NzIyMTg5NDU=",
    "number": 459,
    "title": "【Q451】同一进程的线程共享那些资源",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      },
      {
        "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
        "name": "os"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc0OTAwODU5Ng==",
      "body": "+ 堆\r\n+ 全局变量\r\n+ 文件",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3NzMwNDI0MzI=",
    "number": 460,
    "title": "【Q452】现代框架如 React、Vue 相比原生开发有什么优势",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      },
      {
        "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
        "name": "vue"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs442H_3",
      "body": "render（UI）",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "illumi520",
        "url": "https://github.com/illumi520"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3NzYyMzk3NTE=",
    "number": 461,
    "title": "【Q453】typeof 与 instanceof 的区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc1MjMyNjc5NQ==",
      "body": "1. `typeof` 用以**判断基础数据类型** (null 除外)\r\n2. `instanceOf` 借助原型链**判断复杂数据类型**\r\n\r\n如以下示例：\r\n\r\n``` js\r\n> typeof 3\r\n< \"number\"\r\n> [] instanceof Array\r\n< true\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3NzYyNTU3MDc=",
    "number": 462,
    "title": "【Q454】load 事件与 DomContentLoaded 事件的先后顺序",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs401qaK",
      "body": "当初始的 `HTML` 文档被完全加载和解析完成之后，`DOMContentLoaded` 事件被触发，而无需等待样式表、图像和子框架的完全加载.\r\n\r\n当整个页面及所有依赖资源如样式表和图片都已完成加载时，将触发`load`事件\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "haotie1990",
        "url": "https://github.com/haotie1990"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3NzYyNTgyNzg=",
    "number": 463,
    "title": "【Q455】React/Vue 中的 router 实现原理如何",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      },
      {
        "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
        "name": "vue"
      },
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc1MzkxNDg0NQ==",
      "body": "前端路由实现的本质是**监听url变化**，实现方式有两种：Hash模式和History模式，无需刷新页面就能重新加载相应的页面。\r\nHash url的格式为`www.a.com/#/`，当#后的哈希值发生变化时，通过hashchange事件监听，然后页面跳转。\r\nHistory url通过`history.pushState`和`history.replaceState`改变url。\r\n两种模式的区别：\r\n\r\n- hash只能改变#后的值，而history模式可以随意设置同源url；\r\n- hash只能添加字符串类的数据，而history可以通过API添加多种类型的数据；\r\n- hash的历史记录只显示之前的`www.a.com`而不会显示hash值，而history的每条记录都会进入到历史记录；\r\n- hash无需后端配置且兼容性好，而history需要配置`index.html`用于匹配不到资源的情况。",
      "star": {
        "totalCount": 1
      },
      "author": {
        "login": "buzuosheng",
        "url": "https://github.com/buzuosheng"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3Nzc0MDgzMjU=",
    "number": 464,
    "title": "【Q456】简述 RPC 的实现原理",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
        "name": "micro-service"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU3Nzc0MDgzOTU=",
    "number": 465,
    "title": "【Q457】如何对微服务进行拆分",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
        "name": "micro-service"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU3Nzc0NTQ4NDY=",
    "number": 466,
    "title": "【Q458】服务器CPU过高时如何排查及解决问题",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc1MzQ3MTIzNA==",
      "body": "1. `htop` 查询CPU使用率最高的进程\r\n2. `pidstat` 监控该进程的变化并调试: `pidstat -u -p pid`\r\n\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3Nzc0NTU4NDg=",
    "number": 467,
    "title": "【Q459】mysql 中 limit offset 过大导致查询缓慢的原因及解决方案",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc1NjUwOTkwNQ==",
      "body": "``` sql\r\nSELECT * FROM User LIMIT 1000000, 10\r\n```\r\n\r\n如上语句，跳过 1000000 行用户，取其后的 10 个用户。**其中 offset 过大，将会进行 1000000 行扫描，导致磁盘 IO 多大，拖垮数据库**\r\n\r\n解决方案也很简单: **取出这10个用户的 ID，由于查询 ID 使用聚簇索引，避免 100000 行的磁盘 IO，再通过子查询找到这 10 个用户的所有数据**\r\n\r\n更多链接: [Mysql index configuration](https://stackoverflow.com/questions/1612957/mysql-index-configuration)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3Nzc0NzY4NDE=",
    "number": 468,
    "title": "【Q460】在服务端反爬虫有哪些策略",
    "body": "在服务端反爬/防爬有哪些策略",
    "labels": [
      {
        "id": "MDU6TGFiZWwxOTU2NjA5OTU2",
        "name": "爬虫"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc1MzU3MTgxMw==",
      "body": "## 01 Referer: 当前页面的访问源\r\n\r\nReferer 指当前请求页面的来源页面的地址，用以判断当前页面的访问源。一般用以反爬，比如**图片防盗链**通过判断 `Referer` 是否目标网站而对图片替换为禁止标志的图片。\r\n\r\n## 02 User-Agent: 当前页面的用户代理，如浏览器等\r\n\r\nUser-Agent 指请求当前页面的用户代理，用以标识请求方环境，如浏览器等，如果没有这个字符串可以视为爬虫。同时为了避免伪造用户代理，可以对 User-Agent 进行**限流**，但同时也有随机生成 UA 的库\r\n\r\n+ [random-useragent](https://github.com/skratchdot/random-useragent)\r\n\r\n## 03 Rate-Limit: 限流\r\n\r\n+ 对 IP 地址进行限流\r\n+ 对 UA 进行限流\r\n\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3ODIwODY5MzE=",
    "number": 469,
    "title": "【Q461】如何计算白屏时间和首屏时间",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
        "name": "html"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDgwOTg4MTgxNA==",
      "body": "\r\n白屏时间: window.performance.timing.domLoading - window.performance.timing.navigationStart\r\n\r\n首屏时间: window.performance.timing.domInteractive  - window.performace.timing.navigationStart",
      "star": {
        "totalCount": 1
      },
      "author": {
        "login": "hhhpw",
        "url": "https://github.com/hhhpw"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3ODIwOTA5NTg=",
    "number": 470,
    "title": "【Q462】JS 如何翻转一个字符串",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc1NjczNjA5Ng==",
      "body": "``` js\r\nconst reverse = s => s.split('').reverse().join('')\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3ODM5MDIwNzQ=",
    "number": 471,
    "title": "【Q463】前端如何实现文件上传功能",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs40ySSx",
      "body": "Blob -> ",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3ODY1MzE3ODg=",
    "number": 472,
    "title": "【Q464】什么是重排重绘，如何减少重拍重绘",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
        "name": "html"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc2MDY2MDE4Nw==",
      "body": "重排和重绘是关键渲染路径中的两步，可以参考另一个问题: [什么是关键渲染路径](https://q.shanyue.tech/fe/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/391.html)\r\n\r\n+ 重排(Reflow)：元素的位置发生变动时发生重排，也叫回流。此时在关键渲染路径中的 Layout 阶段，计算每一个元素在设备视口内的确切位置和大小。当一个元素位置发生变化时，其父元素及其后边的元素位置都可能发生变化，代价极高\r\n    ![](https://q.shanyue.tech/assets/layout.png)\r\n\r\n+ 重绘(Repaint): 元素的样式发生变动，但是位置没有改变。此时在关键渲染路径中的 Paint 阶段，将渲染树中的每个节点转换成屏幕上的实际像素，这一步通常称为绘制或栅格化\r\n    ![](https://q.shanyue.tech/assets/paint.png)\r\n\r\n另外，重排必定会造成重绘。以下是避免过多重拍重绘的方法\r\n\r\n1. 使用 `DocumentFragment` 进行 DOM 操作，不过现在原生操作很少也基本上用不到\r\n2. CSS 样式尽量批量修改\r\n3. 避免使用 table 布局\r\n4. 为元素提前设置好高宽，不因多次渲染改变位置\r\n\r\n\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3OTM4MjA1Njk=",
    "number": 473,
    "title": "【Q465】css 如何实现响应式布局大屏幕三等分、中屏幕二等分、小屏幕一等分",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc2OTczMzExOQ==",
      "body": "页面布局元素如下，item 数量不固定\r\n\r\n``` html\r\n<div class=\"container\">\r\n  <div class=\"item\"></div>\r\n  <div class=\"item\"></div>\r\n  <div class=\"item\"></div>\r\n  <div class=\"item\"></div>\r\n  <div class=\"item\"></div>\r\n  <div class=\"item\"></div>\r\n</div>\r\n```\r\n\r\n使用 Grid 布局可以轻松解决这个问题，如若使用其它方案，控制好等分的同时再控制好间距也是一个十分头疼的问题:\r\n\r\n1. `grid-template-columns`: 控制等分\r\n2. `gap`: 控制间隙\r\n\r\n效果可见 [codepen](https://codepen.io/shanyue/pen/rNyLvBe)\r\n\r\n``` css\r\n@media (min-width: 768px) {\r\n  .container {\r\n    grid-template-columns: repeat(2, minmax(0,1fr));\r\n  }\r\n}\r\n\r\n@media (min-width: 1024px) {\r\n  .container {\r\n    grid-template-columns: repeat(3, minmax(0, 1fr));\r\n  }\r\n}\r\n\r\n.container {\r\n  display: grid;\r\n}\r\n\r\n.conainer {\r\n  gap: 1rem;\r\n}\r\n```\r\n\r\n`TailwindCSS` 是一款非常方便的 CSS 原子类框架，只需要一行即可搞定\r\n\r\n``` html\r\n<div class=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4\"></div>\r\n```\r\n\r\n但是这就够了吗？\r\n\r\n这远远不够，这也足够复杂！\r\n\r\n1. 需要媒体查询\r\n2. 需要人为设置 breakpoint，设置大小屏幕的边界\r\n\r\n## 终极解决方案\r\n\r\n`Grid` 布局可以自动判断容器大小，无论大小屏幕自动撑满并均分，请看以下属性\r\n\r\n``` css\r\n.container {\r\n  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr))\r\n}\r\n```\r\n\r\n1. `repeat`: 用以 N 整分\r\n1. `auto-fill`：表示自动填充\r\n2. `minmx`: 即书面意思，最小宽度为 `300px`\r\n\r\n[使用终极解决方案的在线页面](https://devtool.tech/fe-logo)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3OTc3MDYxOTQ=",
    "number": 474,
    "title": "【Q466】在 SSR 项目中如何判断当前环境时服务器端还是浏览器端",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg1Mjg0MzgwNw==",
      "body": "1. SSR渲染的时候，服务端与客户端走不同的webpack打包配置。\r\n那么就可以在打包的时候写入区分环境的环境变量。\r\n2. 服务器端是没有window document 等浏览器宿主环境对象的，可以通过 类型检测 这些对象 来区分。\r\n``` typeof window === undefined ",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "listenecho",
        "url": "https://github.com/listenecho"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3OTc4OTM2NjY=",
    "number": 475,
    "title": "【Q467】前端打包时 cjs、es、umd 模块有何不同",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc5MTQwNDU5MA==",
      "body": "\r\n## cjs (commonjs)\r\n\r\n`commonjs` 是 Node 中的模块规范，通过 `require` 及 `exports` 进行导入导出 (进一步延伸的话，`module.exports` 属于 `commonjs2`)\r\n\r\n同时，webpack 也对 `cjs` 模块得以解析，因此 `cjs` 模块可以运行在 node 环境及 webpack 环境下的，但不能在浏览器中*直接*使用。但如果你写前端项目在 webpack 中，也可以理解为它在浏览器和 Node 都支持。\r\n\r\n比如，著名的全球下载量前十10的模块 [ms](https://npm.devtool.tech/ms) 只支持 `commonjs`，但并不影响它在前端项目中使用(通过webpack)，但是你想通过 cdn 的方式直接在浏览器中引入，估计就会出问题了\r\n\r\n``` js\r\n// sum.js\r\nexports.sum = (x, y) => x + y\r\n\r\n// index.js\r\nconst { sum } = require('./sum.js')\r\n```\r\n\r\n由于 `cjs` 为动态加载，可直接 `require` 一个变量\r\n\r\n``` js\r\nrequire(`./${a}`)\r\n```\r\n\r\n## esm (es module)\r\n\r\n`esm` 是 tc39 对于 js 模块的规范，**在 Node 及 浏览器中均会支持**，使用 `export/import` 进行模块导入导出\r\n\r\n``` js\r\n// sum.js\r\nexport const sum = (x, y) => x + y\r\n\r\n// index.js\r\nimport { sum } from './sum'\r\n```\r\n\r\n由于 `esm` 为静态导入，正因如此，可在编译器进行 **Tree Shaking**，减少 js 体积。tc39 为动态加载模块定义了 API: `import(module)` 。\r\n\r\nesm 是未来的趋势，目前一些 CDN 厂商，前端构建工具均致力于 cjs 模块向 esm 的转化，比如 `skypack`、 `snowpack`、`vite` 等。\r\n\r\n目前，在浏览器与 node.js 中均原生支持 esm。\r\n\r\n+ cjs 模块输出的是一个值的拷贝，esm 输出的是值的引用\r\n+ cjs 模块是运行时加载，esm 是编译时加载\r\n\r\n示例: [array-uniq](https://cdn.jsdelivr.net/npm/array-uniq/index.js)\r\n\r\n## umd\r\n\r\n一种兼容 `cjs` 与 `amd` 的模块，既可以在 node/webpack 环境中被 `require`，也可以在浏览器中直接用 CDN 被 `script.src` 引入\r\n\r\n``` js\r\n(function (root, factory) {\r\n  if (typeof define === 'function' && define.amd) {\r\n    // AMD\r\n    define(['jquery'], factory);\r\n  } else if (typeof exports === 'object') {\r\n    // CommonJS\r\n    module.exports = factory(require('jquery'));\r\n  } else {\r\n    // 全局变量\r\n    root.returnExports = factory(root.jQuery);\r\n  }\r\n}(this, function ($) {\r\n  // ...\r\n}));\r\n```\r\n\r\n示例: [react-table](https://cdn.jsdelivr.net/npm/react-table@7.7.0/dist/react-table.development.js), [antd](https://npm.devtool.tech/react-table)\r\n\r\n这三种模块方案大致如此，但是部分 npm package 也会同时打包出 commonjs/esm/umd 三种模块化格式，供不同需求的业务使用\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3OTg5MTA1NjY=",
    "number": 476,
    "title": "【Q468】前端开发中如何进行多主题配置",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU3OTg5MTg5MTg=",
    "number": 477,
    "title": "【Q469】HTML 中的 input 标签有哪些 type",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
        "name": "html"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc5MDQ0Mzk5Mg==",
      "body": "## button\r\n没有默认行为的按钮，上面显示 value 属性的值，默认为空。\r\n\r\n``` html\r\n<input  type=\"button\" name=\"button\" />\r\n```\r\n\r\n## checkbox\r\n复选框，可设为选中或未选中。\r\n\r\n``` html\r\n<input  type=\"checkbox\" name=\"checkbox\"/>\r\n```\r\n\r\n## color\r\n用于指定颜色的控件；在支持的浏览器中，激活时会打开取色器。\r\n\r\n``` html\r\n<input  type=\"color\" name=\"color\"/>\r\n```\r\n\r\n## date\r\n输入日期的控件（年、月、日，不包括时间）。在支持的浏览器激活时打开日期选择器或年月日的数字滚轮。\r\n\r\n``` html\r\n<input  type=\"date\" name=\"date\"/>\r\n```\r\n\r\n## datetime-local\r\n输入日期和时间的控件，不包括时区。在支持的浏览器激活时打开日期选择器或年月日的数字滚轮。\r\n\r\n``` html\r\n<input  type=\"datetime-local\" name=\"datetime-local\"/>\r\n```\r\n\r\n## email\r\n编辑邮箱地址的区域。类似 text 输入，但在支持的浏览器和带有动态键盘的设备上会有确认参数和相应的键盘。\r\n\r\n``` html\r\n<input type=\"email\" name=\"email\"/>\r\n```\r\n\r\n## file\r\n让用户选择文件的控件。使用accept属性规定控件能选择的文件类型。\r\n\r\n``` html\r\n<input type=\"file\" accept=\"image/*, text/*\" name=\"file\"/>\r\n```\r\n\r\n## hidden\r\n不显示的控件，其值仍会提交到服务器。举个例子，右边就是一个隐形的控件。\r\n\r\n``` html\r\n\r\n```\r\n\r\n## image\r\n带图像的 submit 按钮。显示的图像由 src 属性规定。如果 src 缺失，alt 属性就会显示。\r\n\r\n``` html\r\n<input type=\"image\" name=\"image\" src=\"\" alt=\"image input\"/>\r\n```\r\n\r\n## month\r\n输入年和月的控件，没有时区。\r\n\r\n``` html\r\n<input type=\"month\" name=\"month\"/>\r\n```\r\n\r\n## number\r\n用于输入数字的控件。如果支持的话，会显示滚动按钮并提供缺省验证（即只能输入数字）。拥有动态键盘的设备上会显示数字键盘。\r\n\r\n``` html\r\n<input  type=\"number\" name=\"number\"/>\r\n```\r\n\r\n## password\r\n单行的文本区域，其值会被遮盖。如果站点不安全，会警告用户。\r\n\r\n``` html\r\n<input  type=\"password\" name=\"password\"/>\r\n```\r\n\r\n## radio\r\n单选按钮，允许在多个拥有相同 name 值的选项中选中其中一个。\r\n\r\n``` html\r\n<input type=\"radio\" name=\"radio\"/>\r\n```\r\n\r\n## range\r\n此控件用于输入不需要精确的数字。控件是一个范围组件，默认值为正中间的值。同时使用htmlattrdefmin   和 htmlattrdefmax来规定值的范围。\r\n\r\n``` html\r\n<input type=\"range\" name=\"range\" min=\"0\" max=\"25\"/>\r\n```\r\n\r\n## reset\r\n此按钮将表单的所有内容重置为默认值。不推荐。\r\n\r\n``` html\r\n<input  type=\"reset\" name=\"reset\"/>\r\n```\r\n\r\n## search\r\n用于搜索字符串的单行文字区域。输入文本中的换行会被自动去除。在支持的浏览器中可能有一个删除按钮，用于清除整个区域。拥有动态键盘的设备上的回车图标会变成搜索图标。\r\n\r\n``` html\r\n<input  type=\"search\" name=\"search\"/>\r\n```\r\n\r\n## submit\r\n用于提交表单的按钮。\r\n\r\n``` html\r\n<input type=\"submit\" name=\"submit\"/>\r\n```\r\n\r\n## tel\r\n用于输入电话号码的控件。拥有动态键盘的设备上会显示电话数字键盘。\r\n\r\n``` html\r\n<input  type=\"tel\" name=\"tel\"/>\r\n```\r\n\r\n## text\r\n默认值。单行的文本区域，输入中的换行会被自动去除。\r\n\r\n``` html\r\n<input type=\"text\" name=\"text\"/>\r\n```\r\n\r\n## time\r\n用于输入时间的控件，不包括时区。\r\n\r\n``` html\r\n<input  type=\"time\" name=\"time\"/>\r\n```\r\n\r\n## url\r\n用于输入 URL 的控件。类似 text 输入，但有验证参数，在支持动态键盘的设备上有相应的键盘。\r\n\r\n``` html\r\n<input type=\"url\" name=\"url\"/>\r\n```\r\n\r\n## week\r\n用于输入以年和周数组成的日期，不带时区。\r\n\r\n``` html\r\n<input type=\"week\" name=\"week\"/>\r\n```\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3OTkyNzA4NjQ=",
    "number": 478,
    "title": "【Q470】什么是 Data URL",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
        "name": "html"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc3MjQ5ODI0MA==",
      "body": "Data URL是将图片转换为base64直接嵌入到了网页中，使用`<img src=\"data:[MIME type];base64\"/>`这种方式引用图片，不需要再发请求获取图片。\r\n使用Data URL也有一些缺点：\r\n- base64编码后的图片会比原来的体积大三分之一左右。\r\n- Data URL形式的图片不会缓存下来，每次访问页面都要被下载一次。可以将Data URL写入到CSS文件中随着CSS被缓存下来。",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "buzuosheng",
        "url": "https://github.com/buzuosheng"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4MDI4NDg2OTA=",
    "number": 479,
    "title": "【Q471】如何自定义滚动条的样式",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc3NDU4ODQwMA==",
      "body": "滚动条相关样式都是伪元素，以 `scrollbar` 打头，有以下伪元素，从 `-webkit` 中可见兼容性一般，不过无所谓，现在 Chrome 浏览器占大头\r\n\r\n+   `::-webkit-scrollbar` — 整个滚动条.\r\n+   `::-webkit-scrollbar-button` — 滚动条上的按钮 (上下箭头).\r\n+   `::-webkit-scrollbar-thumb` — 滚动条上的滚动滑块.\r\n+   `::-webkit-scrollbar-track` — 滚动条轨道.\r\n+   `::-webkit-scrollbar-track-piece` — 滚动条没有滑块的轨道部分.\r\n+   `::-webkit-scrollbar-corner` — 当同时有垂直滚动条和水平滚动条时交汇的部分.\r\n+   `::-webkit-resizer` — 某些元素的corner部分的部分样式(例:textarea的可拖动按钮).\r\n\r\n但其实最常用的是以下几个伪元素：**滚动条、滑块、轨道**，如下滚动条设置成功\r\n\r\n``` css\r\n::-webkit-scrollbar {\r\n    width: 6px;\r\n    height: 6px\r\n}\r\n\r\n::-webkit-scrollbar-track {\r\n    border-radius: 3px;\r\n    background: rgba(0,0,0);\r\n    box-shadow: inset 0 0 5px rgba(0,0,0,.08)\r\n}\r\n\r\n::-webkit-scrollbar-thumb {\r\n    border-radius: 3px;\r\n    background: rgba(0,0,1);\r\n    box-shadow: inset 0 0 10px rgba(0,0,0,.2)\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4MDMyMjI5OTY=",
    "number": 480,
    "title": "【Q472】什么是 HTML 的实体编码 (HTML Entity Encode)",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
        "name": "html"
      },
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc4Mjg2MzY4MA==",
      "body": "- 不可分的空格:＆nbsp;\r\n- <(小于符号):＆lt;\r\n- (大于符号):＆gt;\r\n- ＆(与符号):＆amp;\r\n- ″(双引号):＆quot;\r\n- '(单引号):'＆apos;\r\n- ……",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "kglive",
        "url": "https://github.com/kglive"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4MDM0OTcyMzE=",
    "number": 481,
    "title": "【Q473】关于模块化，什么是 amd 和 umd",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc3NTY3OTUxOA==",
      "body": "`amd` 是一种浏览器中的模块格式，关键字为 `define`，`cjs` 是一种 Node 中的模块格式，也是广为人所熟悉的 `require/exports`。\r\n\r\n而 `umd` 是 `amd` 与 `cjs` 两种格式的兼容。既可以跑在浏览器，又可以跑在 Node 中\r\n\r\n**amd**\r\n\r\n``` js\r\ndefine(['jquery', 'underscore'], function ($, _) {});\r\n```\r\n\r\n**umd**\r\n\r\n``` js\r\n(function (root, factory) {\r\n  if (typeof define === 'function' && define.amd) {\r\n    // AMD\r\n    define(['jquery'], factory);\r\n  } else if (typeof exports === 'object') {\r\n    // CommonJS\r\n    module.exports = factory(require('jquery'));\r\n  } else {\r\n    // 全局变量\r\n    root.returnExports = factory(root.jQuery);\r\n  }\r\n}(this, function ($) {\r\n  // ...\r\n}));\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4MDM2NTk2MjU=",
    "number": 482,
    "title": "【Q474】简单介绍以下浏览器中的 module",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs401jHW",
      "body": "`<script type=\"module\">`\r\n\r\n- 模块自动使用严格模式\r\n- 需要使用 defer 属性，模块会自动延迟加载",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "haotie1990",
        "url": "https://github.com/haotie1990"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4MDQxODQ3NTE=",
    "number": 483,
    "title": "【Q475】什么是 commonjs2 ",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU4MDcxNjEwNjM=",
    "number": 484,
    "title": "【Q476】textarea 如何禁止拉伸",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
        "name": "html"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc3ODE0MTY5MQ==",
      "body": "使用 CSS 样式可以避免拉伸\r\n\r\n``` css\r\ntextarea {\r\n  resize: none;\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4MDc3NTkyMzc=",
    "number": 485,
    "title": "【Q477】在 Canvas 中如何处理跨域的图片",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
        "name": "html"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDgwOTg3OTQ1OQ==",
      "body": "img.setAttribute(\"crossOrigin\", \"anonymous\");",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "hhhpw",
        "url": "https://github.com/hhhpw"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4MTE2MDMyNTA=",
    "number": 486,
    "title": "【Q478】如何实现容器中子元素三个三列布局，子元素两个则两列布局",
    "body": "及容器中有三个及以上元素，则三列布局\r\n容器只有两个元素，两列布局平分\r\n容器只有一个元素，一列布局全占",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU4MTQwMzgwMzA=",
    "number": 487,
    "title": "【Q479】前端上传文件时如何读取文件内容",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc4MzgzMTgyNw==",
      "body": "``` html\r\n<input type=\"file\" id=\"input\" onchange=\"handleFiles(this.files)\">\r\n```\r\n\r\n在浏览器中，通过 `input[type=file]` 来点击上传文件，此时监听 `onChange` 事件，可以获取到 `File` 对象，其中从中可以读取文件内容\r\n\r\n而读取文件内容，需要转化 `File/Blob` 到 `Text`，一般使用以下两种方案\r\n\r\n## FileReader API\r\n\r\n这是最常用处理上传文件的 API，但是却繁琐冗余难记，每次使用基本上都要查文档！\r\n\r\n`FileReader API` 用以读取 File/Blob 内容，正因为繁琐难记，以下实现一个 `readBlob` 函数读取内容。\r\n\r\n``` js\r\nfunction readBlob (blob) {\r\n  return new Promise(resolve => {\r\n    const reader = new FileReader()\r\n    reader.onload = function (e) {\r\n      resolve(e.target.result)  \r\n    }\r\n    reader.readAsText(blob)\r\n  })\r\n}\r\n```\r\n\r\n## Response API\r\n\r\n而是用 `Response API` 只需要一行内容\r\n\r\n``` js\r\nconst readBlob = (blob) => new Response(blob).text()\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4MTUyMTkyODk=",
    "number": 488,
    "title": "【Q480】你最喜欢的三个 js 库是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      },
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc4NDkxNDY0Ng==",
      "body": "\r\n这三个库是我喜欢也用的相当多的库，如果是自己的项目基本上都用了:\r\n\r\n1. [next](https://npm.devtool.tech/next)\r\n2. [swr](https://npm.devtool.tech/swr)\r\n3. [graphql](https://npm.devtool.tech/graphql)\r\n\r\n此外，[npm.devtool](https://npm.devtool.tech/) 中收集了最流行的 1000 个库，可以去瞧瞧\r\n\r\n## next\r\n\r\nVercel 出品\r\n\r\n> The React Framework for Production.\r\n\r\n好用！一点基于它的 SSR，一点基于它的开箱即用。\r\n\r\n1. SSR，如果你想提高你的前端水平，那就使用 Next 做一个同构的项目吧，其中遇到的问题比纯客户端渲染更有挑战力，更加棘手。严格来说这是一个需要部署在服务器上的服务器项目，你需要对服务器端开始了解，可能遇到内存爆掉，需要记录服务器日志，需要 Metric 监控内存、CPU 等，需要报警等。而这些在平常的前端项目接触不到。同构要求一份代码既能在 Node 环境中运行，又能在浏览器中运行，其中也会遇到一些问题，比如一个库客户端可以加载服务端不行，或者相反。或者一个疏忽让客户端打包了一个特别大的包(其实仅仅服务端需要)，造成页面加载过慢。\r\n1. 开箱即用，内置路由、ts支持、webpack 配置等等。即使你想扩展你的 webpack 配置，仅仅需要在 `next.config.js` 添加几行代码。而不像 `create-react-app` 基本上都要 `eject`，从而需要管理许多配置\r\n\r\n## swr\r\n\r\n``` js\r\nconst { data: projects, error } = useSWR('/api/projects')\r\n```\r\n\r\n或者一个可选的库: `React-Query`。\r\n\r\n同样也是 Vercel 出品\r\n\r\n最大的好处就是通过 `hooks` 形式加载数据，简单方便。与 `React-Query` 相比，个人感觉:\r\n\r\n1. `react-query` 对于 `mutation` 可使用 hooks，支持更多选项 (如 keepPreviousData)，功能更多，更适合 API 复杂的项目\r\n1. `swr` 相对轻量，可随处使用，不像 react-query 需要在父组件设置 Provider 等，只有读请求的小项目可以用 swr\r\n\r\n## graphql\r\n\r\nGraphQL，按需请求数据。可以简单对接数据库、第三方服务，并扔到客户端，由于面向字段(field)，所以更容易针对字段进行缓存。\r\n\r\n同时也更有利于客户端，`graphql` 的强类型很容易通过 AST 转化为 types，因此客户端请求数据时的 ts 可以根据 query 自动生成。\r\n\r\n现在，Github 最新的 API 也是 graphql 形式的",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4MjAxMjgwODg=",
    "number": 489,
    "title": "【Q481】网站设置字体时，如何设置优先使用系统默认字体",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc5MjY4NzQwMg==",
      "body": "``` css\r\nfont-family: system-ui;\r\n```\r\n\r\n`system-ui` 将会自动选取系统默认字体作为字体，如 [`bootstrap` 的样式规则](https://github.com/twbs/bootstrap/blob/main/scss/_variables.scss#L419)\r\n\r\n``` scss\r\n$font-family-sans-serif: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", \"Liberation Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\" !default;\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4MjIxOTkzNjU=",
    "number": 490,
    "title": "【Q482】现代化前端框架中如何进行调试",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU4MjQyNTE2MTk=",
    "number": 491,
    "title": "【Q483】如何使用 redis 计算 wordcount，并计算出现频率最高的词",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjY2OTk3OTM5",
        "name": "redis"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU4MjUyMjQ2NjE=",
    "number": 492,
    "title": "【Q484】express 中间件的原理是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU4MjU2ODY0OTE=",
    "number": 493,
    "title": "【Q485】写 CSS 时如何避免命名样式冲突",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDc5Mzg4MTM3MA==",
      "body": "\r\n## 1. BEM 式: `.home-page .home-page-btn`\r\n\r\n``` css\r\n.home-page {\r\n  .home-page-btn {}\r\n}\r\n```\r\n\r\nBEM 有一个缺点，就是有些太长，可适当简化，只包裹该页面组件的根类名，但有可能增加样式冲突的风险\r\n\r\n``` css\r\n.home-page {\r\n  .btn {}\r\n}\r\n```\r\n\r\n## 2. CSS Scoped\r\n\r\n`scoped css` 会对当前组件(scope)下所有元素生成唯一的属性或类名，对所有 CSS 规则将携带唯一属性实现作用域的命名保护\r\n\r\n``` css\r\n// 手动写\r\n.btn {}\r\n\r\n// 编译后\r\n.btn .jsx-1287234 {}\r\n\r\n```\r\n\r\n![css scoped demo](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c0676b0f8cc4f40b925dcb983778dd8~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n## 3. CSS Module\r\n\r\n+ [css-modules repo](https://github.com/css-modules/css-modules)\r\n+ [css-modules demo](https://css-modules.github.io/webpack-demo/)\r\n\r\n`module css` 会对类名进行 hash 化\r\n\r\n![css modules demo](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/072649f56f8f4f80afa226879b94a6bf~tplv-k3u1fbpfcp-watermark.image)\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4MjkxMzkyODc=",
    "number": 495,
    "title": "【Q486】什么是前端工程化",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs401huM",
      "body": "前端工程化的主要目标就是解放生产力、提高生产效率。通过制定一系列的规范，借助工具和框架解决前端开发以及前后端协作过程中的痛点和难度问题。\r\n\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "haotie1990",
        "url": "https://github.com/haotie1990"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4MzcxMDI1NjE=",
    "number": 496,
    "title": "【Q487】OAuth 2.0 的原理是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU4MzcxMDI3MDc=",
    "number": 497,
    "title": "【Q488】JWT 的原理是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      },
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU4Mzc4MzI3NDc=",
    "number": 498,
    "title": "【Q489】如何实现一个函数 lodash.merge",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDgwNDE1MTc0Ng==",
      "body": "`Array.prototype.flatMap` 已经是 EcmaScript 的标准，看一个例子，它的输出是多少？\r\n\r\n``` js\r\n[1, 2, [3], 4].flatMap(x => x + 1)\r\n//=> [2, 3, '31', 5]\r\n```\r\n\r\n很可惜，不是 `[2, 3, 4, 5]`，原因在于 `flatMap` 实际上是先 `map` 再 `flat`，实现如下\r\n\r\n``` js\r\nArray.prototype.flatMap = function (mapper) {\r\n  return this.map(mapper).flat()\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4NDA0MTc1MjI=",
    "number": 499,
    "title": "【Q490】如何实现一个 promise.any",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs44MZer",
      "body": "Promise.any 的行为跟 Promise.all 刚好相反\r\n```javascript\r\nPromise.any = (promiseArray) => {\r\n  return new Promise((resolve, reject) => {\r\n    const _promiseArray = Array.from(promiseArray)\r\n    const length = _promiseArray.length\r\n    const rejectedArray = []\r\n    _promiseArray.forEach(item => {\r\n      Promise.resolve(item).then(val => {\r\n        resolve(val)\r\n      }, reason => {\r\n        rejectedArray.push(reason)\r\n        if (rejectedArray.length === length) {\r\n          reject(new AggregateError(rejectedArray))\r\n        }\r\n      })\r\n    })\r\n  })\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "hwb2017",
        "url": "https://github.com/hwb2017"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4NDE0OTkzODA=",
    "number": 500,
    "title": "【Q491】如何实现一个 Promise.all",
    "body": "``` js\r\nawait Promise.all([1, 2, 3])\r\n//-> [1, 2, 3]\r\n\r\nawait Promise.all([1, Promise.resolve(2), 3])\r\n//-> [1, 2, 3]\r\n\r\nawait Promise.all([1, Promise.resolve(2)])\r\n//-> [1, 2]\r\n\r\nawait Promise.all([1, Promise.reject(2)])\r\n//-> Throw Error: 2\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDgwNzkwMjE4Ng==",
      "body": "> 代码可在线调试: [如何实现一个 Promise.all - codepen](https://codepen.io/shanyue/pen/JjWEqBL?editors=0012)\r\n\r\n有一次头条面试，一道手写题目是：如何手写实现 `promise.all`。\r\n\r\n我从来没有想过要手写实现 promise.all 函数，稍微一想，大概就是维护一个数组，把所有 promise 给 resolve 了之后都扔进去，这有啥子好问的。没想到，一上手还稍微有点棘手。\r\n\r\n先来看一个示例吧:\r\n\r\n``` js\r\nawait Promise.all([1, Promise.resolve(2)])\r\n//-> [1, 2]\r\n\r\nawait Promise.all([1, Promise.reject(2)])\r\n//-> Throw Error: 2\r\n```\r\n\r\n1. 传入一个 Iterable，但大部分情况下是数组，以下以数组代替\r\n1. 传入一个数组，其中可包含 Promise，也可包含普通数据\r\n1. 数组中 Prmise 并行执行\r\n1. 但凡有一个 Promise 被 Reject 掉，Promise.all 失败\r\n1. 保持输出数组位置与输入数组一致\r\n1. 所有数据 resolve 之后，返回结果\r\n\r\n``` js\r\nfunction pAll (_promises) {\r\n  return new Promise((resolve, reject) => {\r\n    // Iterable => Array\r\n    const promises = Array.from(_promises)\r\n    // 结果用一个数组维护\r\n    const r = []\r\n    const len = promises.length\r\n    let count = 0\r\n    for (let i = 0; i < len; i++) {\r\n      // Promise.resolve 确保把所有数据都转化为 Promise\r\n      Promise.resolve(promises[i]).then(o => { \r\n        // 因为 promise 是异步的，保持数组一一对应\r\n        r[i] = o;\r\n\r\n        // 如果数组中所有 promise 都完成，则返回结果数组\r\n        if (++count === len) {\r\n          resolve(r)\r\n        }\r\n        // 当发生异常时，直接 reject\r\n      }).catch(e => reject(e))\r\n    }\r\n  })\r\n}\r\n```\r\n\r\n为了测试，实现一个 sleep 函数\r\n\r\n``` js\r\nconst sleep = (seconds) => new Promise(resolve => setTimeout(() => resolve(seconds), seconds))\r\n```\r\n\r\n以下示例进行测试，没有问题\r\n\r\n``` js\r\npAll([1, 2, 3]).then(o => console.log(o))\r\npAll([\r\n  sleep(3000),\r\n  sleep(2000),\r\n  sleep(1000)\r\n]).then(o => console.log(o))\r\npAll([\r\n  sleep(3000),\r\n  sleep(2000),\r\n  sleep(1000),\r\n  Promise.reject(10000)\r\n]).then(o => console.log(o)).catch(e => console.log(e, '<- Error'))\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4NDIwNDM2MjY=",
    "number": 501,
    "title": "【Q492】CSS 如何设置方格背景",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg3NDE1NzgzMg==",
      "body": "``` css\r\nbackground: linear-gradient(90deg, rgba(200, 200, 200, .1) 3%, transparent 0), linear-gradient(rgba(200, 200, 200, .1) 3%, transparent 0);\r\nbackground-size: 20px 20px;\r\n```\r\n![image](https://user-images.githubusercontent.com/38256126/124486859-9a88c700-dde0-11eb-810f-842cd9b212d4.png)\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "mrrs878",
        "url": "https://github.com/mrrs878"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4NDI4ODI4OTI=",
    "number": 502,
    "title": "【Q493】如何取消请求的发送",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
        "name": "html"
      },
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDgxNDY4Njg4Mw==",
      "body": "根据发送网络请求的API不同，取消方法不同\r\n- xhr\r\n- fetch \r\n- axios \r\n\r\n如果使用`XMLHttpRequest`发送请求可以使用`XMLHttpRequest.abort()`\r\n\r\n如果使用`fetch`发送请求可以使用`AbortController`\r\n```\r\nconst controller = new AbortController();\r\nconst signal = controller.signal;\r\nfetch('https://somewhere', { signal })\r\ncontroller.abort()\r\n```\r\n\r\n如果使用`axios`，取消原理同fetch\r\n```\r\nvar CancelToken = axios.CancelToken;\r\nvar source = CancelToken.source();\r\n\r\naxios.get('/https://somewhere', {\r\n  cancelToken: source.token\r\n}\r\n\r\nsource.cancel()\r\n```\r\n\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "evle",
        "url": "https://github.com/evle"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4NDQ2MDg3MTA=",
    "number": 503,
    "title": "【Q494】如何过滤数组中的 falsy value",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDgxMDI5NTYwMQ==",
      "body": "falsy value 包含：`false`, `null`, `0`, `\"\"`, `undefined`, `NaN `\r\n\r\n使用以下即可过滤\r\n\r\n``` js\r\nfunction compact (array) {\r\n  return array.filter(Boolean)\r\n}\r\n```",
      "star": {
        "totalCount": 1
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4NDk2NjM4OTE=",
    "number": 504,
    "title": "【Q495】如何把一个数组随机打乱",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDgxMjg2OTk5MA==",
      "body": "使用原生实现，Math.rondom() - 0.5 有时大于0，有时小于0会达成这样的效果\r\n\r\n``` js\r\n[1, 2, 3, 4].sort((x, y) => Math.random() - 0.5)\r\n```\r\n\r\n借用 `lodash` 可更方便\r\n\r\n``` js\r\n_.shuffle([1, 2, 3, 4])\r\n//-> [3, 2, 4, 1]\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4NTc3MjYwMjI=",
    "number": 505,
    "title": "【Q496】如何更好地给元素设置 z-index",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU4NTc5MDUyOTc=",
    "number": 506,
    "title": "【Q497】React.setState 是同步还是异步的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDgyNzY1NDk0Mw==",
      "body": "setState并不能保证是同步的，在生命周期函数和合成事件中是异步的，在原生事件和setTimeout中是同步的。",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "buzuosheng",
        "url": "https://github.com/buzuosheng"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4NjA4MTg4NDE=",
    "number": 507,
    "title": "【Q498】什么是服务器渲染 (SSR)",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      },
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDgyNzUzODkzMw==",
      "body": "服务端渲染SSR：在服务端将请求的所有资源生成HTML，客户端收到后可以直接渲染。",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "buzuosheng",
        "url": "https://github.com/buzuosheng"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4NjA4MjkzMTM=",
    "number": 508,
    "title": "【Q499】在 React 中如何实现代码分割 (code splitting)",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs401f8G",
      "body": "[https://zh-hans.reactjs.org/docs/code-splitting.html](https://zh-hans.reactjs.org/docs/code-splitting.html)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "haotie1990",
        "url": "https://github.com/haotie1990"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4NjIzODMwODY=",
    "number": 510,
    "title": "【Q500】在 React 中如何做好性能优化",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDgyNzYwODA1NQ==",
      "body": "- 代码分割\r\n- React.memo()、shouldComponentUpdate()等防止不必要的渲染\r\n- Fragments避免额外标记\r\n- 错误边界避免组件在出错时破坏整个应用",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "buzuosheng",
        "url": "https://github.com/buzuosheng"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4NjIzODkxOTk=",
    "number": 511,
    "title": "【Q501】在 React 中发现状态更新时卡顿，此时应该如何定位及优化",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU4NjI1MjMzODE=",
    "number": 512,
    "title": "【Q502】当多次重复点击按钮时，以下三个 Heading 是如何渲染的",
    "body": "``` js\r\nimport React, { memo, useMemo, useState } from \"react\";\r\n\r\nconst Heading = memo(({ style, title }) => {\r\n  console.log(\"Rendered:\", title);\r\n\r\n  return <h1 style={style}>{title}</h1>;\r\n});\r\n\r\nexport default function App() {\r\n  const [count, setCount] = useState(0);\r\n\r\n  const normalStyle = {\r\n    backgroundColor: \"teal\",\r\n    color: \"white\",\r\n  };\r\n\r\n  const memoizedStyle = useMemo(() => {\r\n    return {\r\n      backgroundColor: \"red\",\r\n      color: \"white\",\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <>\r\n      <button\r\n        onClick={() => {\r\n          setCount(count + 1);\r\n        }}\r\n      >\r\n        Increment {count}\r\n      </button>\r\n      <Heading style={memoizedStyle} title=\"Memoized\" />\r\n      <Heading style={normalStyle} title=\"Normal\" />\r\n      <Heading title=\"React.memo Normal\" />\r\n    </>\r\n  );\r\n}\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDgyNzUzNjM0OQ==",
      "body": "\"Memoized\"只在第一次渲染时打印一次，后续点击不刷新。\r\n\"Normal\"会在每次渲染时打印。\r\n\"React.memo Normal”只会在第一次渲染时打印一次。\r\n\r\n使用`useMemo`时，依赖数组为null，这意味着只会在首次渲染时，对memoizedStyle进行一次计算，后续不再计算。\r\n在渲染`<Heading />组件时，React.memo会先判断前后状态\r\n``` js\r\nmemoizedStyle === memoizedStyle  //true\r\n```\r\n由于状态始终是一个对象，自身始终是与自身相等的，所以不会导致重新渲染。\r\n\r\n没有使用`useMemo`时，每次点击，对`<Heading />`组件传入属性，React.memo判断\r\n``` js\r\n {\r\n    backgroundColor: \"teal\",\r\n    color: \"white\",\r\n  } ===  {\r\n    backgroundColor: \"teal\",\r\n    color: \"white\",\r\n  }  // false\r\n```\r\n每次都会传入一个新的对象，由于React.memo对prop进行浅比较，两个对象总是不相等的。\r\n如果需要进行深比较，可以对React.memo传入一个深比较函数作为第二个参数。\r\n\r\n\"React.memo Normal”的参数是字符串，相比对象的比较简单了很多，所以不会导致重新渲染。",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "buzuosheng",
        "url": "https://github.com/buzuosheng"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4NzM1Njk2NTE=",
    "number": 513,
    "title": "【Q503】Core Web Vitals 是什么，它有哪些指标",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg0ODM4Mjk0NQ==",
      "body": "> 见文档 [Web Vitals](https://web.dev/vitals/)\r\n\r\n+ LCP: Largest Content Paint\r\n+ FID: Firtst Input Delay\r\n+ CLS: Cumulative Layout Shift\r\n\r\n|     | Good    | Needs improvement | Poor   |\r\n|-----|---------|-------------------|--------|\r\n| LCP | <=2.5s  | <=4s              | >4s    |\r\n| FID | <=100ms | <=300ms           | >300ms |\r\n| CLS | <=0.1   | <=0.25            | >0.25  |\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4NzU5NDA0OTQ=",
    "number": 514,
    "title": "【Q504】画一个 100x100 的方框，其中文字可以正常换行，文字过多超过方框显示滚动条",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs44NIwG",
      "body": "主要使用 word-wrap: break-word 或 break-all 和 overflow: scroll 实现\r\n\r\n[code pen 链接](https://codepen.io/hwb2017/pen/gOxabQG)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "hwb2017",
        "url": "https://github.com/hwb2017"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4NzcxMzQ5MzI=",
    "number": 515,
    "title": "【Q505】JS 中基础数据类型有哪些",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg0ODM4MjI2OQ==",
      "body": "七种，文档见 [基本数据类型 - MDN](https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive)\r\n\r\n+ number\r\n+ bigint: **这个常常会忽略，最新加入的**\r\n+ string\r\n+ undefined\r\n+ null\r\n+ symbol\r\n+ bool",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4ODM3MjIwODM=",
    "number": 518,
    "title": "【Q506】Grid 布局如何实现类似 flex: row-reverse",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU4ODY3MjcxMzI=",
    "number": 520,
    "title": "【Q507】如何创建一个数组大小为100，每个值都为0的数组",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg0MDYzOTY4Mg==",
      "body": "` \r\n const arr = new Array(100); \r\n arr.fill(0)\r\n `",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "janyin",
        "url": "https://github.com/janyin"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4OTMzNDY0NzQ=",
    "number": 521,
    "title": "【Q508】dependencies 与 devDependencies 有何区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg0MzIxMTA2OA==",
      "body": "**对于业务代码而讲，它俩区别不大**\r\n\r\n当进行业务开发时，严格区分 `dependencies` 与 `devDependencies` 并无必要，实际上，大部分业务对二者也并无严格区别。\r\n\r\n当打包时，依靠的是 `Webpack/Rollup` 对代码进行模块依赖分析，与该模块是否在 `dep/devDep` 并无关系，只要在 `node_modules` 上能够找到该 Package 即可。\r\n\r\n以至于在 CI 中 `npm i --production` 可加快包安装速度也无必要，因为在 CI 中仍需要 lint、test、build 等。\r\n\r\n**对于库 (Package) 开发而言，是有严格区分的**\r\n\r\n+ dependencies: 在生产环境中使用\r\n+ devDependencies: 在开发环境中使用，如 webpack/babel/eslint 等\r\n\r\n**当在项目中安装一个依赖的 Package 时，该依赖的 `dependencies` 也会安装到项目中，即被下载到 `node_modules` 目录中。但是 `devDependencies` 不会**\r\n\r\n因此当我们开发 Package 时，需要注意到我们所引用的 `dependencies` 会被我们的使用者一并下载，而 `devDependencies` 不会。\r\n\r\n一些 Package 宣称自己是 `zero dependencies`，一般就是指不依赖任何 `dependencies`，如 [highlight](https://github.com/highlightjs/highlight.js)\r\n\r\n> JavaScript syntax highlighter with language auto-detection and zero dependencies.",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4OTMzNTA5Mzc=",
    "number": 522,
    "title": "【Q509】如何确认你们项目是否依赖某一个依赖项",
    "body": "例: 你们项目中是否引用了 npm 库 [semver](https://npm.devtool.tech/semver)",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg0ODM4MTU2OQ==",
      "body": "``` bash\r\nyarn list | grep xxx\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4OTMzNTIzMTY=",
    "number": 523,
    "title": "【Q510】当你引入某一个依赖项时，你引入的是该依赖下的哪一个文件",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs40saaF",
      "body": "package.json中的main对应的文件",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "Asarua",
        "url": "https://github.com/Asarua"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4OTMzNTQyMzM=",
    "number": 524,
    "title": "【Q511】npm workspaces 解决了什么问题",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg0ODM4MjU2Ng==",
      "body": "多个包难以互相链接",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4OTM0MTY2NTI=",
    "number": 525,
    "title": "【Q512】如何检测并避免循环依赖",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs400o68",
      "body": "```js\r\nfunction isCircularReference(value) {\r\n  const isObject = value => Object.prototype.toString.call(value) === '[object Object]';\r\n  const isPrimitive = value => /Number|Boolean|String|Undefined|Null|Symbol/.test(Object.prototype.toString.call(value));\r\n  const memory = new WeakMap();\r\n  let isCycled = false;\r\n  const traverse = function(value) {\r\n    if (!isPrimitive(value)) {\r\n      if (memory.has(value)) {\r\n        isCycled = true;\r\n        return; \r\n      }\r\n      memory.set(value, true);\r\n      const keys = Object.keys(value);\r\n      for (const key of keys) {\r\n        traverse(value[key]);\r\n      }\r\n    }\r\n  }\r\n  traverse(value);\r\n  return isCycled;\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "haotie1990",
        "url": "https://github.com/haotie1990"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4OTQ5MzIzMDY=",
    "number": 526,
    "title": "【Q513】有没有使用过 async/await，他们的原理是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg0ODM4MTA0Mw==",
      "body": "原理: 一个 Generator 与一个自动执行器",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4OTQ5NTY3MjE=",
    "number": 527,
    "title": "【Q514】什么是闭包，闭包的应用有哪些地方",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg0NjM3NDA1Mw==",
      "body": "闭包是一个函数, 其可以记住并访问外部变量.\r\n\r\n在函数被创建时, 函数的隐藏属性 [[Environment]] 会记住函数被创建时的位置, 即当时的词法环境 Lexical Environment\r\n\r\n这样, 无论在哪里调用函数, 都会去到 [[Environment]] 所引用的词法环境\r\n\r\n当查找变量时, 先在词法环境内部查找, 当没有找到局部变量时, 前往当前词法环境所记录的外部词法环境查找\r\n\r\n我知道的闭包的应用: 封装私有变量和处理回调函数\r\n\r\n前端新人, 理解浅薄, 如果有错希望您指出\r\n\r\n学习来源为 [JavaScript.info/Closure](https://javascript.info/closure)",
      "star": {
        "totalCount": 0
      },
      "author": null
    }
  },
  {
    "id": "MDU6SXNzdWU4OTUwMzQ2NjU=",
    "number": 528,
    "title": "【Q515】关于事件循环，一道异步代码执行输出顺序问题",
    "body": "``` js\r\nsetTimeout(() => {\r\n  console.log('A')\r\n  Promise.resolve().then(() => {\r\n    console.log('B')\r\n  })\r\n}, 1000)\r\n\r\nPromise.resolve().then(() => {\r\n  console.log('C')\r\n})\r\n\r\nnew Promise((resolve) => {\r\n  console.log('D')\r\n  resolve('')\r\n}).then(() => {\r\n  console.log('E')\r\n})\r\n\r\nasync function sum (a, b) {\r\n  console.log('F')\r\n}\r\n\r\nasync function asyncSum(a, b) {\r\n  await Promise.resolve()\r\n  console.log('G')\r\n  return Promise.resolve(a + b)\r\n}\r\n\r\nsum(3, 4)\r\nasyncSum(3, 4)\r\nconsole.log('H')\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg1NDI5NjA5NA==",
      "body": "`D F H C E G A B`",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4OTgyMDUzMjk=",
    "number": 529,
    "title": "【Q516】HTML 标签有哪些行内元素",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
        "name": "html"
      },
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg0NjA3MjEyOA==",
      "body": "常见的标签有以下几种，可参考 [inline element](https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements)\r\n\r\n+ a\r\n+ img\r\n+ picture\r\n+ span\r\n+ input\r\n+ textarea\r\n+ select\r\n+ label",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4OTgyMjU1NDU=",
    "number": 530,
    "title": "【Q517】CSS如何设置一行超出显示省略号",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg0NzY4ODY5OQ==",
      "body": "``` css\r\noverflow: hidden;\r\ntext-overflow: ellipsis;\r\nwhite-space: nowrap;\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4OTgyMjYxNjk=",
    "number": 531,
    "title": "【Q518】CSS如何设置多行超出显示省略号",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg0NzY4NzQ3Ng==",
      "body": "使用 `-webkit-line-clamp` 来设置多行超出显示省略号\r\n\r\n``` css\r\noverflow: hidden;\r\ndisplay: -webkit-box;\r\n-webkit-box-orient: vertical;\r\n-webkit-line-clamp: 2;\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4OTg3MDgyMzQ=",
    "number": 532,
    "title": "【Q519】如何发布一个全局可执行命令的 npm package",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs40saQx",
      "body": "在package.json中增加bin，对应脚本，脚本文件头部\r\n#! usr/local/bin node\r\n\r\n\bemm，头部大概是这个，可能有拼写错误",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "Asarua",
        "url": "https://github.com/Asarua"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4OTg3MDk3NjM=",
    "number": 533,
    "title": "【Q520】如何为一个项目指定 node 版本号",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg0ODM3MTMwMw==",
      "body": "指定一个项目所需的 node 最小版本，这属于一个项目的质量工程。\r\n\r\n如果对于版本不匹配将会报错(yarn)或警告(npm)，那我们需要在 `package.json` 中的 `engines` 字段中指定 Node 版本号\r\n\r\n> 更多质量工程问题，见 [如何保障项目质量](https://github.com/shfshanyue/Daily-Question/issues/552)\r\n\r\n``` json\r\n{\r\n  \"engines\": {\r\n    \"node\": \">=14.0.0\"\r\n  }\r\n}\r\n```\r\n\r\n一个示例：\r\n\r\n**我在本地把项目所需要的 node 版本号改成 `>=16.0.0`，而本地的 node 版本号为 `v8.17.0`**\r\n\r\n此时，npm 将会发生警告\r\n\r\n``` bash\r\nnpm WARN EBADENGINE Unsupported engine { package: 'next-app@1.0.0',\r\nnpm WARN EBADENGINE   required: { node: '>=16.0.0' },\r\nnpm WARN EBADENGINE   current: { node: 'v8.17.0', npm: '7.14.0' } }\r\n```\r\n\r\n而 yarn 将会直接报错\r\n\r\n``` bash\r\nerror next-app@1.0.0: The engine \"node\" is incompatible with this module. Expected version \">=16.0.0\". Got \"8.17.0\"\r\n```\r\n\r\n而如果我们**项目中某些依赖所需要的 Node 版本号与项目运行时的 Node 版本号不匹配，也会报错(在yarn中)**，此时无法正常运行项目，可避免意外发生",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4OTg3MTExMTc=",
    "number": 534,
    "title": "【Q521】什么是 semver，~1.2.3 与 ^1.2.3 的版本号范围是多少",
    "body": "当你 `npm install` 时，你安装的是哪一种形式",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg0NjU5MjA3MA==",
      "body": "`semver`，`Semantic Versioning` 语义化版本的缩写，文档可见 <https://semver.org/>，它由 `[major, minor, patch]` 三部分组成，其中\r\n\r\n+ `major`: 当你发了一个含有 Breaking Change 的 API\r\n+ `minor`:  当你新增了一个向后兼容的功能时\r\n+ `patch`: 当你修复了一个向后兼容的 Bug 时\r\n\r\n\r\n假设你的版本库中含有一个函数\r\n\r\n``` js\r\n// 假设原函数\r\nexport const sum = (x: number, y: number): number => x + y\r\n\r\n// Patch Version，修复小 Bug\r\nexport const sum = (x: number, y: number): number => x + y\r\n\r\n// Minor Version，向后兼容\r\nexport const sum = (...rest: number[]): number => rest.reduce((s, x) => s + x, 0)\r\n\r\n// Marjor Version，出现 Breaking Change\r\nexport const sub = () => {}\r\n```\r\n\r\n对于 `~1.2.3` 而言，它的版本号范围是 `>=1.2.3  <1.3.0`\r\n\r\n对于 `^1.2.3` 而言，它的版本号范围是 `>=1.2.3  <2.0.0`\r\n\r\n当我们 `npm i` 时，默认的版本号是 `^`，可最大限度地在向后兼容与新特性之间做取舍，但是有些库有可能不遵循该规则，我们在项目时应当使用 `yarn.lock`/`package-lock.json` 锁定版本号。\r\n\r\n我们看看 `package-lock` 的工作流程。\r\n\r\n1. `npm i webpack`，此时下载最新 webpack 版本 `5.58.2`，在 `package.json` 中显示为 `webpack: ^5.58.2`，版本号范围是 `>=5.58.2 < 6.0.0`\r\n2. 在 `package-lock.json` 中全局搜索 `webpack`，发现 webpack 的版本是被锁定的，也是说它是确定的 `webpack: 5.58.2`\r\n3. 经过一个月后，webpack 最新版本为 `5.100.0`，但由于 `webpack` 版本在 `package-lock.json` 中锁死，每次上线时仍然下载 `5.58.2` 版本号\r\n4. 经过一年后，webpack 最新版本为 `6.0.0`，但由于 `webpack` 版本在 `package-lock.json` 中锁死，且 package.json 中 `webpack` 版本号为 `^5.58.2`，与 `package-lock.json` 中为一致的版本范围。每次上线时仍然下载 `5.58.2` 版本号\r\n5. 支线剧情：经过一年后，webpack 最新版本为 `6.0.0`，需要进行升级，此时手动改写 `package.json` 中 `webpack` 版本号为 `^6.0.0`，与 `package-lock.json` 中不是一致的版本范围。此时 `npm i` 将下载 `6.0.0` 最新版本号，并重写 `package-lock.json` 中锁定的版本号为 `6.0.0`",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4OTg3MTQ1Nzc=",
    "number": 535,
    "title": "【Q522】package.json 中 main/module/browser/exports 字段有何区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs44sGUJ",
      "body": "## main\r\n\r\n`main` 指 npm package 的入口文件，当我们对某个 package 进行导入时，实际上导入的是 `main` 字段所指向的文件。\r\n\r\n`main` 是 CommonJS 时代的产物，也是最古老且最常用的入口文件。\r\n\r\n``` js\r\n// package.json 内容\r\n{\r\n  name: 'midash',\r\n  main: './dist/index.js'\r\n}\r\n\r\n// 关于如何引用 package\r\nconst midash = require('midash')\r\n\r\n// 实际上是通过 main 字段来找到入口文件，等同于该引用\r\nconst midash = require('midash/dist/index.js')\r\n```\r\n\r\n## module\r\n\r\n随着 ESM 且打包工具的发展，许多 package 会打包 N 份模块化格式进行分发，如 `antd` 既支持 `ES`，也支持 `umd`，将会打包两份。\r\n\r\n![antd 分发了两种格式](https://cdn.jsdelivr.net/gh/shfshanyue/assets@master/src/antd.50lzknb7r000.png)\r\n\r\n如果使用 `import` 对该库进行导入，则首次寻找 `module` 字段引入，否则引入 `main` 字段。\r\n\r\n基于此，许多前端友好的库，都进行了以下分发操作:\r\n\r\n1. 对代码进行两份格式打包: `commonjs` 与 `es module`\r\n1. `module` 字段作为 `es module` 入口\r\n1. `main` 字段作为 `commonjs` 入口\r\n\r\n``` js\r\n{\r\n  name: 'midash',\r\n  main: './dist/index.js',\r\n  module: './dist/index.mjs'\r\n}\r\n\r\n// 以下两者等同\r\nimport midash from 'midash'\r\nimport midash from 'midash/dist/index.mjs'\r\n```\r\n\r\n如果你的代码只分发一份 `es module` 模块化方案，则直接置于 `main` 字段之中。\r\n\r\n## exports\r\n\r\n如果说以上两个是刀剑，那 `exports` 至少得是瑞士军刀。\r\n\r\n`exports` 可以更容易地控制子目录的访问路径，也被称为 `export map`。\r\n\r\n假设我们 Package 的目录如下所示:\r\n\r\n``` bash\r\n├── package.json\r\n├── index.js\r\n└── src\r\n    └── get.js\r\n```\r\n\r\n**不在 `exports` 字段中的模块，即使直接访问路径，也无法引用！**\r\n\r\n``` js\r\n// package.json\r\n{\r\n  name: 'midash',\r\n  main: './index.js',\r\n  exports: {\r\n    '.': './dist/index.js',\r\n    'get': './dist/get.js'\r\n  }\r\n}\r\n\r\n// 正常工作\r\nimport get from 'midash/get'\r\n\r\n// 无法正常工作，无法引入\r\nimport get from 'midash/dist/get'\r\n```\r\n\r\n`exports` 不仅可根据模块化方案不同选择不同的入口文件，还可以根据环境变量(`NODE_ENV`)、运行环境(`nodejs`/`browser`/`electron`) 导入不同的入口文件。\r\n\r\n``` js\r\n{\r\n  \"type\": \"module\",\r\n  \"exports\": {\r\n    \"electron\": {\r\n      \"node\": {\r\n        \"development\": {\r\n          \"module\": \"./index-electron-node-with-devtools.js\",\r\n          \"import\": \"./wrapper-electron-node-with-devtools.js\",\r\n          \"require\": \"./index-electron-node-with-devtools.cjs\"\r\n        },\r\n        \"production\": {\r\n          \"module\": \"./index-electron-node-optimized.js\",\r\n          \"import\": \"./wrapper-electron-node-optimized.js\",\r\n          \"require\": \"./index-electron-node-optimized.cjs\"\r\n        },\r\n        \"default\": \"./wrapper-electron-node-process-env.cjs\"\r\n      },\r\n      \"development\": \"./index-electron-with-devtools.js\",\r\n      \"production\": \"./index-electron-optimized.js\",\r\n      \"default\": \"./index-electron-optimized.js\"\r\n    },\r\n    \"node\": {\r\n      \"development\": {\r\n        \"module\": \"./index-node-with-devtools.js\",\r\n        \"import\": \"./wrapper-node-with-devtools.js\",\r\n        \"require\": \"./index-node-with-devtools.cjs\"\r\n      },\r\n      \"production\": {\r\n        \"module\": \"./index-node-optimized.js\",\r\n        \"import\": \"./wrapper-node-optimized.js\",\r\n        \"require\": \"./index-node-optimized.cjs\"\r\n      },\r\n      \"default\": \"./wrapper-node-process-env.cjs\"\r\n    },\r\n    \"development\": \"./index-with-devtools.js\",\r\n    \"production\": \"./index-optimized.js\",\r\n    \"default\": \"./index-optimized.js\"\r\n  }\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4OTg3MjExMzQ=",
    "number": 536,
    "title": "【Q523】npm publish 时 npm script 的生命周期",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg0ODM4MDcwNA==",
      "body": "+ prepublishOnly\r\n+ prepack\r\n+ prepare\r\n+ postpack\r\n+ publish\r\n+ postpublish",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4OTg3MjIzMzQ=",
    "number": 537,
    "title": "【Q524】前端项目每次 npm install 之后需要执行一些处理工作，应该怎么办",
    "body": "例如: husky",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg0ODM2NTYzNg==",
      "body": "使用 npm script 生命周期中的 `npm prepare`，他将会在发包 (publish) 之前以及装包 (install) 之后自动执行。\r\n\r\n如果指向在装包之后自动执行，可使用 `npm postinstall`\r\n\r\n例如:\r\n\r\n[husky](https://github.com/typicode/husky)\r\n\r\n``` json\r\n{\r\n  \"prepare\": \"npm run build & node packages/husky/lib/bin.js install\" \r\n}\r\n```\r\n\r\n[vue-cli](https://github.com/vuejs/vue-cli/blob/dev/package.json) 一些著名的仓库会使用 [patch-package](https://github.com/ds300/patch-package) 自动修复 node_modules 中依赖的问题\r\n\r\n``` json\r\n{\r\n  \"postinstall\": \"patch-package\"\r\n}\r\n```\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4OTkwMTQ2MjA=",
    "number": 538,
    "title": "【Q525】flex 布局中 order 有何作用",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg0NzY3NzM5MQ==",
      "body": "`order` 属性定义Flex布局中子元素的排列顺序，数值越小，排列越靠前，默认为0。\r\n\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4OTkwMTc4MzM=",
    "number": 539,
    "title": "【Q526】flex 布局中 align-content 与 align-items 有何区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg0NzY3NjM0MA==",
      "body": "> 示例代码见: [align-content 与 align-items](https://codepen.io/shanyue/pen/abJwoRp?editors=1100)\r\n\r\n+ `align-content` 作用于纵轴多行元素，一行元素不起作用\r\n+ `align-items` 作用于纵轴单行元素\r\n\r\n下图，上部分为 `align-content`，下部分为 `align-items`\r\n\r\n![image](https://user-images.githubusercontent.com/13389461/119467452-1ae6f180-bd78-11eb-9645-19ea9ee0a1e5.png)\r\n\r\n\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4OTkwNjI1NzU=",
    "number": 540,
    "title": "【Q527】解构赋值一个数组，a 取第一项默认值为 3，c取剩下的值组成数组",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg0ODM2NDU1Ng==",
      "body": "``` js\r\nconst list = [1, 2, 3, 4, 5]\r\nconst [a, ...c] = list\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4OTkwNjQ5Njk=",
    "number": 541,
    "title": "【Q528】解构赋值以下对象，他们的值是多少",
    "body": "---\r\n\r\n``` js\r\nconst {a: aa, b } = {a: 3, b: 4} \r\n```\r\n\r\n分别打印 `a`、`aa`、`b`，他们的值是多少\r\n\r\n---\r\n\r\n\r\n``` js\r\nfunction move({x = 0, y = 0} = {}) {\r\n  return [x, y];\r\n}\r\n\r\nfunction move({x, y} = { x: 0, y: 0 }) {\r\n  return [x, y];\r\n}\r\n```\r\n\r\n以下几个表达式返回的结果是什么\r\n\r\n``` js\r\nmove({x: 3, y: 8});\r\nmove({x: 3})\r\nmove({}); \r\nmove(); \r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg0ODM3MDgwMw==",
      "body": "``` js\r\nconst {a: aa, b } = {a: 3, b: 4} \r\n\r\n// 其中 a 报错、aa 为3, b 为 4\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4OTkwNjcyNTc=",
    "number": 542,
    "title": "【Q529】Map 与 WeakMap 有何区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg0ODM1NzQ4OA==",
      "body": "+ `Map`: 可使用任何数据类型作为 key，但因其在内部实现原理中需要维护两个数组，存储 key/value，因此垃圾回收机制无法回收\r\n+ `WeakMap`: 只能使用引用数据类型作为 key。弱引用，不在内部维护两个数组，可被垃圾回收，但因此无法被遍历！即没有与枚举相关的 API，如 `keys`、`values`、`entries` 等",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU4OTk4NDQ0ODY=",
    "number": 543,
    "title": "【Q530】HTML 中有哪些语义化标签",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
        "name": "html"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg0ODM0ODkxNg==",
      "body": "> 见文档 [HTML Elements - MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element)\r\n\r\n+ header\r\n+ footer\r\n+ main\r\n+ aside\r\n+ article\r\n+ section\r\n+ address\r\n+ summary/details\r\n+ menu\r\n+ h1/h2/h3/h4/h5/h6\r\n+ img\r\n+ p\r\n+ strong/italic",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MDAzMTQ2Nzg=",
    "number": 544,
    "title": "【Q531】子元素垂直居中，并且该正方形的长度/宽度为父容器宽度(width)一半的正方形",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg0NzU2Mzk1Ng==",
      "body": "> [垂直居中长度为父容器一半的子元素 - Codepen](https://codepen.io/shanyue/pen/GRWmaVw?editors=1100)\r\n\r\n``` html\r\n<div class=\"container\">\r\n  <div class=\"item\"></div>\r\n</div>\r\n```\r\n\r\n以前采用百分比撑高 `padding`，那这种方案已经过时，会挤压 Content 内容，无法在其中填充内容(需要绝对定位)。\r\n\r\n可使用最新的属性 `aspect-ratio`，即长宽比\r\n\r\n``` css\r\n.container {\r\n  display: grid;\r\n  place-items: center;\r\n}\r\n\r\n.item {\r\n  width: 50%;\r\n  aspect-ratio: 1/1;\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MDA1MjA4MTU=",
    "number": 545,
    "title": "【Q532】简述 css 中 position 的值",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg0NzY5OTE3Ng==",
      "body": "+ `static`: 默认值，无定位，`top`、`right`、`bottom`、`left` 不起任何作用\r\n+ `relative`: 相对定位\r\n+ `absolute`: 绝对定位，脱离文档流，上下左右以最近的定位父元素为参照系\r\n+ `fixed`: 脱离文档流，上下左右以浏览器视口为参照系\r\n+ `sticky`: `relative` 与 `fixed` 的结合体",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MDA1MzY3NjE=",
    "number": 546,
    "title": "【Q533】什么是 BFC",
    "body": "+ 它是如何生成的\r\n+ 它有什么作用及应用",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg0ODM1MDYyOA==",
      "body": "块级格式化上下文，`Block Formatting Context`",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MDA1Mzk5NTA=",
    "number": 547,
    "title": "【Q534】CSS 如何实现固定长宽比的元素",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg0ODM0NTk2NQ==",
      "body": "过去的解决方案是使用 `padding`。一个元素的 `padding` 如若设置为百分比，则代表的是以父元素宽度为基准，根据这个原理，可设置长宽比。但实际上意义有限，毕竟你把 padding 给占了，content 无任何区域。\r\n\r\n现代化的解决方案是使用长宽比的 CSS 属性: `aspect-ratio`",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MDA1NDYwMzQ=",
    "number": 548,
    "title": "【Q535】rem、em、vw、vh 的值各是什么意思",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg0ODMzNjI2Nw==",
      "body": "他们同属于 CSS Data Type 中的 `[length]`，见文档 [length - MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/length)\r\n\r\n+ `rem`: 根据根元素(即 `html`)的 `font-size`\r\n+ `em`: 根据**自身元素**的 `font-size`\r\n+ `vw`: viewport width\r\n+ `vh`: viewport height",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MDA1NDgwNzg=",
    "number": 549,
    "title": "【Q536】normalize.css 与 reset.css 又何区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg0NzcxODM2Nw==",
      "body": "[What is the difference between Normalize.css and Reset CSS?](https://stackoverflow.com/questions/6887336/what-is-the-difference-between-normalize-css-and-reset-css)\r\n\r\n+ [normalize.css](https://github.com/necolas/normalize.css/blob/master/normalize.css): 会保留有用的样式，比如 h1 的字体大小\r\n+ [reset.css](https://github.com/jgthms/minireset.css/blob/master/minireset.css): 把所有样式都重置，比如 h1、h2、h3 的字体大小都进行了重置，保持了无样式",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MDA1NjE5NjY=",
    "number": 550,
    "title": "【Q537】line-height 的值分别取 [2, 2em, 200%] 有什么区别?",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg0ODMzNDI4MQ==",
      "body": "> 代码见: [lineHeight - codepen](https://codepen.io/shanyue/pen/bGqRLxQ?editors=1100)\r\n\r\n`line-height` 是相对于元素自身的字体大小来取值，但同时会被继承。在实际工作中，取值 `2em` 或者 `200%` 有可能遇到未预测的内容。\r\n\r\n比如:\r\n\r\n+ 父元素: `fontSize: 18px; lineHeight: 1.5em(27px，150% 同理);` ，它的 lineHeight 计算下来为 27px，会被子元素继承\r\n+ 子元素: `fontSize: 30px`，子元素的 lineHeight 被继承为 27px，出现问题\r\n\r\n以下为演示代码，见: [lineHeight - codepen](https://codepen.io/shanyue/pen/bGqRLxQ?editors=1100)\r\n\r\n``` html\r\n<div class=\"box green\">\r\n  <h1>lineHeight: 1.5; 这是没有问题的框框</h1>\r\n  lineHeight: 1.5; 这是没有问题的框框\r\n  lineHeight: 1.5; 这是没有问题的框框\r\n</div>\r\n\r\n<div class=\"box red\">\r\n <h1>lineHeight: 1.5em; 这是有问题的框框</h1>\r\n  lineHeight: 1.5em; 这是有问题的框框\r\n  lineHeight: 1.5em; 这是有问题的框框\r\n</div>\r\n\r\n<div class=\"box orange\">\r\n <h1>lineHeight: 150%; 这是有问题的框框</h1>\r\n  lineHeight: 150%; 这是有问题的框框\r\n  lineHeight: 150%; 这是有问题的框框\r\n</div>\r\n```\r\n\r\n``` css\r\n.green {\r\n  line-height: 1.5;\r\n  border: solid limegreen;\r\n}\r\n\r\n.red {\r\n  line-height: 1.5em;\r\n  border: solid red;\r\n}\r\n\r\n.orange {\r\n  line-height: 150%;\r\n  border: solid orange;\r\n}\r\n\r\nh1 {\r\n  font-size: 30px;\r\n}\r\n\r\n.box {\r\n  width: 18em;\r\n  display: inline-block;\r\n  vertical-align: top;\r\n  font-size: 16px;\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MDE1Nzc0MzA=",
    "number": 552,
    "title": "【Q538】你是如何保障你们项目质量的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg0ODM3OTY2MQ==",
      "body": "+ lint\r\n+ type\r\n+ test\r\n+ code review\r\n+ git hooks\r\n+ CI\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MDE2OTcxODk=",
    "number": 553,
    "title": "【Q539】Javascript 数组中有那些方法可以改变自身，那些不可以",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg0OTQ5MTM5Nw==",
      "body": "不可改变自身的 Array API\r\n\r\n+ Array.prototype.map",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MDE3MjU4NTY=",
    "number": 554,
    "title": "【Q540】如何判断一个数组是否包含某个值",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg0OTQ5MDk2NA==",
      "body": "``` js\r\nArray.prototype.includes()\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MDE3MjYzNDU=",
    "number": 555,
    "title": "【Q541】如何判断字符串包含某个子串",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg0OTQ5MDc4Nw==",
      "body": "``` js\r\nString.prototype.includes()\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MDMwODE4Nzc=",
    "number": 556,
    "title": "【Q542】DOM 中如何阻止事件默认行为，如何判断事件否可阻止？",
    "body": "追问：\r\n\r\n1. 有哪些事件可阻止，哪些事件不可阻止?",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg1MTc0MDYwNQ==",
      "body": "+ `e.preventDefault()`: 取消事件\r\n+ `e.cancelable`: 事件是否可取消",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MDMwODg2MTc=",
    "number": 557,
    "title": "【Q543】什么是事件冒泡和事件捕获",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU5MDMwODkwNjg=",
    "number": 558,
    "title": "【Q544】什么是事件委托，e.currentTarget 与 e.target 有何区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg1MTEzMTMyNA==",
      "body": "![image](https://user-images.githubusercontent.com/13389461/120127876-31b39b00-c1f3-11eb-8297-ca155f3b4562.png)\r\n\r\n事件委托指当有大量子元素触发事件时，将事件监听器绑定在父元素进行监听，此时数百个事件监听器变为了一个监听器，提升了网页性能。\r\n\r\n另外，React 把所有事件委托在 Root Element，用以提升性能。",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MDMxMDQ2MDc=",
    "number": 559,
    "title": "【Q545】关于事件捕获和冒泡，以下代码输出多少",
    "body": "> 代码见: [事件捕获和冒泡 - Codepen](https://codepen.io/shanyue/pen/gOmxmqw?editors=1011)\r\n\r\n以下代码输出多少:\r\n\r\n``` html\r\n<div class=\"container\" id=\"container\">\r\n  <div class=\"item\" id=\"item\">\r\n    <div class=\"btn\" id=\"btn\">\r\n      Click me\r\n    </div>\r\n  </div>\r\n</div>\r\n```\r\n\r\n``` js\r\ndocument.addEventListener('click', (e) => {\r\n  console.log('Document click')\r\n}, {\r\n  capture: true\r\n})\r\n\r\ncontainer.addEventListener('click', (e) => {\r\n  console.log('Container click')\r\n  // e.stopPropagation()\r\n}, {\r\n  capture: true\r\n})\r\n\r\nitem.addEventListener('click', () => {\r\n  console.log('Item click')\r\n})\r\n\r\nbtn.addEventListener('click', () => {\r\n  console.log('Btn click')\r\n})\r\n\r\nbtn.addEventListener('click', () => {\r\n  console.log('Btn click When Capture')\r\n}, {\r\n  capture: true\r\n})\r\n\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg1MTczOTIwMw==",
      "body": "``` js\r\nDocument click\r\nContainer click\r\nBtn click When Capture\r\nBtn click\r\nItem click\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MDMxMTUxODU=",
    "number": 560,
    "title": "【Q546】浏览器中 cookie 有哪些字段",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg1MDc3MDYyMA==",
      "body": "+ Domain\r\n+ Path\r\n+ Expire/MaxAge\r\n+ HttpOnly\r\n+ Secure\r\n+ SameSite",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MDMxODM5Mjg=",
    "number": 561,
    "title": "【Q547】某元素的 fontSize: 2rem; lineHeight: 1.5em; 此时 lineHeight 为多少像素",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU5MDM1MDgzNjI=",
    "number": 562,
    "title": "【Q548】DOM 中 Element 与 Node 有何区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs40sZJ3",
      "body": "Element是dom元素，Node是节点，包含Element，还有其他节点",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "Asarua",
        "url": "https://github.com/Asarua"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MDQ0MzU2MTQ=",
    "number": 563,
    "title": "【Q549】如何判断某一个值是数组",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg1MTcyODYwMg==",
      "body": "完美实现一个月下载量超过一个亿的包: [isarray](https://npm.devtool.tech/isarray)\r\n\r\n``` js\r\nconst isArray = Array.isArray || list => ({}).toString.call(list) === '[object Array]'\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MDQ0NDg1MDI=",
    "number": 564,
    "title": "【Q550】简述 Object.defineProperty ",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg1MDA3MDI5Nw==",
      "body": "与直接为一个对象的属性赋值(`o.a = 3`)不同，`Object.defineProperty` 可更为精确，拥有更多选项地为对象属性赋值\r\n\r\n属性描述符拥有两种: 数据描述符与存取描述符\r\n\r\n## 数据描述符 (data descriptor)\r\n\r\n决定该属性值是否可写\r\n\r\n``` js\r\nconst o = {}\r\nObject.defineProperty(o, 'a', {\r\n  configurable: false,\r\n  enumerable: false,\r\n  writable: true,\r\n  value: 3,\r\n})\r\n```\r\n\r\n+ `configurable`: 是否可被删除\r\n+ `enumerable`: 是否可被枚举，不可枚举属性无法通过 `Object.keys` 获取到\r\n+ `writable`: 是否可更改该属性值\r\n+ `value`: 该属性值的值\r\n\r\n当我们使用赋值运算符为对象添加属性时，实际上是添加了一个数据描述符\r\n\r\n``` js\r\n> o.c = 5\r\n> Object.getOwnPropertyDescriptor(o, 'c')\r\n< {value: 5, writable: true, enumerable: true, configurable: true}\r\n```\r\n\r\n## 存取描述符 (accessor descriptor)\r\n\r\n可对对象属性进行拦截，Vue2 的数据绑定原理便是基于此\r\n\r\n``` js\r\nconst o = {}\r\nObject.defineProperty(o, 'a', {\r\n  configurable: false,\r\n  enumerable: false,\r\n  get () {\r\n     return this._a\r\n  },\r\n  set (a) {\r\n    this._a = a * 10\r\n  }\r\n})\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MDQ1NzE2Nzk=",
    "number": 565,
    "title": "【Q551】Object.keys 与 Object.getOwnPropertyNames() 有何区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg1MTcyNzE3NQ==",
      "body": "+ `Object.keys`: 列出可枚举的属性值\r\n+ `Object.getOwnPropertyNames`: 列出所有属性值(包括可枚举与不可枚举)\r\n\r\n同时 `Object.defineProperty` 中的选项  `enumerable` 可定义属性是否可枚举",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MDQ1OTExODM=",
    "number": 566,
    "title": "【Q552】关于 setState 以下代码的输出",
    "body": "代码如下所示，每次切换 TODO 状态时，通过手动修改 `todo.status` 再 setTodo，此时是否会修改成功\r\n\r\n> 代码见 [setState - codesandbox](https://codesandbox.io/s/setstate-r7qof?file=/src/App.js)\r\n\r\n``` js\r\nimport { useState } from \"react\";\r\n\r\nexport default function App() {\r\n  const [todo, setTodo] = useState({ id: 1, status: \"TODO\" });\r\n  return (\r\n    <div className=\"App\">\r\n      <button\r\n        onClick={() => {\r\n          todo.status = !todo.status;\r\n          setTodo(todo);\r\n        }}\r\n      >\r\n        Toggle Status\r\n      </button>\r\n      <h1>{todo.status}</h1>\r\n    </div>\r\n  );\r\n}\r\n\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU5MDQ2NDMyOTI=",
    "number": 567,
    "title": "【Q553】Grid 布局的优势在哪里",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg1MDk3NzU4MQ==",
      "body": "Flex 布局是轴线布局，只能指定\"项目\"针对轴线的位置，可以看作是一维布局。\r\nGrid 布局则是将容器划分成\"行\"和\"列\"，产生单元格，然后指定\"项目所在\"的单元格，可以看作是二维布局。\r\nGrid 布局远比 Flex 布局强大    \r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "Kiera569",
        "url": "https://github.com/Kiera569"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MDQ5OTM5MTc=",
    "number": 569,
    "title": "【Q554】SameSite Cookie 有哪些值，是如何预防 CSRF 攻击的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      },
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg1MDkxODczNw==",
      "body": "> 见文档 [SameSite Cookie - MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite)\r\n> 见文章 [Cookie 的 SameSite 属性](http://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html)\r\n\r\n+ None: 任何情况下都会向第三方网站请求发送 Cookie\r\n+ Lax: 只有导航到第三方网站的 Get 链接会发送 Cookie，跨域的图片、iframe、form表单都不会发送 Cookie\r\n+ Strict: 任何情况下都不会向第三方网站请求发送Cookie\r\n\r\n目前，主流浏览器 Same-Site 的默认值为 `Lax`，而在以前是 `None`，将会预防大部分 CSRF 攻击，如果需要手动指定 `Same-Site` 为 `None`，需要指定 Cookie 属性 `Secure`，即在 https 下发送",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MDUwMzU1NjE=",
    "number": 570,
    "title": "【Q555】sessionStorage与localStorage有何区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU5MDUwMzY2MDA=",
    "number": 571,
    "title": "【Q556】如何设置一个支持过期时间的 localStorage",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs4270sX",
      "body": "```javascript\r\n\r\nfunction initLocalStorage () {\r\n    localStorage.setItem = function (key, value, time = 1000) {\r\n        const expiresTime = Date.now() + time * 1000\r\n        const payload = {\r\n            __data: value,\r\n            __expiresTime: expiresTime,\r\n        }\r\n        Storage.prototype.setItem.call(localStorage, key, JSON.stringify(payload))\r\n    }\r\n    localStorage.getItem = function (key) {\r\n        const value = Storage.prototype.getItem.call(localStorage, key)\r\n        if (typeof value === 'string') {\r\n            const jsonVal = JSON.parse(value)\r\n            if (jsonVal.__expiresTime) {\r\n                if (jsonVal.__expiresTime >= Date.now()) {\r\n                    return JSON.stringify(jsonVal.__data)\r\n                } else {\r\n                    return null\r\n                }\r\n            }\r\n        }\r\n        return value\r\n    }\r\n\r\n}\r\ninitLocalStorage()\r\n\r\n```\r\n\r\n想了下 只能去改api 去封装一层 不过存在一个问题就是别人在使用的时候 也需要遵循这个规则  没想到别的办法",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "heretic-G",
        "url": "https://github.com/heretic-G"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MDYyOTUzMTc=",
    "number": 572,
    "title": "【Q557】如何实现三列均分布局",
    "body": "布局代码如下所示，可见 [三列均分布局 - codepen](https://codepen.io/shanyue/pen/yLMzxqX)\r\n\r\n> 注: 在第一个元素中设置文字，子元素不能因文字过长而挤压。\r\n\r\n``` html\r\n<div class=\"container\">\r\n  <div class=\"item\">白日依山尽，黄河入海流。欲穷千里目，更上一层楼。</div>\r\n  <div class=\"item\"></div>\r\n  <div class=\"item\"></div>\r\n</div>\r\n```\r\n\r\n``` css\r\n\r\n// 以下为样式代码，非核心功能代码\r\n* {\r\n  box-sizing: border-box;\r\n}\r\n\r\n.container {\r\n  background-color: #eee;\r\n  height: 10rem;\r\n  width: 40rem;\r\n  margin: 1rem;\r\n}\r\n\r\n.item {\r\n  border: 1px solid #888;\r\n}\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg1MDc1NDIyMA==",
      "body": "见代码 [三均分布局 - Codepen](https://codepen.io/shanyue/pen/yLMzxqX)\r\n\r\n## 使用 Flex\r\n\r\n注意使用 `calc(100% / 3)` 设置 `flex-basis`，同时它的缺陷是**不能够很好的为子元素设置左右间隙**\r\n\r\n``` scss\r\n.flex-container {\r\n  display: flex;\r\n  flex-wrap: wrap;\r\n  // gap: 1rem;\r\n  \r\n  \r\n  .item {\r\n   flex: 0 0 calc(100% / 3);\r\n  }\r\n}\r\n```\r\n\r\n> 注意: 如果同时给子元素使用 `flex-grow: 1` 控制均分，当子元素拥有文字等内容时，会受到挤压，将无法实现均分布局。\r\n\r\n## 使用 Grid\r\n\r\n使用 Grid 直接操作容器即可，对于子元素之间的间隙也可以很好地控制，可看出 Grid 更为简单，更为高效，更为精确\r\n\r\n``` scss\r\n.grid-container {\r\n  display: grid;\r\n  grid-template-columns: 1fr 1fr 1fr;\r\n  gap: 1rem;\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MDY1OTcxMTM=",
    "number": 573,
    "title": "【Q558】如何统计当前页面出现的所有标签",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg1MDkyMzU2OA==",
      "body": "+ `document.querySelectorAll('*')`\r\n+ `document.getElementsByTagName('*')`\r\n+ `$$('*')`，可在浏览器控制台使用\r\n+ `document.all`，已废弃，不建议使用",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MDY2MDAwNjU=",
    "number": 574,
    "title": "【Q559】如何监听 localStorage 的变动",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs400ajV",
      "body": "[StorageEvent](https://developer.mozilla.org/zh-CN/docs/Web/API/StorageEvent)\r\n\r\n[https://caniuse.com/?search=StorageEvent](https://caniuse.com/?search=StorageEvent)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "haotie1990",
        "url": "https://github.com/haotie1990"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MDY2MTExNDA=",
    "number": 575,
    "title": "【Q560】Data URL 的应用场景及如何生成",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      },
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg1MDkzMTIzMg==",
      "body": "Data URLs 由四个部分组成：\r\n\r\n1. 前缀(data:)\r\n2. 指示数据类型的MIME类型\r\n3. 如果二进制数据则为可选的base64标记，比如图片\r\n4. 数据\r\n\r\n\r\n```\r\ndata:[<mediatype>][;base64],<data>\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MDY2Nzk3MTM=",
    "number": 576,
    "title": "【Q561】实现一个 inherits 函数进行继承",
    "body": "使用方法如 `inherits(Dog, Animal);`，`Dog` 对 `Animal` 进行了继承",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg3MTg2Mzk2Ng==",
      "body": "``` js\r\nfunction inherits(SuperType, SubType) {\r\n  const pro = Object.create(SuperType.prototype);\r\n  pro.constructor = SubType;\r\n  SubType.prototype = pro;\r\n}\r\nfunction SuperType(friends) {\r\n  this.friends = friends;\r\n}\r\nSuperType.prototype.getFriends = function() {\r\n  console.log(this.friends);\r\n}\r\nfunction SubType(name, friends) {\r\n  this.name = name;\r\n  SuperType.call(this, friends);\r\n}\r\ninherits(SuperType, SubType);\r\nSubType.prototype.getName = function() {\r\n  console.log(this.name);\r\n}\r\n\r\nconst tom = new SubType('tom', ['jerry']);\r\ntom.getName();\r\n// 'tom'\r\ntom.getFriends();\r\n// ['jerry']\r\ntom.friends.push('jack');\r\ntom.getFriends();\r\n// ['jerry', 'jack']\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "mrrs878",
        "url": "https://github.com/mrrs878"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MDY2ODA0ODY=",
    "number": 577,
    "title": "【Q562】WeakMap 与垃圾回收有何关系",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg1MTcyNTU3NA==",
      "body": "`WeakMap` 与 `Map` 有亮点不同\r\n\r\n1. 键值只能为引用对象，无法使用基础数据类型\r\n2. 弱引用，无法枚举，因此无 `.entries()` 方法",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MDY2OTE2NjE=",
    "number": 578,
    "title": "【Q563】什么是媒体查询，JS 可以监听媒体查询吗",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs400Z-K",
      "body": "[MediaQueryList](https://developer.mozilla.org/zh-CN/docs/Web/API/MediaQueryList)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "haotie1990",
        "url": "https://github.com/haotie1990"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MDc3NzM2MTc=",
    "number": 579,
    "title": "【Q564】z-index: 999 元素一定会置于 z-index: 0 元素之上吗",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg1MTczMjUzNQ==",
      "body": "代码见 [zindex - codepen](https://codepen.io/shanyue/pen/XWMVpxJ)\r\n\r\n不可，更复杂的示例见 [层叠上下文 - MDN](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MDc3OTQ0OTE=",
    "number": 580,
    "title": "【Q565】浏览器中事件有哪些属性与方法",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU5MDc3OTkwOTQ=",
    "number": 581,
    "title": "【Q566】关于块级作用域，以下代码输出多少，在何时间输出",
    "body": "``` js\r\nfor (var i = 0; i < 5; i++) {\r\n  setTimeout(() => console.log(i), 1000)\r\n}\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg1MTc1MDM2OQ==",
      "body": "一秒之后连续输出五个5，以下可输出预期效果\r\n\r\n``` js\r\nfor (let i = 0; i < 5; i++) {\r\n  setTimeout(() => console.log(i), 1000 * i)\r\n}\r\n\r\nfor (var i = 0; i < 5; i++) {\r\n  setTimeout(console.log, 1000 * i, i)\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MDkwMTg2NTU=",
    "number": 582,
    "title": "【Q567】如何逆序一个字符串",
    "body": "可以使用 `Array.prototype.reverse.call(s)` 逆序字符串吗",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg1MjY3MTQwOA==",
      "body": "可以直接调用 API 进行实现:\r\n\r\n``` js\r\nconst reverse = s => s.split('').reverse().join('')\r\n\r\nreverse('hello')\r\n//=> \"olleh\"\r\n```\r\n\r\n如果不调用 API 实现的话，参考以下代码:\r\n\r\n``` js\r\nfunction reverse (s) {\r\n  let r = ''\r\n  for (const c of s) {\r\n    r = c + r\r\n  }\r\n  return r\r\n}\r\n\r\nreverse('hello')\r\n//=> \"olleh\"\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MDkwMjU3NjU=",
    "number": 583,
    "title": "【Q568】为何 0.1+0.2 不等于 0.3，应如何做相等比较",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg1MjY3NTEwMA==",
      "body": "0.1，0.2 表示为二进制会有精度的损失，比较时可引入一个很小的数值 `Number.EPSILON` 容忍误差，其值为 2^-52。\r\n\r\n``` js\r\nfunction equal (a, b) {\r\n  return Math.abs(a - b) < Number.EPSILON\r\n}\r\n```",
      "star": {
        "totalCount": 2
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MDkwMjg5ODk=",
    "number": 584,
    "title": "【Q569】关于 this 与包装对象，以下输出多少",
    "body": "``` js\r\nfunction foo() {\r\n  console.log(this)\r\n}\r\n\r\nfoo.call(3);\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg3MTg4MjM3Mw==",
      "body": "如果处于非严格模式下，要绑定的`this`指定为`null`或`undefined`时会自动替换为全局对象，原始值则会被包装\r\n\r\n严格模式：\r\n``` js\r\n'use strict';\r\n\r\nfunction test() {\r\n    console.log(this)\r\n}\r\n\r\ntest.call(2)\r\n// 2\r\n```\r\n\r\n非严格模式\r\n``` js\r\nfunction test() {\r\n    console.log(this)\r\n}\r\ntest.call(2)\r\n// Number {2}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "mrrs878",
        "url": "https://github.com/mrrs878"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MDk0NDM2NTY=",
    "number": 585,
    "title": "【Q570】浏览器中如何读取二进制信息",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs400ZKl",
      "body": "[二进制数据，文件](https://zh.javascript.info/binary)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "haotie1990",
        "url": "https://github.com/haotie1990"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MTAwMDg0MzM=",
    "number": 586,
    "title": "【Q571】关于类型转化，判断以下代码输出",
    "body": "``` js\r\nBoolean(new Boolean(false));\r\nBoolean(document.all);\r\n\r\n[] == '';\r\n[3] == 3;\r\n[] == false;\r\n42 == true;\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg3MjMwMDA5Mg==",
      "body": "在`==`时，会强制类型转换并比较转换后的结果\r\n\r\n比较过程如下：\r\n\r\n- 如果两个变量都是对象，则当都引用同一对象时才返回`true`\r\n- `null == undefined` ? 返回`true`\r\n- 当两个变量类型不一致时会进行类型转换：\r\n    - `string == number` ? `string`转换为`number`后再进行比较\r\n    - `boolean == any` ? `boolean`转换为`number`后再进行比较\r\n    - `object == string/number/symbol` ? 尝试调用`object`的`valueOf`或`toString`将其转换为原始类型后再进行比较\r\n- 当两个变量类型一致时：\r\n    - `number == number` ? 其中有一个为`NaN`时返回`false`; `+0 == -0`时返回`true`\r\n \r\n![非原创，原作者未知](https://user-images.githubusercontent.com/38256126/124141063-a5c7b400-dabb-11eb-8a8c-2f9503f9f06e.png)\r\n\r\n所以`[] == 0`时：\r\n\r\n1. `[]`先调用`Array.prototype.toString`转为原始值\r\n\r\n``` js\r\nArray.prototype.toString.call([])\r\n// \"\"\r\n```\r\n\r\n2. `\"\" == 0`，`\"\"`转为`number`即0\r\n\r\n3. `0 == 0`，返回`true`\r\n\r\n其他几行代码同理\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "mrrs878",
        "url": "https://github.com/mrrs878"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MTAwMjM2OTI=",
    "number": 587,
    "title": "【Q572】关于暂时性死域，判断以下代码输出",
    "body": "**第一段代码如下**\r\n\r\n``` js\r\nvar a = 3;\r\nlet a;\r\n```\r\n\r\n**第二段代码如下**\r\n\r\n``` js\r\nvar x = 3;\r\n\r\nfunction foo (x=x) {\r\n    // ..\r\n}\r\n\r\nfoo()\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs41F7m1",
      "body": "暂时性死域的问题，对于 `let`/`const` 声明变量之前被使用的话会报错",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MTAwMzYxOTY=",
    "number": 588,
    "title": "【Q573】关于词法作用域，判断以下代码输出",
    "body": "``` js\r\nvar scope = 'global scope';\r\nfunction checkScope () {\r\n  var scope = 'local scope';\r\n  function f() {\r\n    return scope; \r\n  }\r\n  return f;\r\n}\r\n\r\ncheckScope()();\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg1MzUxNTQ2Ng==",
      "body": "`local scope`\r\n\r\n由于 js 为词法作用域(Lexical Scope)，访问某个变量时，先在当前作用域中查找，如果查找不到则在嵌套作用域中查找，直到找到。如果找不到，则报 ReferenceError。",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MTAwMzY5Mjk=",
    "number": 589,
    "title": "【Q574】关于 this，判断以下代码输出",
    "body": "``` js\r\nfunction foo() {\r\n  console.log( this.a );\r\n}\r\n\r\nvar a = 2;\r\n\r\n(function(){\r\n  \"use strict\";\r\n\r\n  foo();\r\n})();\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg1MzUxOTcwMQ==",
      "body": "输出: 2\r\n\r\n**只有在存在 this 的函数中设置严格模式**，this 为 undefined。因此此时会正常输出。",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MTAwNjQwMjQ=",
    "number": 590,
    "title": "【Q575】关于 new，判断以下代码输出",
    "body": "``` js\r\nfunction F () {\r\n  this.a = 3;\r\n  return {\r\n    a: 4;\r\n  }\r\n}\r\n\r\nconst f = new F();\r\nconsole.log(f.a);\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg1MzYyNDUzOA==",
      "body": "输出 4\r\nnew 操作符，默认返回this对象。如果手动指定返回对象，则new出来的实例指向的是return的对象，而不是this",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "hsk863hh",
        "url": "https://github.com/hsk863hh"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MTA5ODU2NDQ=",
    "number": 591,
    "title": "【Q576】如何正确得知某张图片的 MIME 格式",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      },
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU5MTA5ODY4MzE=",
    "number": 592,
    "title": "【Q577】关于简单的事件循环，判断以下代码输出",
    "body": "判断以下代码输出次序\r\n\r\n``` js\r\nsetTimeout(() => console.log('A'))\r\n\r\nPromise.resolve().then(() => console.log('B'))\r\n\r\nconsole.log('C')\r\n```\r\n\r\n[复杂题在此](https://github.com/shfshanyue/Daily-Question/issues/528)",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg1NDI5MzA5Mw==",
      "body": "`C B A`\r\n\r\nC 在主线程执行栈\r\nB 在microtask\r\nA 在 macrotask",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MTMwNTQ0NzA=",
    "number": 594,
    "title": "【Q578】HTTP 响应头 cache-control: s-maxage=0 是什么意思",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU5MTMwNTgwMzc=",
    "number": 595,
    "title": "【Q579】http 缓存控制中 Cach-Control 为 public 与 private 有何区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg1ODQyOTQ3Nw==",
      "body": "cache-control:默认值是private,\r\nprivite    响应只能为私有缓存，不能在用户间共享\r\npublic    公有缓存，可以在多用户间共享",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "Kiera569",
        "url": "https://github.com/Kiera569"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MTMwNjE4ODk=",
    "number": 596,
    "title": "【Q580】http 方法 get 与 post 有何区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs400Xfm",
      "body": "- GET在浏览器回退时是无害的，而POST会再次提交请求。\r\n\r\n- GET产生的URL地址可以被Bookmark，而POST不可以。\r\n\r\n- GET请求会被浏览器主动cache，而POST不会，除非手动设置。\r\n\r\n- GET请求只能进行url编码，而POST支持多种编码方式。\r\n\r\n- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。\r\n\r\n- GET请求在URL中传送的参数是有长度限制的，而POST么有。\r\n\r\n- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。\r\n\r\n- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。\r\n\r\n- GET参数通过URL传递，POST放在Request body中。\r\n\r\n- **GET产生一个TCP数据包；POST产生两个TCP数据包**。",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "haotie1990",
        "url": "https://github.com/haotie1990"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MTM0ODIxMDM=",
    "number": 597,
    "title": "【Q581】箭头函数和普通函数的区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg3NDA0MDU5MQ==",
      "body": "箭头函数无 this，无 prototype",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MTUxMDI0NzM=",
    "number": 598,
    "title": "【Q582】什么是 URL 编码 (URL Encode)",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
        "name": "html"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs400W_n",
      "body": "encodeURI用来编码**URI**，其不会编码保留字符：;,/?:@&=+$\r\n\r\nencodeURIComponent用来编码URI**参数**，除了字符：A-Z a-z 0-9 - _ . ! ~ * ' ( )，都将会转义",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "haotie1990",
        "url": "https://github.com/haotie1990"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MTU3MjQ4NDg=",
    "number": 599,
    "title": "【Q583】http 状态码  204 使用在什么场景",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg1NzMzNTYzNQ==",
      "body": "1. `Head Method`\r\n2. `Options Method`\r\n3. 打点",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MTU3MzAzOTU=",
    "number": 600,
    "title": "【Q584】现代前端应用应如何配置 HTTP 缓存机制",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      },
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs41KKwb",
      "body": "> 参考: [前端项目中的缓存配置](https://shanyue.tech/frontend-engineering/http-cache.html)\r\n\r\n关于 http 缓存配置的最佳实践为以下两条：\r\n\r\n1. 文件路径中带有 hash 值：一年的强缓存。因为该文件的内容发生变化时，会生成一个带有新的 hash 值的 URL。前端将会发起一个新的 URL 的请求。配置响应头 `Cache-Control: public,max-age=31536000,immutable`\r\n1. 文件路径中不带有 hash 值：协商缓存。大部分为 `public` 下文件。配置响应头 `Cache-Control: no-cache` 与 `etag/last-modified`\r\n\r\n但是当处理永久缓存时，切记不可打包为一个大的 `bundle.js`，此时一行业务代码的改变，将导致整个项目的永久缓存失效，此时需要按代码更新频率分为多个 chunk 进行打包，可细粒度控制缓存。\r\n\r\n![细粒度缓存控制](https://shanyue.tech/assets/img/http-cache-2.182dbd90.png)\r\n\r\n\r\n1. `webpack-runtime`: 应用中的 `webpack` 的版本比较稳定，分离出来，保证长久的永久缓存\r\n1. `react/react-dom`: `react` 的版本更新频次也较低\r\n1. `vendor`: 常用的第三方模块打包在一起，如 `lodash`，`classnames` 基本上每个页面都会引用到，但是它们的更新频率会更高一些。另外对低频次使用的第三方模块不要打进来\r\n1. `pageA`: A 页面，当 A 页面的组件发生变更后，它的缓存将会失效\r\n1. `pageB`: B 页面\r\n1. `echarts`: 不常用且过大的第三方模块单独打包\r\n1. `mathjax`: 不常用且过大的第三方模块单独打包\r\n1. `jspdf`: 不常用且过大的第三方模块单独打包\r\n\r\n在 `webpack5` 中可以使用以下配置:\r\n\r\n``` js\r\n{\r\n  // Automatically split vendor and commons\r\n  // https://twitter.com/wSokra/status/969633336732905474\r\n  // https://medium.com/webpack/webpack-4-code-splitting-chunk-graph-and-the-splitchunks-optimization-be739a861366\r\n  splitChunks: {\r\n    chunks: 'all',\r\n  },\r\n  // Keep the runtime chunk separated to enable long term caching\r\n  // https://twitter.com/wSokra/status/969679223278505985\r\n  // https://github.com/facebook/create-react-app/issues/5358\r\n  runtimeChunk: {\r\n    name: entrypoint => `runtime-${entrypoint.name}`,\r\n  },\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MTU3NDEyODM=",
    "number": 601,
    "title": "【Q585】如何确保你们的项目开启了 gzip",
    "body": "当你们的项目上线后，如何查看它是否开启了 gzip",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg3MzU1NzgwNw==",
      "body": "在响应头中查看是否有以下值：\r\n\r\n```  bash\r\ncontent-encoding: gzip\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MTU3NDE3Njk=",
    "number": 602,
    "title": "【Q586】HTTP 有哪些常见的请求头和响应头",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU5MTY4MDYwNjM=",
    "number": 603,
    "title": "【Q587】使用 webpack 如何分包",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
        "name": "webpack"
      },
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU5MTY4MDk0OTA=",
    "number": 604,
    "title": "【Q588】什么是 HSTS ",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs400WMJ",
      "body": "HSTS 是 HTTP 严格传输安全（HTTP Strict Transport Security） 的缩写。 这是一种网站用来声明他们只能使用安全连接（HTTPS）访问的方法。 如果一个网站声明了 HSTS 策略，浏览器必须拒绝所有的 HTTP 连接并阻止用户接受不安全的 SSL 证书\r\n\r\n[https://zhuanlan.zhihu.com/p/130946490](https://zhuanlan.zhihu.com/p/130946490)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "haotie1990",
        "url": "https://github.com/haotie1990"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MTgxNzI4ODg=",
    "number": 605,
    "title": "【Q589】http 中 referer 请求头是做什么的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg2MDUyMzQyNw==",
      "body": "判断该网页的来源地址\r\n\r\n1. 打点\r\n2. 防盗链",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MTgxNzU1OTA=",
    "number": 606,
    "title": "【Q590】React 中什么是合成事件",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg1OTYyODg3Nw==",
      "body": "1. 提供统一的 API，抹平各大浏览器差异\r\n2. 所有事件绑定在 React Root Element 进行事件委托",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MTgxNzYwODQ=",
    "number": 607,
    "title": "【Q591】什么是纯函数",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg2MTQ3NDQ3OQ==",
      "body": "1. 输出仅由输入决定，每一个固定的输入总是返回相同的输出\r\n2. 不产生副作用\r\n\r\n``` js\r\nfunction push(list, x)  {\r\n  list.push(x);\r\n  return list\r\n}\r\n\r\nconst l = []\r\npush(l, 3)\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MTgxNzcwNzM=",
    "number": 608,
    "title": "【Q592】前端项目中有哪些副作用",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      },
      {
        "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
        "name": "vue"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU5MTgxODE1MzU=",
    "number": 609,
    "title": "【Q593】React/Vue 中受控组件与不受控组件的区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      },
      {
        "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
        "name": "vue"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU5MTg3MzQ5NDY=",
    "number": 610,
    "title": "【Q594】给数字添加千位符",
    "body": "``` js\r\n//=> '123'\r\nnumberThousands(123)\r\n\r\n//=> '1,234,567'\r\nnumberThousands(1234567)\r\n```\r\n\r\n问题追问：\r\n\r\n+ 如果考虑小数应该如何处理?",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg1OTU3OTMyOA==",
      "body": "千位符替换可由正则 `/(\\d)(?=(\\d\\d\\d)+(?!\\d))/` 进行匹配\r\n\r\n``` js\r\nfunction numberThousands (number, thousandsSeperator = ',') {\r\n  return String(number).replace(/(\\d)(?=(\\d\\d\\d)+(?!\\d))/g, '$1' + thousandsSeperator)\r\n}\r\n```\r\n\r\n删除的正则或许有点复杂，如果对字符串反转，可以来一个简单的正则\r\n\r\n``` js\r\nfunction numberThousands (number, thousandsSeperator = ',') {\r\n  const reverse = str => str.split('').reverse().join('')\r\n  const str = reverse(String(number)).replace(/\\d\\d\\d(?!\\d)/g, '$1' + thousandsSeperator)\r\n  return reverse(str)\r\n}\r\n```\r\n\r\n如果你写不出来正则，也可由一段简单的代码实现\r\n\r\n``` js\r\nfunction numberThousands (number, thousandsSeperator = ',') {\r\n  const s = String(number)\r\n  let r = ''\r\n  for (let i = s.length - 1; i >= 0; i--) {\r\n    const seperator = (s.length - i - 1) % 3 ? '' : thousandsSeperator\r\n    r = `${s[i]}${seperator}${r}`\r\n  }\r\n  return r.slice(0, -1)\r\n}\r\n```",
      "star": {
        "totalCount": 1
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MTg4ODEyMDI=",
    "number": 611,
    "title": "【Q595】React 中监听 input 的 onChange 事件的原生事件是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      },
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg2MjAxMTI1Mw==",
      "body": "[React 中 onChange 的原生事件是什么？](https://codesandbox.io/s/input-onchange-1ybhw?file=/src/App.js)\r\n\r\n``` js\r\nimport \"./styles.css\";\r\n\r\nexport default function App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <input\r\n        onChange={(e) => {\r\n          console.log(\"Event: \", e);\r\n          console.log(\"NativeEvent: \", e.nativeEvent);\r\n          console.log(\"CurrentTarget: \", e.nativeEvent.currentTarget);\r\n          console.log(\"NativeEvent Type: \", e.nativeEvent.type);\r\n        }}\r\n      />\r\n    </div>\r\n  );\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MTk1NTIxNDM=",
    "number": 612,
    "title": "【Q596】在浏览器中点击 a 标签保存为文件如何做",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg2MDA1MDI4NA==",
      "body": "有两种方式:\r\n\r\n1. `a.download` 当指定 a 标签的 `download` 属性时，点击该链接会直接保存为文件，文件名为 `download` 属性\r\n1.  通过对 a 标签指定的 URL 在服务器设置响应头 `Content-Disposition: attachment; filename=\"filename.jpg\"` 可直接下载\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MTk2ODk0NjM=",
    "number": 613,
    "title": "【Q597】引入 BFF 层的优势在哪里",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg2MDEzMzIwOQ==",
      "body": "BFF 全称 `Backend For Frontend`，一般指在前端与服务器端搭建一层由前端维护的 Node Server服务，具有以下好处\r\n\r\n1. 数据处理。对数据进行校验、清洗及格式化。使得数据更与前端契合\r\n2. 数据聚合。后端无需处理大量的表连接工作，第三方接口聚合工作，业务逻辑简化为各个资源的增删改查，由 BFF 层聚合各个资源的数据，后端可集中处理性能问题、监控问题、消息队列等\r\n3. 权限前移。在 BFF 层统一认证鉴权，后端无需做权限校验，后端可直接部署在集群内网，无需向外网暴露服务，减少了后端的服务度。\r\n\r\n但其中也有一些坏处，如以下\r\n\r\n1. 引入复杂度，新的 BFF 服务需要一套基础设施的支持，如日志、异常、部署、监控等",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MTk3MDUzMzU=",
    "number": 614,
    "title": "【Q598】如何实现一个深比较的函数 deepEqual",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs400Vtn",
      "body": "```js\r\nfunction isEqual(x, y) {\r\n  if (x === y) {\r\n    return true;\r\n  } else if ((typeof x === 'object' && x !== null) && (typeof y === 'object' && y !== null)) {\r\n    const keysX = Object.keys(x);\r\n    const keysY = Object.keys(y);\r\n    if (keysX.length !== keysY.length) {\r\n      return false;\r\n    }\r\n    for (const key of keysX) {\r\n      if(!isEqual(x[key], y[key])) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  } else {\r\n    return false;\r\n  }\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "haotie1990",
        "url": "https://github.com/haotie1990"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MTk3NzA2ODk=",
    "number": 615,
    "title": "【Q599】Object.is 与全等运算符(===)有何区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg2MDE5MDYxOQ==",
      "body": "> https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is\r\n\r\n1. +0/-0\r\n2. NaN/NaN\r\n\r\n``` js\r\nif (!Object.is) {\r\n  Object.is = function(x, y) {\r\n    // SameValue algorithm\r\n    if (x === y) { // Steps 1-5, 7-10\r\n      // Steps 6.b-6.e: +0 != -0\r\n      return x !== 0 || 1 / x === 1 / y;\r\n    } else {\r\n      // Step 6.a: NaN == NaN\r\n      return x !== x && y !== y;\r\n    }\r\n  };\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MTk4MjAwMDk=",
    "number": 616,
    "title": "【Q600】在 React hooks 中如何模拟 forceUpdate",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg2MDIyNzA1Nw==",
      "body": "``` js\r\n  const [ignored, forceUpdate] = useReducer(x => x + 1, 0);\r\n\r\n  function handleClick() {\r\n    forceUpdate();\r\n  }\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MjAyMTc3Mjg=",
    "number": 617,
    "title": "【Q601】什么是认证与授权",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU5MjM5MTI3Njk=",
    "number": 619,
    "title": "【Q602】如何把对象转化为 key/value 的二维数组",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg2MzIyOTI5OA==",
      "body": "``` js\r\nObject.entries({ a: 3 })\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MjUwMDUzMjY=",
    "number": 620,
    "title": "【Q603】在 JS 中如何监听 Object 某个属性值的变化",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg3NjI3MTI5OA==",
      "body": "```\r\nlet obj = {\r\n    a:'元素a',\r\n    b:'元素b'\r\n}\r\nconst handle = {\r\n    get:(obj,prop)=>{\r\n        console.log(`正在获取：${prop}`);\r\n        return obj[prop];\r\n    },\r\n    set:(obj,prop,value)=>{\r\n        console.log(`正在修改元素：将${prop}属性设置为${value}`);\r\n        obj[prop] = value;\r\n    }\r\n}\r\n\r\nconst proxy = new Proxy(obj,handle);\r\n\r\nconsole.log(proxy.a)\r\n//正在获取：a\r\n// 元素a\r\n\r\nproxy.a='123'\r\n// 正在修改元素：将a属性设置为123\r\n\r\nconsole.log(proxy);\r\n//Proxy {a: \"123\", b: \"元素b\"}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "txd688",
        "url": "https://github.com/txd688"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MjU1MTMzMTc=",
    "number": 621,
    "title": "【Q604】判断以下路由，将会响应哪一个路由",
    "body": "代码见: [多匹配路由 - codesandbox](https://codesandbox.io/s/node-server-duopipeiluyou-lr2l4)\r\n\r\n``` js\r\nconst app = new Koa()\r\nconst router = new Router()\r\n\r\nrouter.get('/', (ctx, next) => {\r\n  ctx.body = 'hello, world'\r\n})\r\n\r\nrouter.get('/api/users/10086', (ctx, next) => {\r\n  console.log(ctx.router)\r\n  ctx.body = {\r\n    userId: 10086,\r\n    direct: true\r\n  }\r\n})\r\n\r\nrouter.get('/api/users/:userId', (ctx, next) => {\r\n  console.log(ctx.router)\r\n  ctx.body = {\r\n    userId: ctx.params.userId\r\n  }\r\n})\r\n\r\napp.use(router.routes())\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      },
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs41EfQ9",
      "body": "TODO",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MzEzMjEwOTE=",
    "number": 622,
    "title": "【Q605】js 中什么是 AsyncIterable",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs40p9QH",
      "body": "``` js\r\nfor await (const x of data) {}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MzMyNDkyNTE=",
    "number": 624,
    "title": "【Q606】关于事件循环，仅有 Promise，判断以下代码输出",
    "body": "> 代码见 [Promise 事件循环代码输出顺序题目 - CodePen](https://codepen.io/shanyue/pen/XWRJjwz)\r\n\r\n``` js\r\nPromise.resolve(console.log(0))\r\n  .then(() => {\r\n    console.log(1);\r\n    Promise.resolve(console.log(5))\r\n      .then(() => console.log(3))\r\n      .then(() => console.log(4))\r\n      .then(() => console.log(6))\r\n  })\r\n  .then(() => console.log(2))\r\n  .then(() => console.log(7))\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg3MTA1NTQ0Ng==",
      "body": "按照我的理解应该是0,1,2,7,5,3,4,6",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "xiaoxiaohuayu",
        "url": "https://github.com/xiaoxiaohuayu"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MzMyNjY1NDE=",
    "number": 625,
    "title": "【Q607】关于字符串编码解码进阶",
    "body": "一道有意思的面试题\r\n例子如下，实现`countOfLetters`\r\n```js\r\ncountOfLetters('A2B3') // { A: 2, B: 3 }\r\ncountOfLetters('A(A3B)2') // { A: 7, B: 2}\r\ncountOfLetters('C4(A(A3B)2)2') // { A: 14, B: 4, C: 4 }\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg3MTA2NTMzNw==",
      "body": "答案：\r\n```ts\r\ntype LetterCounter = {\r\n  // A-Z\r\n  [i: string]: number\r\n}\r\n\r\nfunction letterAddCount(target: LetterCounter, source: LetterCounter) {\r\n  for (let k in source) {\r\n    target[k] ??= 0\r\n    target[k] += source[k]\r\n  }\r\n  return target\r\n}\r\nfunction letterMultipleCount(target: LetterCounter, multiples: number) {\r\n  for (let i in target) {\r\n    target[i] *= multiples\r\n  }\r\n  return target\r\n}\r\nfunction countOfLetters(str: string) {\r\n  const regex = /[1-9]/\r\n  const stack: LetterCounter[] = [{}]\r\n  for (let i = 0; i < str.length; i++) {\r\n    const ch = str[i]\r\n    let count = 1\r\n    if (regex.test(str[i + 1])) count = +str[++i]\r\n    // case ( | )\r\n    switch (ch) {\r\n      case '(':\r\n        stack.push({})\r\n        continue\r\n      case ')':\r\n        const pop = stack.pop()!\r\n        const last = stack[stack.length - 1]\r\n        letterAddCount(last, letterMultipleCount(pop, count))\r\n        continue\r\n    }\r\n    // case A-Z\r\n    const last = stack[stack.length - 1]\r\n    last[ch] ??= 0\r\n    last[ch] += count\r\n  }\r\n  return stack.pop()\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "Nctdtman",
        "url": "https://github.com/Nctdtman"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MzM2NTk2Njk=",
    "number": 626,
    "title": "【Q608】请简介 CSS 的盒模型",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs44oowH",
      "body": "- 标准盒模型 \r\nwidth = content-width\r\nheight = content-height \r\n- 怪异盒模型\r\nwidth = content-width + padding + border\r\nheight = content-height + padding + border\r\n\r\n> 但是我感觉怪异盒模型更好用 😂",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "ssaylo",
        "url": "https://github.com/ssaylo"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MzQzMjE3MDY=",
    "number": 627,
    "title": "【Q609】请简述重新登录 refresh token 的原理",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      },
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs400GYj",
      "body": " Refresh Token，将会话管理流程改进如下。\r\n\r\n- 客户端使用用户名密码进行认证\r\n\r\n- 服务端生成有效时间较短的 Access Token（例如 10 分钟），和有效时间较长的 Refresh Token（例如 7 天）\r\n\r\n- 客户端访问需要认证的接口时，携带 Access Token\r\n\r\n- 如果 Access Token 没有过期，服务端鉴权后返回给客户端需要的数据\r\n\r\n- 如果携带 Access Token 访问需要认证的接口时鉴权失败（例如返回 401 错误），则客户端使用 Refresh Token 向刷新接口申请新的 Access Token\r\n\r\n- 如果 Refresh Token 没有过期，服务端向客户端下发新的 Access Token\r\n\r\n- 客户端使用新的 Access Token 访问需要认证的接口\r\n\r\nRefresh Token提供了服务端禁用用户 Token 的方式，当用户需要登出或禁用用户时，只需要将服务端的 Refresh Token 禁用或删除，用户就会在 Access Token 过期后，由于无法获取到新的 Access Token 而再也无法访问需要认证的接口。这样的方式虽然会有一定的窗口期（取决于 Access Token 的失效时间），但是结合用户登出时客户端删除 Access Token 的操作，基本上可以适应常规情况下对用户认证鉴权的精度要求。",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "haotie1990",
        "url": "https://github.com/haotie1990"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MzQ0NjIwMTE=",
    "number": 628,
    "title": "【Q610】了解什么是 JSBridge 吗",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs400Fno",
      "body": "JSBridge就是JavaScript和Native(IOS/Android)之间的桥梁，提供两者相互调用的能力",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "haotie1990",
        "url": "https://github.com/haotie1990"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MzQ1NjM1MjM=",
    "number": 629,
    "title": "【Q611】React/Vue 中兄弟组件如何进行通信",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      },
      {
        "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
        "name": "vue"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg3MjMyODA3Mw==",
      "body": "> [见代码：React 中兄弟组件如何通信 - CodeSandbox](https://codesandbox.io/s/react-xiongdizujiantongxin-f2jf6)\r\n\r\n兄弟组件可通过 prop 与回调函数式的 prop 进行通信\r\n\r\n``` js\r\nimport { useState } from \"react\";\r\nimport \"./styles.css\";\r\n\r\nfunction One({ count, setCount }) {\r\n  return (\r\n    <div style={{ border: \"1px solid red\" }}>\r\n      <h2>Conponent One</h2>\r\n      <button onClick={() => setCount(count + 1)}>Click</button>\r\n      <div>{count}</div>\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction Two({ count, setCount }) {\r\n  return (\r\n    <div style={{ border: \"1px solid red\" }}>\r\n      <h2>Conponent Two</h2>\r\n      <button onClick={() => setCount(count + 1)}>Click</button>\r\n      <div>{count}</div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default function App() {\r\n  const [count, setCount] = useState(0);\r\n  return (\r\n    <div className=\"App\">\r\n      <One count={count} setCount={(c) => setCount(c)} />\r\n      <Two count={count} setCount={(c) => setCount(c)} />\r\n    </div>\r\n  );\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MzQ4NDc5MjE=",
    "number": 630,
    "title": "【Q612】React.memo 中是如何实现性能优化的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg3MzMzNjMxNw==",
      "body": "当 React 中一个组件进行更新时，它的所有子组件都会进行重新渲染，即便子组件的 props 并未发生任何改变。\r\n\r\n`React.memo` 对子组件默认使用浅比较对比前后两次 props 的变更，若未发生变更则不会重新渲染，因此提高了性能。\r\n\r\n可参考以下两个示例，加深理解:\r\n\r\n1. [React.memo 和性能优化](https://codesandbox.io/s/zujianxiasuoyouzizujianhuifashengchongxinxuanran-bv70e)。当某个组件状态更新时，它的所有子组件树将会重新渲染。\r\n1. [React.memo 和 React.useMemo 是如何优化性能的](https://codesandbox.io/s/reactmemo-and-reactusememo-79txp)\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MzU0MjA0MjY=",
    "number": 631,
    "title": "【Q613】如何使用 JS 实现一个发布订阅模式",
    "body": "使用 JS 实现一个发布订阅器，`Event`，示例如下:\r\n\r\n``` js\r\nconst e = new Event()\r\n\r\ne.on('click', x => console.log(x.id))\r\n\r\ne.once('click', x => console.log(id))\r\n\r\n//=> 3\r\ne.emit('click', { id: 3 })\r\n\r\n//=> 4\r\ne.emit('click', { id: 4 })\r\n\r\n```\r\n\r\nAPI 如下：\r\n\r\n``` js\r\nclass Event {\r\n  emit (type, ...args) {\r\n  }\r\n\r\n  on (type, listener) {\r\n  }\r\n\r\n  once (type, listener) {\r\n  }\r\n\r\n  off (type, listener) {\r\n  }\r\n}\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg3MjcyNjQ0OA==",
      "body": "一个简单的订阅发布模式实现如下，主要有两个核心 API\r\n\r\n+ `emit`: 发布一个事件\r\n+ `on`: 监听一个事件\r\n+ `off`: 取消一个事件监听\r\n\r\n实现该模式，使用一个 events 维护发布的事件：\r\n\r\n``` js\r\nconst events = {\r\n  click: [{\r\n    once: true,\r\n    listener: callback,\r\n  }, {\r\n    listener: callback\r\n  }]\r\n}\r\n```\r\n\r\n具体实现代码如下所示\r\n\r\n``` js\r\nclass Event {\r\n  events = {}\r\n \r\n  emit (type, ...args) {\r\n    const listeners = this.events[type]\r\n    for (const listener of listeners) {\r\n      listener.listener(...args)\r\n      if (listener.once) {\r\n        this.off(type, listener.listener)\r\n      }\r\n    }\r\n  }\r\n\r\n  on (type, listener) {\r\n    this.events[type] = this.events[type] || []\r\n    this.events[type].push({ listener })\r\n  }\r\n\r\n  once (type, listener) {\r\n    this.events[type] = this.events[type] || []\r\n    this.events[type].push({ listener, once: true })\r\n  }\r\n\r\n  off (type, listener) {\r\n    this.events[type] = this.events[type] || []\r\n    this.events[type] = this.events[type].filter(listener => listener.listener !== listener)\r\n  }\r\n}\r\n```\r\n\r\n以上代码不够优雅，且有点小瑕疵，再次实现如下，代码可见 [如何实现发布订阅器  - codepen](https://codepen.io/shanyue/pen/WNjprpe?editors=0012)\r\n\r\n``` js\r\nclass Event {\r\n  events = {}\r\n \r\n  emit (type, ...args) {\r\n    const listeners = this.events[type]\r\n    for (const listener of listeners) {\r\n      listener(...args)\r\n    }\r\n  }\r\n\r\n  on (type, listener) {\r\n    this.events[type] = this.events[type] || []\r\n    this.events[type].push(listener)\r\n  }\r\n\r\n  once (type, listener) {\r\n    const callback = (...args) => {\r\n      this.off(type, callback)\r\n      listener(...args)\r\n    }\r\n    this.on(type, callback)\r\n  }\r\n\r\n  off (type, listener) {\r\n    this.events[type] = this.events[type] || []\r\n    this.events[type] = this.events[type].filter(callback => callback !== listener)\r\n  }\r\n}\r\n\r\nconst e = new Event()\r\n\r\nconst callback = x => { console.log('Click', x.id) }\r\ne.on('click', callback)\r\ne.on('click', callback)\r\n\r\n// 只打印一次\r\nconst onceCallback = x => console.log('Once Click', x.id)\r\ne.once('click', onceCallback)\r\ne.once('click', onceCallback)\r\n\r\n//=> 3\r\ne.emit('click', { id: 3 })\r\n\r\n//=> 4\r\ne.emit('click', { id: 4 })\r\n```",
      "star": {
        "totalCount": 1
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MzU5MzgwNjU=",
    "number": 632,
    "title": "【Q614】immer 的原理是什么，为什么它的性能更高",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg3NjU3NzIzNw==",
      "body": "``` js\r\nconst state = {\r\n  user: { id: 3 },\r\n  role: { name: 'admin' }\r\n}\r\n\r\nconst proxyState = new Proxy(state, {\r\n  get (target, prop) {\r\n    return target[prop]\r\n  },\r\n})\r\n```\r\n\r\n```js\r\n//=> True\r\nstate !== proxyState\r\n\r\n//=> True\r\nstate.user === proxyState.user\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MzYxNjE5NzQ=",
    "number": 633,
    "title": "【Q615】React.useMemo 与 React.useCallback 是如何进行性能优化的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU5MzY0MTUwNTI=",
    "number": 634,
    "title": "【Q616】在 nginx 中如何配置 HTTP 协商缓存",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg3NTIyNjM4MA==",
      "body": "Nginx 中在 1.3.3 后已默认开启了协商缓存，手动配置如下：\r\n\r\n``` nginx\r\nlocation /public {\r\n    add_header Cache-Control no-cache; \r\n    etag on;\r\n    if_modified_since exact;\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MzY0MjAzMjM=",
    "number": 635,
    "title": "【Q617】什么是 base64 与 URL Safe base64",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg3NTIyMjc4Nw==",
      "body": "`base64` 由 `0-9`、`A-Z`、`a-z` 及 `+`、`/` 组成，但是在 URL 中使用 `base64` 时，`/` 容易与路径符号发生冲突。\r\n\r\n因此，URL Safe Base64 将 `+` 替换为 `_`，`/` 替换为 `-`。",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MzY0MzQyNjU=",
    "number": 636,
    "title": "【Q618】列举 Number、String、Array、Object、Promise 有哪些 API",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      },
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg3NDAzODczOQ==",
      "body": "## Number\r\n\r\n+ Number.isNaN()\r\n+ Number.isInteger()\r\n+ Number.isInfinite()\r\n+ Number.isSafeInteger()\r\n+ Number.prototype.toFixed()\r\n\r\n## String\r\n\r\n+ String.fromCharCode()\r\n+ String.raw()\r\n+ String.prototype.charAt()\r\n+ String.prototype.charCodeAt()\r\n+ String.prototype.concat()\r\n+ String.prototype.startsWith()\r\n+ String.prototype.endsWith()\r\n+ String.prototype.includes()\r\n+ String.prototype.indexOf()\r\n+ String.prototype.lastIndexOf()\r\n+ String.prototype.charAt()\r\n+ String.prototype.charCodeAt()\r\n+ String.prototype.trim()\r\n  + 如何手写实现 trim\r\n+ String.prototype.trimStart()\r\n+ String.prototype.trimEnd()\r\n+ String.prototype.repeat()\r\n+ String.prototype.replace()\r\n+ String.prototype.slice()\r\n+ String.prototype.split()\r\n+ String.prototype.substring()\r\n+ String.prototype.padStart()\r\n+ String.prototype.padEnd()\r\n+ String.prototype.search()\r\n+ String.prototype.match()\r\n+ String.prototype.toLowerCase()\r\n+ String.prototype.toUpperCase()\r\n\r\n## Array\r\n\r\n+ Array.isArray()\r\n+ Array.from()\r\n  + 如何生成 `[0, 1, 2, ..., 99]` 的数组\r\n+ Array.of()\r\n+ Array.prototype.slice()\r\n+ Array.prototype.splice()\r\n+ Array.prototype.sort()\r\n+ Array.prototype.reverse()\r\n+ Array.prototype.indexOf\r\n+ Array.prototype.lastIndexOf()\r\n+ Array.prototype.includes()\r\n+ Array.prototype.push()\r\n+ Array.prototype.pop()\r\n+ Array.prototype.shift()\r\n+ Array.prototype.unshift()\r\n  + 如何给数组首项添加元素\r\n+ Array.prototype.map()\r\n+ Array.prototype.reduce()\r\n+ Array.prototype.forEach()\r\n+ Array.prototype.filter()\r\n+ Array.prototype.every()\r\n+ Array.prototype.some()\r\n+ Array.prototype.flat()\r\n+ Array.prototype.flatMap()\r\n+ Array.prototype.toString()\r\n\r\n## Object\r\n\r\n+ Object.create()\r\n+ Object.assign()\r\n+ Object.defineProperties()\r\n+ Object.defineProperty()\r\n+ Object.keys()\r\n+ Object.values()\r\n+ Object.entries()\r\n+ Object.fromEntries()\r\n+ Object.is()\r\n\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MzY4NTIyNTc=",
    "number": 637,
    "title": "【Q619】使用 JS 如何生成一个随机字符串",
    "body": "`random` 接收一个整数作为随机数的个数，最多生成8个随机数\r\n\r\n``` js\r\n// 'a839ac'\r\nrandom(6)\r\n\r\n// '8abc'\r\nrandom(4)\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg3Mzk0ODQ1Mg==",
      "body": "``` js\r\nconst random = (n) => Math.random().toString(36).slice(2, 2 + n)\r\n\r\nrandom()\r\n// => \"c1gdm2\"\r\nrandom()\r\n// => \"oir5pp\"\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MzcwMDEwMDE=",
    "number": 638,
    "title": "【Q620】CSS 有哪些选择器",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg3NDA0Njc4Nw==",
      "body": "+ `:hover`\r\n+ `:active`\r\n+ `:first-child`\r\n+ `:last-child`\r\n+ `:nth-child`\r\n+ `:first-of-type`\r\n+ `:last-of-type`\r\n+ `:nth-of-type`\r\n+ `:empty`\r\n+ `:check`\r\n+ `:disable`",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5MzcwMTI2NDY=",
    "number": 639,
    "title": "【Q621】CSS 有哪些伪类与伪元素选择器",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg3NDA1MjY0NA==",
      "body": "[CSS 选择器 - MDN](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Selectors)\r\n\r\n## 伪元素\r\n\r\n+ `::before`\r\n+ `::after`\r\n+ `::selection`\r\n+ `::placeholder`\r\n+ `::marker`\r\n\r\n## 伪类\r\n\r\n+ `:hover`\r\n+ `:first-child`\r\n+ `:last-child`\r\n+ `:nth-child`",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5Mzg0Mzc0Nzk=",
    "number": 640,
    "title": "【Q622】Number.isNaN 与 globalThis.isNaN 有何区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg3NTI1NzkzMQ==",
      "body": "``` js\r\nNumber.isNaN(NaN)\r\nisNaN(NaN)\r\n\r\nNumber.isNaN('NaN')\r\nisNaN('NaN')\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5Mzg0NDE3Mjc=",
    "number": 641,
    "title": "【Q623】如何判断一个数值为整数",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg3NTI0Mzk5MA==",
      "body": "``` js\r\n// ES6\r\nNumber.isInteger(num);\r\n\r\n// ES5\r\nif (!Number.isInteger) {\r\n  Number.isInteger = function(num) {\r\n    return typeof num == \"number\" && num % 1 == 0;\r\n  };\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5Mzg2OTg4OTI=",
    "number": 642,
    "title": "【Q624】同一页面三个组件请求同一个 API 发送了三次请求，如何优化",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      },
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg3NTQ2Mzg0Mw==",
      "body": "``` js\r\nconst fetchUser = (id) => {\r\n  return new Promise(resolve => {\r\n    setTimeout(() => {\r\n      console.log('Fetch: ', id)\r\n      resolve(id)\r\n    }, 5000)\r\n  })\r\n}\r\n\r\nconst cache = {}\r\nconst cacheFetchUser = (id) => {\r\n  if (cache[id]) {\r\n    return cache[id]\r\n  }\r\n  cache[id] = fetchUser(id)\r\n  return cache[id]\r\n}\r\n```\r\n\r\n``` js\r\ncacheFetchUser(3).then((id) => console.log(id))\r\ncacheFetchUser(3).then((id) => console.log(id))\r\ncacheFetchUser(3).then((id) => console.log(id))\r\n\r\n// Fetch:  3\r\n​// 3\r\n​// 3\r\n​// 3 \r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5Mzk0MTgyMTg=",
    "number": 643,
    "title": "【Q625】简述 koa 的中间件原理，手写 koa-compose 代码",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      },
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs40k4fS",
      "body": "``` js\r\nfunction compose (middlewares) {\r\n  return ctx => {\r\n    const dispatch = (i) => {\r\n      const middleware = middlewares[i]\r\n      if (i === middlewares.length) {\r\n        return\r\n      }\r\n      return middleware(ctx, () => dispatch(i+1))\r\n    }\r\n    return dispatch(0)\r\n  }\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5Mzk0MjQzODE=",
    "number": 644,
    "title": "【Q626】如何压缩前端项目中 JS 的体积",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
        "name": "webpack"
      },
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      },
      {
        "id": "MDU6TGFiZWwzMDkwODMwMjI5",
        "name": "perf"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg3NjEwMzQ0MQ==",
      "body": "1. [terser](https://github.com/terser/terser) 或者 [uglify](https://github.com/mishoo/UglifyJS)，及流行的使用 Rust 编写的 `swc` 压缩混淆化 JS。\r\n2. `gzip` 或者 `brotli` 压缩，在网关处(nginx)开启\r\n3. 使用 `webpack-bundle-analyzer` 分析打包体积，替换占用较大体积的库，如 `moment` -> `dayjs`\r\n4. 使用支持 Tree-Shaking 的库，对无引用的库或函数进行删除，如 `lodash` -> `lodash/es`\r\n5. 对无法 Tree Shaking 的库，进行按需引入模块，如使用 `import Button from 'antd/lib/Button'`，此处可手写 `babel-plugin` 自动完成，但不推荐\r\n6. 使用 babel (css 为 postcss) 时采用 `browserlist`，越先进的浏览器所需要的 polyfill 越少，体积更小\r\n7. code spliting，路由懒加载，只加载当前路由的包，按需加载其余的 chunk，首页 JS 体积变小 (PS: 次条不减小总体积，但减小首页体积)\r\n8. 使用 webpack 的 splitChunksPlugin，把运行时、被引用多次的库进行分包，在分包时要注意避免某一个库被多次引用多次打包。此时分为多个 chunk，虽不能把总体积变小，但可提高加载性能 (PS: 此条不减小总体积，但可提升加载性能)",
      "star": {
        "totalCount": 1
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5Mzk0NDU1ODg=",
    "number": 645,
    "title": "【Q627】如何优化 React 项目的性能",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      },
      {
        "id": "MDU6TGFiZWwzMDkwODMwMjI5",
        "name": "perf"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg3NjExMjMyNg==",
      "body": "1. 避免不必要的渲染，shouldComponentUpdate、React.memo、React.useMemo、React.useCallback。\r\n2. 代码分割，React.lazy 动态加载组件\r\n3. 使用 `react-query`，对请求响应进行缓存、重发等，避免多次请求，减少网络 IO 消耗及优化渲染次数\r\n4. 使用 `useDebounce`，对值及事件处理函数进行防抖，避免状态频繁变动，优化渲染次数\r\n5. 使用 `useImmer`",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NDAzODA0MDY=",
    "number": 646,
    "title": "【Q628】实现一个函数 maxBy，根据给定条件找到最大的数组项",
    "body": "类似 `loadash` 如：\r\n\r\n``` js\r\nconst data = [{ value: 6 }, { value: 2 }, { value: 4 }]\r\n\r\n//=> { value: 6 }\r\nmaxBy(data, x => x.value)\r\n```\r\n\r\n面试追问:\r\n\r\n+ 如果最大的项有多个，则多个都返回，如下所示\r\n\r\n``` js\r\nconst data = [{ value: 6 }, { value: 2 }, { value: 4 }, { value: 6 }]\r\n\r\n//=> [{ value: 6 }, { value: 6 }]\r\nmaxBy(data, x => x.value)\r\n```\r\n\r\n相关问题：\r\n\r\n+ [【Q411】如何找到当前页面出现次数最多的HTML标签](https://github.com/shfshanyue/Daily-Question/issues/418)\r\n+ [【Q629】实现一个函数 max，找到数组中最大的一个值/两个值/N个值](https://github.com/shfshanyue/Daily-Question/issues/647)",
    "labels": [
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg3Njg4NzI2Ng==",
      "body": "``` js\r\nconst maxBy = (list, keyBy) => list.reduce((x, y) => keyBy(x) > keyBy(y) ? x : y)\r\n```\r\n\r\n若需要返回多个项，则使用以下代码\r\n\r\n``` js\r\nconst maxBy = (list, keyBy) => {\r\n  return list.slice(1).reduce((acc, x) => {\r\n    if (keyBy(x) > keyBy(acc[0])) {\r\n      return [x]\r\n    }\r\n    if (keyBy(x) === keyBy(acc[0])) {\r\n      return [...acc, x]\r\n    }\r\n    return acc\r\n  }, [list[0]])\r\n}\r\n```",
      "star": {
        "totalCount": 1
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NDAzODU4Nzc=",
    "number": 647,
    "title": "【Q629】实现一个函数 max，找到数组中最大的一个值/两个值/N个值",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg3NzA0OTg3Mg==",
      "body": "求最大的一个值：\r\n\r\n``` js\r\nfunction max (list) {\r\n  if (!list.length) { return 0 }\r\n  return list.reduce((x, y) => x > y ? x : y)\r\n}\r\n```\r\n\r\n求最大的两个值：\r\n\r\n> 代码见 [找出数组中最大的两个值 - codepen](https://codepen.io/shanyue/pen/vYmyYwQ?editors=1010)\r\n\r\n``` js\r\nfunction maxTwo (list) {\r\n  let max = -Infinity, secondMax = -Infinity\r\n  for (const x of list) {\r\n    if (x > max) {\r\n      secondMax = max\r\n      max = x\r\n    } else if (x > secondMax) {\r\n      secondMax = x\r\n    }\r\n  }\r\n  return [max, secondMax]\r\n}\r\n```\r\n\r\n如果求 TopN，可使用大顶堆、小顶堆实现，见另一个问题",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NDA2OTQ3Mjk=",
    "number": 648,
    "title": "【Q630】什么是安全整数，如何判断一个整数是安全整数",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs40mIPX",
      "body": "根据 MDN 的文档描述：<https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger>\r\n\r\n> 一个安全整数是一个符合下面条件的整数：\r\n> \r\n> 1. 可以准确地表示为一个IEEE-754双精度数字,\r\n> 1. 其IEEE-754表示不能是舍入任何其他整数以适应IEEE-754表示的结果。.\r\n\r\n可以使用 `Number.isSafeInteger()` 来判断一个数值是否为安全整数\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NDEzNjI2ODA=",
    "number": 649,
    "title": "【Q631】在 Node 中如何读写文件",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg3NzczNzIyNA==",
      "body": "1. open\r\n2. read\r\n3. close",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NDEzNjc1NjM=",
    "number": 650,
    "title": "【Q632】在 Node 中如何发送请求",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs40iyud",
      "body": "如果使用原生 API，可使用 `http/https` 核心模块\r\n\r\n``` js\r\nconst https = require('https');\r\n\r\nhttps.get('https://icanhazip.com', (res) => {\r\n  console.log('statusCode:', res.statusCode);\r\n  console.log('headers:', res.headers);\r\n  let data = ''\r\n\r\n  res.on('data', (chunk) => {\r\n    data += chunk\r\n  })\r\n\r\n  res.on('end', () => {\r\n    console.log(data)\r\n  })\r\n\r\n}).on('error', (e) => {\r\n  console.error(e);\r\n});\r\n\r\n```\r\n\r\n如果使用第三方库的话，可使用 `axios` 等。\r\n\r\n目前，Node 团队抛弃了核心模块 http/https 从头开发了一个新的 http client，名为 [undeci](https://github.com/nodejs/undici)，将有可能成为以后默认的 http client\r\n\r\n``` js\r\nimport { request } from 'undici'\r\n\r\nconst {\r\n  statusCode,\r\n  headers,\r\n  trailers,\r\n  body\r\n} = await request('http://localhost:3000/foo')\r\n\r\nconsole.log('response received', statusCode)\r\nconsole.log('headers', headers)\r\n\r\nfor await (const data of body) {\r\n  console.log('data', data)\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NDEzNjgyMjc=",
    "number": 651,
    "title": "【Q633】Node 中服务端框架如何解析 http 的请求体 body",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs40p48F",
      "body": "在 Node 服务中，通过 `http.createServer` 接收到的 req 为可读流，对流进行读取数据\r\n\r\n``` js\r\nconst server = http.createServer((req, res) => {\r\n  let body = ''\r\n  req.on('data', chunk => body += chunk)\r\n  req.on('end', () => {\r\n    data = body\r\n    res.end(data)\r\n  })\r\n})\r\n\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NDEzODM2OTk=",
    "number": 652,
    "title": "【Q644】统计字符串中出现次数最多的字符及次数",
    "body": "这是一道大厂面试出现频率超高的编程题\r\n\r\n``` js\r\n//=> ['a', 6]\r\ngetFrequentChar('aaabbaaacc')\r\n\r\n//=> ['a', 3]\r\ngetFrequentChar('aaa')\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg3Nzc1MTg2MQ==",
      "body": "见代码实现: [统计字符串中出现次数最多的字符及次数- codepen](https://codepen.io/shanyue/pen/YzVGjrv?editors=0012)\r\n\r\n``` js\r\nfunction getFrequentChar (str) {\r\n  const dict = {}\r\n  for (const char of str) {\r\n    dict[char] = (dict[char] || 0) + 1\r\n  }\r\n  const maxBy = (list, keyBy) => list.reduce((x, y) => keyBy(x) > keyBy(y) ? x : y)\r\n  return maxBy(Object.entries(dict), x => x[1])\r\n}\r\n```\r\n\r\n以下方案一边进行计数统计一遍进行大小比较，只需要 1 次 `O(n)` 的算法复杂度\r\n\r\n``` js\r\nfunction getFrequentChar2 (str) {\r\n  const dict = {}\r\n  let maxChar = ['', 0]\r\n  for (const char of str) {\r\n    dict[char] = (dict[char] || 0) + 1\r\n    if (dict[char] > maxChar[1]) {\r\n      maxChar = [char, dict[char]]\r\n    }\r\n  }\r\n  return maxChar\r\n}\r\n```",
      "star": {
        "totalCount": 1
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NDEzOTM4MDE=",
    "number": 653,
    "title": "【Q635】请输出 100 以内的菲波那切数列",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg3Nzk0MTE5OQ==",
      "body": "``` js\r\nfunction fib (n) {\r\n  let a = 0, b = 1;\r\n  let r = [0]\r\n  while (b < n) {\r\n    r.push(b);\r\n    [a, b] = [b, a + b];\r\n  }\r\n  return r\r\n}\r\n```",
      "star": {
        "totalCount": 3
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NDE0NTQ0ODA=",
    "number": 654,
    "title": "【Q636】你们项目中使用了哪些依赖/第三方库",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      },
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU5NDIwODQ1ODE=",
    "number": 655,
    "title": "【Q637】如何使用正则匹配一个汉字",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      },
      {
        "id": "MDU6TGFiZWwzMjE2MjE2NDU2",
        "name": "regexp"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs400b1u",
      "body": "`/\\p{Unified_Ideograph}/u`",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "wangjiayan",
        "url": "https://github.com/wangjiayan"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NDIxMDQ4MzI=",
    "number": 656,
    "title": "【Q638】如何把字符串全部转化为小写格式",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg3OTUxNjIzNQ==",
      "body": "```js\r\nconst convert = str => str.replace(/[A-Z]/g, l => l.toLowerCase())\r\n\r\n// test\r\nconvert('aCd')\r\nconvert('aCd123')\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "cyio",
        "url": "https://github.com/cyio"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NDUyNjk2ODM=",
    "number": 657,
    "title": "【Q639】HTTP 与 TCP 中的 keep-alive 各是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
        "name": "network"
      },
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU5NDUyODcwNzk=",
    "number": 658,
    "title": "【Q640】如何实现数组函数 reduce",
    "body": "满足以下两个测试用例\r\n\r\n``` js\r\n// => 55\r\nreduce([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], (x, y) => x + y)\r\n\r\n// => 155\r\nreduce([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], (x, y) => x + y, 100)\r\n\r\n// => NaN\r\nreduce([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], (x, y) => x + y, undefined)\r\n```\r\n\r\n以下有一个特殊的测试用例，**可考虑，可不考虑**\r\n\r\n``` js\r\n// 在 lodash 中为 NaN\r\n// 在原生API 中为 15\r\nreduce([1, 2, 3, 4, 5,,,,,,,,,,,], (x, y) => x + y)\r\n```\r\n\r\nTC39 规范在此: <https://tc39.es/ecma262/#sec-array.prototype.reduce>。可参考标准，但无需按照标准实现。",
    "labels": [
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg4MDYyMjI2MA==",
      "body": "代码见 [如何实现数组函数 reduce](https://codepen.io/shanyue/pen/dyWmLgQ?editors=0012)，可调试与测试用例\r\n\r\n``` js\r\nconst reduce = (list, fn, ...init) => {\r\n  let next = init.length ? init[0] : list[0]\r\n  for (let i = init.length ? 0 : 1; i < list.length; i++) {\r\n    next = fn(next, list[i], i)\r\n  }\r\n  return next\r\n}\r\n```",
      "star": {
        "totalCount": 1
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NDUzOTM5NTk=",
    "number": 659,
    "title": "【Q641】redis 中的哨兵与集群模式各是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjY2OTk3OTM5",
        "name": "redis"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU5NDUzOTcxNjQ=",
    "number": 660,
    "title": "【Q642】在 Node 中流 (stream) 分为几类，有哪些应用场景",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs400DQ8",
      "body": "Node.js 中有四种基本的流类型：\r\n\r\n- Writable: 可以写入数据的流（例如，`fs.createWriteStream()`）。\r\n\r\n- Readable: 可以从中读取数据的流（例如，`fs.createReadStream()`）。\r\n\r\n- Duplex: Readable 和 Writable 的流（例如，`net.Socket`）。\r\n\r\n- Transform: 可以在写入和读取数据时修改或转换数据的 Duplex 流（例如，`zlib.createDeflate()`）",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "haotie1990",
        "url": "https://github.com/haotie1990"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NDU1MzI3OTk=",
    "number": 661,
    "title": "【Q643】如何实现 chunk 函数，数组进行分组",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs40hz5T",
      "body": "``` js\r\nfunction chunk (list, size) {\r\n  const l = []\r\n  for (let i = 0; i < list.length; i++ ) {\r\n    const index = Math.floor(i / size)\r\n    l[index] ??= [];\r\n    l[index].push(list[i])\r\n  }\r\n  return l\r\n}\r\n\r\n```",
      "star": {
        "totalCount": 2
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NDU1MzU2OTk=",
    "number": 662,
    "title": "【Q644】实现一个异步的 sum/add",
    "body": "> 这是一道字节跳动的面试题目，见面经 [某银行前端一年半经验进字节面经](https://juejin.cn/post/6959364219162607630)。山月认为这也是一道水平较高的题目，promise 串行，并行，二分，并发控制，层层递进。\r\n\r\n请实现以下 sum 函数，只能调用 add 进行实现\r\n\r\n``` js\r\n/*\r\n  请实现一个 sum 函数，接收一个数组 arr 进行累加，并且只能使用add异步方法\r\n  \r\n  add 函数已实现，模拟异步请求后端返回一个相加后的值\r\n*/\r\nfunction add(a, b) {\r\n  return Promise.resolve(a + b);\r\n}\r\n\r\nfunction sum(arr) {\r\n  \r\n}\r\n```\r\n\r\n**追加问题：如何控制 add 异步请求的并发次数**\r\n\r\n相关问题：\r\n\r\n+ [【Q088】如何实现 promise.map，限制 promise 并发数](https://github.com/shfshanyue/Daily-Question/issues/89)\r\n+ [【Q643】如何实现 chunk 函数，数组进行分组](https://github.com/shfshanyue/Daily-Question/issues/661)",
    "labels": [
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDg4MDgzOTAyMA==",
      "body": "\r\n```js\r\n!async function () {\r\n        function add(a, b) {\r\n            // return new Promise((resolve)=>{\r\n            //     setTimeout(()=>{\r\n            //         resolve(a+b)\r\n            //     },1000)\r\n            // })\r\n            return Promise.resolve(a + b)\r\n        }\r\n        async function changeArr(arr) {//两两相加转化为新数组\r\n            let reArr = []\r\n            for (let i = 0; i < arr.length; i += 2) {\r\n                if (arr[i + 1] === undefined) {//如果是奇数个数组,只把最后一个push进去\r\n                    reArr.push(Promise.resolve(arr[i]))\r\n                } else {\r\n                    reArr.push(add(arr[i], arr[i + 1]))\r\n                }\r\n            }\r\n            return await Promise.all(reArr)\r\n        }\r\n        async function sum(arr) {\r\n            if (arr.length < 2) {//数组长度小于2\r\n                return arr[0]\r\n            }\r\n            let result = await changeArr(arr)//处理数组,两两相加转化为新数组\r\n            if (result.length < 2) {//递归结束条件\r\n                return result[0]\r\n            } else {\r\n                return sum(result)//递归两两相加\r\n            }\r\n        }\r\n        const r = await sum([2,2,2,2,2])\r\n        console.log(r)\r\n    }()\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "mtt3366",
        "url": "https://github.com/mtt3366"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NDYxMDUyNTA=",
    "number": 663,
    "title": "【Q645】随机生成六位数的手机验证码(重复/不可重复)",
    "body": "> 字节跳动面经一道面试题，见 <https://juejin.cn/post/6959364219162607630>\r\n\r\n相关题目:\r\n\r\n+ [【Q447】如何实现一个数组洗牌函数 shuffle](https://github.com/shfshanyue/Daily-Question/issues/455)",
    "labels": [
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs40h7GW",
      "body": "``` js\r\nconst random = n => Math.floor(Math.random() * (n + 1))\r\n\r\n// 可生成重复的随机验证码\r\nfunction randomCode () {\r\n  return [0, 0, 0, 0, 0, 0].map(() => random(9))\r\n}\r\n\r\n// 不可生成重复的随机验证码\r\nconst shuffle = (list) => list.sort((x, y) => Math.random() - 0.5)\r\nconst randomUniqueCode = () => shuffle([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]).slice(0, 6)\r\n\r\n// 一种比较低效的解法\r\nfunction randomUniqueCode2 () {\r\n  let i = 0;\r\n  let l = []\r\n  while (i < 6) {\r\n    const x = random(9)\r\n    if (!l.includes(x)) {\r\n      i++;\r\n      l.push(x)\r\n    }\r\n  }\r\n  return l\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NDYxNzIyNjU=",
    "number": 664,
    "title": "【Q646】如何禁止打开浏览器控制台",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      },
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs40mIX-",
      "body": "> https://github.com/AEPKILL/devtools-detector",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NDYzNDcxMzk=",
    "number": 665,
    "title": "【Q647】Array 中那些 API 可改变自身",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU5NDYzNjY0Njc=",
    "number": 666,
    "title": "【Q648】如何把一个数组 Array 转化为迭代器 Iterable",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs40iykK",
      "body": "``` js\r\nconst list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\r\n\r\nconst it = list[Symbol.iterator]()\r\n\r\nit.next()\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NDYzNzg0Nzc=",
    "number": 667,
    "title": "【Q649】如何去除字符串首尾空白字符",
    "body": "实现一个 trim 函数，如同原生的 `Array.prototype.trim`，以下有两个测试用例\r\n\r\n``` js\r\n//=> hello\r\n'    hello   '.trim()\r\n\r\n//=> hello\r\n'    hello   \\t\\n'.trim()\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs40kxXR",
      "body": "在正则表达式中，`\\s` 指匹配一个空白字符，包括空格、制表符、换页符和换行符。等价于`[ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]`。\r\n\r\n``` js\r\nconst trim = str => str.trim || str.replace(/^\\s+|\\s+$/g, '')\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NDY3MjIwMDU=",
    "number": 668,
    "title": "【Q650】http 各个版本间各有什么改进",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU5NDY3ODIzNzM=",
    "number": 669,
    "title": "【Q651】简述 http3，http3 解决了什么问题",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs40kfk5",
      "body": "http3是基于UDP协议的。\r\n它主要解决了http1.1和http2都存在的队头阻塞，TCP和TLS的握手时延问题。",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "mingshengxiao",
        "url": "https://github.com/mingshengxiao"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NDY3ODI2MDA=",
    "number": 670,
    "title": "【Q652】http2 中 Stream 与 Frame 是什么关系",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs40ke7P",
      "body": "+ Stream 为 Request/Response 报文的双向通道，一个完整资源的请求与相应是一个 stream，特殊的 stream 作为 Settings、Window_Update 等 Frame 发送的通道\r\n+ Frame 为 http2 通信的最小单位，有 Data、Headers 等，一个 Stream 包含多个 Frame，如一条 http 请求包含 Header、Data Frame 等\r\n\r\n![](https://cdn.jsdelivr.net/gh/shfshanyue/assets@master/20210619/image.yf6of3e60w0.png)\r\n\r\n![image](https://developers.google.com/web/fundamentals/performance/http2/images/streams_messages_frames01.svg)",
      "star": {
        "totalCount": 2
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NDY5OTE1MDM=",
    "number": 671,
    "title": "【Q653】useLayoutEffect 和 useEffect 有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs40pffc",
      "body": "TODO",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NDcwMjU0ODg=",
    "number": 672,
    "title": "【Q654】css加载会阻塞DOM树的解析和渲染吗",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs40pey9",
      "body": "TODO",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NDcwMjc2NTM=",
    "number": 673,
    "title": "【Q655】实现 intersection，取数组交集",
    "body": "类似 `lodash.intersection`，有以下测试用例\r\n\r\n``` js\r\n//=> [2]\r\nintersection([2, 1], [2, 3]);\r\n\r\n//=> [1, 2]\r\nintersection([1, 2, 2], [1, 2, 2])\r\n\r\n//=> [1, 2]\r\nintersection([1, 2, 2], [1, 2, 2], [1, 2])\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs40kwmz",
      "body": "``` js\r\nconst intersection = (...list) => {\r\n  const result = list.reduce((x, y) => x.filter(i => y.includes(i)))\r\n  return [...new Set(result)]\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NDcwNjMwNTI=",
    "number": 674,
    "title": "【Q656】JS 中如何实现 call/apply",
    "body": "在 JS 中如何实现 call/apply?\r\n\r\n相关问题:\r\n\r\n+ [【Q033】如何实现一个 bind](https://github.com/shfshanyue/Daily-Question/issues/32)\r\n+ [【Q034】如何实现一个 softbind](https://github.com/shfshanyue/Daily-Question/issues/33)",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs40ljJ3",
      "body": "``` js\r\nconst call = (fn, thisObj, ...args) => {\r\n  thisObj.fn = fn;\r\n  const r = thisObj.fn(...args);\r\n  delete thisObj.fn; \r\n  return r;\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NDcyMTEzOTc=",
    "number": 675,
    "title": "【Q657】实现一个 composeLeft/flow(从左向右) 函数，进行函数合成",
    "body": "实现一个 composeLeft/flow(从左向右) 函数，进行函数合成，类似于 `lodash.flow`\r\n\r\n\r\n``` js\r\nconst add10 = x => x + 10\r\nconst mul10 = x => x * 10\r\nconst add100 = x => x + 100\r\n\r\n// (10 + 10) * 10 + 100 = 300\r\nflow(add10, mul10, add100)(10)\r\n```\r\n\r\n相关问题: [【Q181】如何实现 compose 函数，进行函数合成](https://github.com/shfshanyue/Daily-Question/issues/182)",
    "labels": [
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs40lV9e",
      "body": "// 我这个好理解，不够优雅\r\n```\r\nfunction compose(fn){\r\n    let args = [].slice.call(arguments)\r\n    return function(){\r\n        let sum = 0\r\n        let params = [].slice.call(arguments)[0]\r\n        for(let i = 0; i< args.length; i++){\r\n            let f = args[i]\r\n            sum += f(params)\r\n        }\r\n        return sum;\r\n    }\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "ovarte",
        "url": "https://github.com/ovarte"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NDczMTQxMTU=",
    "number": 676,
    "title": "【Q658】什么是点击劫持(ClickJacking)，如何预防",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs40lo7K",
      "body": "可以使用 HTTP X-Frame-Options 响应头以及 `CSP: frame-ancestors` 指令，避免**自己网站被当做 iframe 嵌入到非法网站引导用户点击**\r\n\r\n``` bash\r\nX-Frame-Options: DENY\r\nX-Frame-Options: SAMEORIGIN\r\n```\r\n\r\n或者使用 CSP 的指令 `frame-ancestors` 进行预防\r\n\r\n```bash\r\nContent-Security-Policy: frame-ancestors 'none';\r\nContent-Security-Policy: frame-ancestors 'self' https://www.example.org;\r\n```\r\n\r\n同时，也可以使用 Javascript 进行控制，当发现自身网站置于 iframe 中时，将不予展现\r\n\r\n```html\r\n<head>\r\n</head>\r\n<body>\r\n  <script>\r\n    // 如果发现现在是在 iframe 中\r\n    if (self !== top) {\r\n      document.write('')\r\n    }\r\n  </script>\r\n</body>\r\n```",
      "star": {
        "totalCount": 2
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NDc2MjM2OTc=",
    "number": 677,
    "title": "【Q659】在 React Hooks 中实现 usePreviouseValue 取上次渲染的值",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs40oWrx",
      "body": "TODO",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NDc2ODc1MjU=",
    "number": 678,
    "title": "【Q660】实现一个 render/template 函数，可以用以渲染模板",
    "body": "``` js\r\nconst template = '{{ user[\"name\"] }}，今天你又学习了吗 - 用户ID: {{ user.id }}';\r\n\r\nconst data = {\r\n  user: {\r\n    id: 10086,\r\n    name: '山月',\r\n  }\r\n};\r\n\r\n//=> \"山月，今天你又学习了吗 - 用户ID: 10086\"\r\nrender(template, data); \r\n```\r\n\r\n注意:\r\n\r\n1. 注意深层嵌套数据\r\n2. 注意 `user['name']` 属性\r\n\r\n> 关于复杂的模板编译解析执行，可参考 [mustache](https://github.com/janl/mustache.js) 与 [handlebars.js](https://github.com/handlebars-lang/handlebars.js)",
    "labels": [
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      },
      {
        "id": "MDU6TGFiZWwzMjE2MjE2NDU2",
        "name": "regexp"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs40mw7C",
      "body": "代码可见 [实现一个 render/template 函数，可以用以渲染模板 - codepen](https://codepen.io/shanyue/pen/yLboJQE?editors=0012)\r\n\r\n``` js\r\nfunction get (source, path, defaultValue = undefined) {\r\n  // a[3].b -> a.3.b -> [a, 3, b]\r\n  const paths = path.replace(/\\[(\\w+)\\]/g, '.$1').replace(/\\[\"(\\w+)\"\\]/g, '.$1').replace(/\\['(\\w+)'\\]/g, '.$1').split('.')\r\n  let result = source\r\n  for (const p of paths) {\r\n    result = result?.[p]\r\n  }\r\n  return result === undefined ? defaultValue : result \r\n}\r\n\r\nfunction render (template, data)  {\r\n  return template.replace(/{{\\s+([^\\s]+)\\s+}}/g, (capture, key) => {\r\n    return get(data, key)\r\n  })\r\n}\r\n```",
      "star": {
        "totalCount": 3
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NDkzODQzMTY=",
    "number": 679,
    "title": "【Q661】Number 中最大数、最大安全整数、EPSILON 都是多少，原理是什么",
    "body": "可参考 IEEE754 规范",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs40r88b",
      "body": "> https://zh.wikipedia.org/zh-cn/%E9%9B%99%E7%B2%BE%E5%BA%A6%E6%B5%AE%E9%BB%9E%E6%95%B8\r\n\r\n![](https://upload.wikimedia.org/wikipedia/commons/7/76/General_double_precision_float.png)",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NDk3MTYxOTA=",
    "number": 680,
    "title": "【Q662】TCP 是如何进行拥塞控制的",
    "body": "可参考文章: <https://zhuanlan.zhihu.com/p/76023663>",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMzA5NzM0Njk0",
        "name": "tcp"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs40s8PD",
      "body": "TODO",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NDk3NjI5Mzk=",
    "number": 681,
    "title": "【Q663】给定一个数值，给出它在 IEEE754 的表示，如符号位、指数位与分数位",
    "body": "相关问题：\r\n\r\n+ [【Q661】Number 中最大数、最大安全整数、EPSILON 都是多少，原理是什么](https://github.com/shfshanyue/Daily-Question/issues/679)",
    "labels": [
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs40tEqY",
      "body": "代码见: [给定一个数值，给出它在 IEEE754 的表示，如符号位、指数位与分数位 - codepen](https://codepen.io/shanyue/pen/abWLooZ)\r\n\r\n``` js\r\nfunction formatToBinaryExponent (num) {\r\n  const [int, dec] = String(num).split(/(?=\\.)/).map(x => Number(x).toString(2))\r\n  const exponent = (int.length - 1).toString(2)\r\n  const fraction = int.slice(1) + dec.slice(2)\r\n  return {\r\n    exponent,\r\n    fraction: fraction.slice(0, 52),\r\n    sign: num > 0,\r\n    exact: fraction.length < 52,\r\n  }\r\n}\r\n\r\nconsole.log(formatToBinaryExponent(13.5))\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NTA0NTAyNjU=",
    "number": 682,
    "title": "【Q664】请简述下 Node 与浏览器环境中的事件循环",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs40vG0M",
      "body": "TODO",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NTA1MjA2Nzk=",
    "number": 683,
    "title": "【Q665】JS 如何检测到对象中有循环引用",
    "body": "示例，如下数据为循环结构/循环引用\r\n\r\n``` js\r\nconst user = { id: 10086, name: '山月' }\r\nuser._user = user\r\n```\r\n\r\n追问:\r\n\r\n1. 由于 `JSON.stringify` 序列化对象时，将跳过不枚举的 key，因此此时可不考虑不可枚举的 key\r\n2. 如果考虑不可枚举 key 与 Symbol 如何处理",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs40vTW0",
      "body": "TODO",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NTA3MjEwODA=",
    "number": 684,
    "title": "【Q666】实现二进制与十进制的互相转化的两个函数",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs40wEiQ",
      "body": "代码见：[实现二进制与十进制的互相转化的两个函数](https://codepen.io/shanyue/pen/GRmMQgy)\r\n\r\n``` js\r\nfunction integerToBin (num) {\r\n  // 64\r\n  const result = []\r\n  while (num / 2) {\r\n    next = num % 2\r\n    num = Math.floor(num / 2)\r\n    result.unshift(next)\r\n  }\r\n  return result\r\n}\r\n\r\nfunction fractionalToBin (num) {\r\n  const result = []\r\n  let i = 0\r\n  while (num !== 0 && i < 54) {\r\n    num = num * 2\r\n    \r\n    next = num >= 1 ? 1 : 0\r\n    num = num % 1\r\n    i++\r\n    result.push(next)\r\n  }\r\n  return result\r\n}\r\n\r\nfunction decToBinary (num) {\r\n  // 1.5\r\n  const [int, fraction] = String(num).split(/(?=\\.)/).map((x, i) => {\r\n    return i === 0 ? integerToBin(x) : fractionalToBin(x)\r\n  })\r\n  return [int, fraction]\r\n}\r\n\r\nfunction binToDec (num) {\r\n  const [_int, _fraction] = String(num).split('.')\r\n  const int = _int.split('').reduceRight((acc, x, i) => {\r\n    return acc + x * 2 ** i\r\n  }, 0)\r\n  const fraction = _fraction ? _fraction.split('').reduce((acc, x, i) => {\r\n    return acc + x * 2 ** -(i + 1)\r\n  }, 0) : 0\r\n  return `${int}${fraction ? '.' + fraction.toString().slice(2) : ''}`\r\n}\r\n\r\nconsole.log(16, integerToBin(16), Number(16).toString(2))\r\nconsole.log(18, integerToBin(18), Number(18).toString(2))\r\nconsole.log(0.5, fractionalToBin(0.5), Number(0.5).toString(2))\r\nconsole.log(0.1, fractionalToBin(0.1), Number(0.1).toString(2))\r\nconsole.log(1.1, decToBinary(1.1), Number(1.1).toString(2))\r\n\r\nconsole.log(7.875, decToBinary(7.875), Number(7.875).toString(2))\r\nconsole.log('111.111', binToDec('111.111'), parseInt('111.111', 2))\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NTEyNDMyOTQ=",
    "number": 685,
    "title": "【Q667】简述下 WebWorker，它如何进行通信",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs407aTv",
      "body": "TODO",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NTEzMzYxNjk=",
    "number": 686,
    "title": "【Q668】JS 中异步任务为何分为微任务与宏任务",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs40xxcd",
      "body": "TODO",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NTEzNDM2NzY=",
    "number": 687,
    "title": "【Q669】在 CSS 中，使用 rem 作为单位有何缺点",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs40xzyq",
      "body": "1.a11y可访问性不友好,不跟随系统字体\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "illumi520",
        "url": "https://github.com/illumi520"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NTEzNTIwNDE=",
    "number": 688,
    "title": "【Q670】如何提高首屏渲染时间？",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      },
      {
        "id": "MDU6TGFiZWwzMDkwODMwMjI5",
        "name": "perf"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs40x0ss",
      "body": "TODO",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NTE1MTgzOTM=",
    "number": 689,
    "title": "【Q671】浏览器中监听事件函数 addEventListener 第三个参数有那些值",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs40z1gY",
      "body": "- capture。监听器会在时间捕获阶段传播到event.target时触发。\r\n- passive。监听器不会调用preventDefault()。\r\n- once。监听器只会执行一次，执行后移除。\r\n- singal。调用abort()移除监听器。",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "buzuosheng",
        "url": "https://github.com/buzuosheng"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NTE2MDQ3NzI=",
    "number": 690,
    "title": "【Q672】什么是原码、补码与反码",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
        "name": "os"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs40yhpe",
      "body": "+ 原码:\r\n+ 反码: 反码按位取反\r\n+ 补码: 正数和0的补码就是该数字本身，负数的补码则是反码加一\r\n## 补码\r\n\r\n| 符 |   |   |   |   |   |   |   |   |      |\r\n|-----|---|---|---|---|---|---|---|---|------|\r\n| 0   | 1 | 1 | 1 | 1 | 1 | 1 | 1 | = | 127  |\r\n| 0   | 0 | 0 | 0 | 0 | 0 | 1 | 0 | = | 2    |\r\n| 0   | 0 | 0 | 0 | 0 | 0 | 0 | 1 | = | 1    |\r\n| 0   | 0 | 0 | 0 | 0 | 0 | 0 | 0 | = | 0    |\r\n| 1   | 1 | 1 | 1 | 1 | 1 | 1 | 1 | = | −1   |\r\n| 1   | 1 | 1 | 1 | 1 | 1 | 1 | 0 | = | −2   |\r\n| 1   | 0 | 0 | 0 | 0 | 0 | 0 | 1 | = | −127 |\r\n| 1   | 0 | 0 | 0 | 0 | 0 | 0 | 0 | = | −128 |\r\n",
      "star": {
        "totalCount": 3
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NTIyMzYwMDY=",
    "number": 692,
    "title": "【Q673】求给定数组中 N 个数相加之和为 sum 所有可能集合",
    "body": "求给定数组中 N 个数相加之和为 sum 所有可能集合，请补充以下代码\r\n\r\n``` js\r\nfunction fn(arr, n, sum) {}\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
        "name": "algorithm"
      },
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs400fNx",
      "body": "TODO",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NTQwMDU0Mzk=",
    "number": 693,
    "title": "【Q674】在 Node 中如何读取可读流的内容",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs407ion",
      "body": "fs.createReadStream吗，有人知道了踢我一下",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "Asarua",
        "url": "https://github.com/Asarua"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NTU4OTQ2Mjg=",
    "number": 694,
    "title": "【Q675】浏览器中 Frame 与 Event Loop 的关系是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs40_-nU",
      "body": "TODO",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NTY1NTczMzA=",
    "number": 695,
    "title": "【Q676】在 Typescript 中如何实现类型标记 Pick 与 Omit",
    "body": "有以下测试用例\r\n\r\n``` ts\r\ninterface User {\r\n  id: number;\r\n  age: number;\r\n  name: string;\r\n};\r\n\r\n// 相当于: type PickUser = { age: number; name: string; }\r\ntype OmitUser = Omit<User, \"id\">\r\n\r\n// 相当于: type PickUser = { id: number; age: number; }\r\ntype PickUser = Pick<User, \"id\" | \"age\">\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwzMjEzODUzNTU2",
        "name": "ts"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs41CI6L",
      "body": "``` ts\r\ntype Pick<T, K extends keyof T> = {\r\n  [P in K]: T[P];\r\n};\r\n\r\ntype Exclude<T, U> = T extends U ? never : T;\r\n\r\ntype Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;\r\n```\r\n\r\n``` ts\r\ninterface User {\r\n  id: number;\r\n  age: number;\r\n  name: string;\r\n};\r\n\r\n// 相当于: type PickUser = { age: number; name: string; }\r\ntype OmitUser = Omit<User, \"id\">\r\n\r\n// 相当于: type PickUser = { id: number; age: number; }\r\ntype PickUser = Pick<User, \"id\" | \"age\">\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NTY3MzQ1MDI=",
    "number": 696,
    "title": "【Q677】如何实现一个 sampleSize 函数，从数组中随机取N个元素 ",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs41CpgO",
      "body": "``` js\r\nconst shuffle = (list) => list.sort((x, y) => Math.random() - 0.5)\r\nconst sampleSize = (list, n) => shuffle(list).slice(0, n)\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NTY3NDU0NTg=",
    "number": 697,
    "title": "【Q678】实现一个函数 keyBy",
    "body": "类似 [lodash.keyBy](https://lodash.com/docs/4.17.15#keyBy)，这里仅仅考虑第二个参数为函数的情况\r\n\r\n``` js\r\n// Output: {\r\n//   \"1\": {\r\n//     \"id\": 1,\r\n//     \"name\": \"山月\"\r\n//   },\r\n//   \"2\": {\r\n//     \"id\": 2,\r\n//     \"name\": \"shanyue\"\r\n//   }\r\n// }\r\nkeyBy([{ id: 1, name: '山月' }, { id: 2, name: 'shanyue' }], x => x.id)\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs41C-no",
      "body": "``` js\r\nfunction keyBy (list, by) {\r\n  return list.reduce((acc, x) => {\r\n    acc[by(x)] = x \r\n    return acc \r\n  }, {})\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NTY3NTI5MDg=",
    "number": 698,
    "title": "【Q679】实现一个函数 groupBy",
    "body": "类似 [lodash.groupBy](https://lodash.com/docs/4.17.15#groupBy)\r\n\r\n``` js\r\ngroupBy([\r\n  { id: 1, name: '山月', sex: 'male' },\r\n  { id: 2, name: '张三', sex: 'female' },\r\n  { id: 3, name: '李四', sex: 'female' }\r\n], x => x.sex)\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs41C-mU",
      "body": "``` js\r\nfunction groupBy (collection, by) {\r\n  return collection.reduce((acc, x) => {\r\n    if (acc[by(x)]) { acc[by(x)].push(x)}\r\n    else { acc[by(x)] = [x] }\r\n    return acc \r\n  }, {})\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NTY4NDM5OTA=",
    "number": 699,
    "title": "【Q680】在 Node 中如何读取大文件的内容",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs41C9YD",
      "body": "``` js\r\nimport { createReadStream } from 'fs';\r\n\r\nconst stream = createReadStream('bigfile.json');\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NTY4NTU5MTI=",
    "number": 700,
    "title": "【Q681】求正序增长的正整数数组中，其和为 N 的两个数",
    "body": "``` js\r\n//=> [5, 10]\r\ntwoSum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 15)\r\n\r\n//=> null\r\ntwoSum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 150)\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
        "name": "algorithm"
      },
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs41C_vA",
      "body": "TODO",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NTY4ODE0NzE=",
    "number": 701,
    "title": "【Q682】100层楼，两个玻璃球，求最少多少次测出能摔碎玻璃球的楼层",
    "body": "给你两个一摸一样的球，这两个球如果从一定的高度掉到地上有可能就会摔碎，当然，如果在这个高度以下往下扔，怎么都不会碎，当然超过这个高度肯定就一定摔碎了。\r\n\r\n现在已知这个恰巧摔碎高度范围在一层楼到100层楼之间。\r\n\r\n如何用最少的试验次数，用这两个玻璃球测试出摔碎的楼高",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
        "name": "algorithm"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs41DD4i",
      "body": "假设最少次数是x次 那么第一个我们从哪里扔呢 ？从x 因为如果碎了 另一个球从1到x 正好就是x\r\n如果没碎这时候我们第一个球第二次只剩x-1次 所以我们从x+x-1层扔 碎了从x+1到x + x-2 遍历\r\n后面逻辑一样 减1去扔第一个球 没碎下次再减1 碎了从上一次的没碎的上一层遍历就好了 \r\n\r\n所以可以一共层数等于x + (x-1) + (x-2) + ... + 1 = 100\r\n\r\n下面我们来解这个这个方程:\r\n\r\n(x+1)*x/2 = 100\r\n\r\n最终x向上取整,得到 x=14\r\n\r\n因此，最优解在最坏情况的尝试次数是14次，第一次扔鸡蛋的楼层也是14层。\r\n\r\n最后，让我们把第一个鸡蛋没碎的情况下，所尝试的楼层数完整列举出来：\r\n\r\n14，27， 39， 50， 60， 69， 77， 84， 90， 95， 99， 100",
      "star": {
        "totalCount": 2
      },
      "author": {
        "login": "heretic-G",
        "url": "https://github.com/heretic-G"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NTcyMDY3MzM=",
    "number": 702,
    "title": "【Q683】FizzBuzz，是否能被3或5整除",
    "body": "输入一个整数，如果能够被3整除，则输出 `Fizz`\r\n\r\n如果能够被5整除，则输出 `Buzz`\r\n\r\n如果既能被3整数，又能被5整除，则输出 `FizzBuzz`\r\n\r\n\r\n``` js\r\n//=> 'fizz'\r\nfizzbuzz(3)\r\n\r\n//=> 'buzz'\r\nfizzbuzz(5)\r\n\r\n//=> 'fizzbuzz'\r\nfizzbuzz(15)\r\n\r\n//=> 7\r\nfizzbuzz(7)\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs41ESbd",
      "body": "``` js\r\nfunction fizzbuzz (n) {\r\n  if (n % 5 === 0 && n % 3 === 0) {\r\n    return 'fizzbuzz'\r\n  } else if (n % 3 === 0) {\r\n    return 'fizz'\r\n  } else if (n % 5 === 0) {\r\n    return 'buzz'\r\n  }\r\n  return n\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NTcyNzA2MDI=",
    "number": 703,
    "title": "【Q684】实现一个函数  camelCase，对变量转化为驼峰命名",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU5NTkxMjI2MzQ=",
    "number": 704,
    "title": "【Q685】如何遍历一个对象",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs41KJDN",
      "body": "TODO",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NTkxMjkxMzk=",
    "number": 705,
    "title": "【Q686】网站性能优化中，如何对小图片进行优化",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwzMDkwODMwMjI5",
        "name": "perf"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs41KKVp",
      "body": "TODO",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NTkyNTQ5MjE=",
    "number": 706,
    "title": "【Q687】https 如何被抓包，原理是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs41KjRg",
      "body": "TODO",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NjE0MzUzNDI=",
    "number": 708,
    "title": "【Q688】setTimeout为什么最小只能设置4ms，如何实现一个0ms的setTimeout?",
    "body": "可参考两篇文章\r\n\r\n1. [为什么 setTimeout 有最小时延 4ms ?](https://juejin.cn/post/6846687590616137742)\r\n2. [如何实现一个0ms的setTimeout?](https://zhuanlan.zhihu.com/p/379637806)\r\n",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs41PJC4",
      "body": "postMessage",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NjMzMzYxMTA=",
    "number": 710,
    "title": "【Q689】JS 中如何原生实现 instanceOf",
    "body": "``` js\r\nfunction fakeInstanceOf (instance, parent): Boolean {}\r\n\r\n//=> true\r\nfakeInstanceOf([], Array)\r\n\r\n//=> true\r\nfakeInstanceOf([], Object)\r\n\r\n//=> true\r\nfakeInstanceOf(x => x, Object)\r\n\r\n//=> false\r\nfakeInstanceOf('hello', Object)\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs41VIOs",
      "body": "``` js\r\nfunction fakeInstanceOf (instance, parent) {\r\n  if (typeof(instance) !== 'object' && typeof(instance) !== 'function') {\r\n    return false\r\n  }\r\n  let proto = instance?.__proto__ || null\r\n  while (true) {\r\n    if (proto === null) { return false }\r\n    if (proto === parent.prototype) { return true }\r\n    proto = proto.__proto__\r\n  }\r\n}\r\n```",
      "star": {
        "totalCount": 1
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NjMzNTE0Nzk=",
    "number": 711,
    "title": "【Q690】如何根据 random5 随机生成 [0, 5]，生成一个函数 random7？",
    "body": "已知有一个函数 叫做 `random5`，执行这个函数会随机返回 0-5 之间任意一个数，概率相同。\r\n\r\n根据这个 `random5`，实现一个 `random7`，要求执行这个函数后随机返回 0-7 之间任意一个数，概率相同。\r\n\r\n这是一道群友分享的百度面经中的问题。",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
        "name": "algorithm"
      },
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs41YyGQ",
      "body": "https://www.growingwiththeweb.com/2014/03/given-random5-implement-random7.html\r\n看到一题近似的，不过random5和random7 是返回[0, 5]和[0, 7]",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "AaronKwong929",
        "url": "https://github.com/AaronKwong929"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NjM0NDQzMTA=",
    "number": 712,
    "title": "【Q691】如何实现一个 ORM 类似的 find 链式调用",
    "body": "如下代码所示，使用 `find` 函数实现链式调用\r\n\r\n``` js\r\nconst data = [\r\n  {userId: 8, title: 'title1'},\r\n  {userId: 11, title: 'other'},\r\n  {userId: 15, title: null},\r\n  {userId: 19, title: 'title2'}\r\n];\r\n\r\n// 查找data中，符合where中条件的数据，并根据orderBy中的条件进行排序\r\nconst result = find(data).where({\r\n  \"title\": /\\d$/   // 这里意思是过滤出数组中，满足title字段中符合 /\\d$/的项\r\n}).orderBy('userId', 'desc');  // 这里的意思是对数组中的项按照userId进行倒序排列\r\n\r\n//=> 返回 [{ userId: 19, title: 'title2'}, { userId: 8, title: 'title1' }];\r\nconsole.log(result.value); ",
    "labels": [
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs41Vahc",
      "body": "代码见 codepen，[如何实现链式调用](https://codepen.io/shanyue/pen/abWQLZv?editors=0012)\r\n\r\n``` js\r\nfunction find (data) {\r\n  return {\r\n    data,\r\n    where (match) {\r\n      this.data = this.data.filter((item) => {\r\n        return Object.entries(match).every(([key, value]) => {\r\n          if (value instanceof RegExp) {\r\n            return value.test(item[key])\r\n          }\r\n          return item[key] === value\r\n        })\r\n      })\r\n      return this\r\n    },\r\n\r\n    orderBy (key, type) {\r\n      this.data.sort((x, y) => type !== 'desc' ? x[key] - y[key] : y[key] - x[key])\r\n      return this\r\n    }\r\n  }\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NjM2NTUyMzQ=",
    "number": 713,
    "title": "【Q692】什么是协变与逆变",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwzMjEzODUzNTU2",
        "name": "ts"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs41V_pN",
      "body": "> 协变与逆变(Covariance and contravariance )是在计算机科学中，描述具有父/子型别关系的多个型别通过型别构造器、构造出的多个复杂型别之间是否有父/子型别关系的用语。",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NjQ2MzkxMTM=",
    "number": 714,
    "title": "【Q693】在 ts 中如何实现 Partial",
    "body": "实现 `Partial`，使得 Object 所有的属性变为可选属性。\r\n\r\n> PS: `Partial` 已经在 TS 中原生实现，见文档: <https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype>\r\n\r\n``` ts\r\ntype User = {\r\n  id: number;\r\n  age: number;\r\n  name: string;\r\n}\r\n\r\n// Output:\r\n// type PartialUser = {\r\n//   id?: number | undefined;\r\n//   age?: number | undefined;\r\n//   name?: string | undefined;\r\n// }\r\ntype PartialUser = Partial<User>\r\n```\r\n\r\n以下是使用案例\r\n\r\n``` ts\r\ninterface Todo {\r\n  title: string;\r\n  description: string;\r\n}\r\n \r\nfunction updateTodo(todo: Todo, fieldsToUpdate: Partial<Todo>) {\r\n  return { ...todo, ...fieldsToUpdate };\r\n}\r\n \r\nconst todo1 = {\r\n  title: \"organize desk\",\r\n  description: \"clear clutter\",\r\n};\r\n \r\nconst todo2 = updateTodo(todo1, {\r\n  description: \"throw out trash\",\r\n});\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwzMjEzODUzNTU2",
        "name": "ts"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs41ZEcJ",
      "body": "``` ts\r\ntype Partial<T> = {\r\n  [P in keyof T]?: T[P]\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NjQ2NDYxMTE=",
    "number": 715,
    "title": "【Q694】在 ts 中什么是 infer，并实现 Parameters 与 ReturnType",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwzMjEzODUzNTU2",
        "name": "ts"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs41Z7ci",
      "body": "```typescript\r\ntype Parameters<T extends (...args: any[]) => unknown> = T extends (...args: infer R) => unknown ? R : never\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "heretic-G",
        "url": "https://github.com/heretic-G"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NjU3OTA4NDE=",
    "number": 716,
    "title": "【Q695】Flex 布局中的 flex-basis 与 width 有何区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs41bwYZ",
      "body": "1. 当 `flex-direction` 为 `column` 时，主轴为纵轴，此时 `flex-basis` 与 `height` 对应\r\n2. `flex-basis` 的值为理想情况，而在实际情况中可能被压缩",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5Njk4MzEwNTg=",
    "number": 718,
    "title": "【Q696】OSCP Stapling 是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU5NzI3NDU2MTA=",
    "number": 719,
    "title": "【Q697】npm 执行命令传递参数时，为何需要双横线",
    "body": "如在` npm script` 中有以下命令：\r\n\r\n``` js\r\n{\r\n  \"start\": \"serve\"\r\n}\r\n```\r\n\r\n其中 `serve` 可通过 `--port` 指定端口号：\r\n\r\n``` bash\r\n$ npm start -- --port 8080\r\n\r\n# 而在 yarn 时无需传递参数\r\n$ yarn start --port 8080\r\n```\r\n\r\n那为什么 npm 执行命令传递参数时，为何需要双横线",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      },
      {
        "id": "MDU6TGFiZWwyMTA5NjQyNTA2",
        "name": "shell"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs41xQIX",
      "body": "https://github.com/npm/npm/pull/5518\r\nnpm脚本执行时会开启一个shell，执行后面指定的脚本命令或文件， -- 是为了给后面shell脚本命令传递参数，类似node环境的process.argv的吧。",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "iceycc",
        "url": "https://github.com/iceycc"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5NzMyMjM3NTg=",
    "number": 720,
    "title": "【Q698】有没有使用过 Node 的 inspect 这个核心模块",
    "body": "文档：[Node Inspector API](https://nodejs.org/api/inspector.html)\r\n\r\n``` js\r\nconst inspector = require('inspector');\r\n```\r\n",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs41sWTt",
      "body": "``` js\r\n  const session = new inspector.Session()\r\n  session.connect()\r\n  session.post('Profiler.enable', () => {\r\n    session.post('Profiler.start', start)\r\n  })\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5Nzc4NDI1NzM=",
    "number": 721,
    "title": "【Q699】在虚拟 DOM 中进行 diff 算法时，介绍当根据 key 对数组进行重用时的算法",
    "body": "如以下示例，当从上方五个 div 变为下方五个 div 时，由于 diff 算法，无需重复构建 DOM 创建五个新的 div 标签。\r\n\r\n请写出此时重用的算法，并给出时间复杂度\r\n\r\n``` html\r\n<div key=\"1\">Demo 1</div>\r\n<div key=\"2\">Demo 2</div>\r\n<div key=\"3\">Demo 3</div>\r\n<div key=\"4\">Demo 4</div>\r\n<div key=\"5\">Demo 5</div>\r\n\r\n\r\n<div key=\"4\">Demo 4</div>\r\n<div key=\"5\">Demo 5</div>\r\n<div key=\"2\">Demo 2</div>\r\n<div key=\"1\">Demo 1</div>\r\n<div key=\"3\">Demo 3</div>\r\n```\r\n\r\n``` js\r\nfunction updateChildren (element, oldVnodes, newVnodes) {\r\n  \r\n}\r\n```\r\n\r\n## 可参考\r\n\r\n1. [编辑距离](https://leetcode-cn.com/problems/edit-distance/)",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      },
      {
        "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
        "name": "vue"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU5ODAwNzMzNjI=",
    "number": 722,
    "title": "【Q700】http client 中如何得知已接收完所有响应数据",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      },
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU5ODAyMjcyNDY=",
    "number": 723,
    "title": "【Q701】实现函数 promisify，把回调函数改成 promise 形式",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
        "name": "code"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs42DW4M",
      "body": "```javascript\r\nfunction promisify(fn) {\r\n  return function(...args) {\r\n    let hasCb = args.some(v => typeof v === 'function')\r\n    if (hasCb) {\r\n      fn(...args)\r\n    } else {\r\n      return new Promise((resolve, reject) => {\r\n        fn(...args, cb)\r\n\r\n        function cb(err, data) {\r\n          if (err) {\r\n            reject(err)\r\n          } else {\r\n            resolve(data)\r\n          }\r\n        }\r\n      })\r\n    }\r\n  }\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "Asarua",
        "url": "https://github.com/Asarua"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5ODE2Njc4MzE=",
    "number": 724,
    "title": "【Q702】return promise 与 return await promise 有何区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU5ODIzODUwMzM=",
    "number": 725,
    "title": "【Q703】在 ES6 Class 中，super 的过程中做了什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs44yEPo",
      "body": "本质就是call（this）",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "illumi520",
        "url": "https://github.com/illumi520"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU5OTQxNjYwNzg=",
    "number": 727,
    "title": "【Q704】关于 Promise，判断以下代码的输出",
    "body": "``` js\r\nPromise.resolve().then(() => {\r\n  console.log(0)\r\n  return Promise.resolve(4)\r\n}).then(res => {\r\n  console.log(res)\r\n})\r\n\r\nPromise.resolve().then(() => {\r\n  console.log(1)\r\n}).then(() => {\r\n  console.log(2)\r\n}).then(() => {\r\n  console.log(3)\r\n}).then(() => {\r\n  console.log(5)\r\n}).then(() => {\r\n  console.log(6)\r\n})\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs45tW63",
      "body": "0 1 2 3 4 5 6\r\n?",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "okbug",
        "url": "https://github.com/okbug"
      }
    }
  },
  {
    "id": "I_kwDODQzyOs48CaWm",
    "number": 729,
    "title": "【Q705】webpack 的 runtime 做了什么事情",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
        "name": "webpack"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs43RFL_",
      "body": "`webpack` 的 runtime，也就是 webpack 最后生成的代码，做了以下三件事:\r\n\r\n1. `__webpack_modules__`: 维护一个所有模块的数组。将入口模块解析为 AST，根据 AST 深度优先搜索所有的模块，并构建出这个模块数组。每个模块都由一个包裹函数 `(module, module.exports, __webpack_require__)` 对模块进行包裹构成。\r\n2. `__webpack_require__(moduleId)`: 手动实现加载一个模块。对已加载过的模块进行缓存，对胃加载过的模块，执行 id 定位到 `__webpack_modules__` 中的包裹函数，执行并返回 `module.exports`，并缓存\r\n3. `__webpack_require__(0)`: 运行第一个模块，即运行入口模块\r\n\r\n另外，当涉及到多个 chunk 的打包方式中，比如 `code spliting`，webpack 中会有 `jsonp` 加载 chunk 的运行时代码。\r\n\r\n以下是 `webpack runtime` 的最简代码，配置示例可见 [node-examples](https://github.com/shfshanyue/node-examples/blob/master/webpack/cjs/build.js)\r\n\r\n``` js\r\n/******/ var __webpack_modules__ = ([\r\n/* 0 */,\r\n/* 1 */\r\n/***/ ((module) => {\r\n\r\nmodule.exports = (...args) => args.reduce((x, y) => x + y, 0)\r\n\r\n/***/ })\r\n/******/ ]);\r\n/************************************************************************/\r\n/******/ // The module cache\r\n/******/ var __webpack_module_cache__ = {};\r\n/******/ \r\n/******/ // The require function\r\n/******/ function __webpack_require__(moduleId) {\r\n/******/ \t// Check if module is in cache\r\n/******/ \tvar cachedModule = __webpack_module_cache__[moduleId];\r\n/******/ \tif (cachedModule !== undefined) {\r\n/******/ \t\treturn cachedModule.exports;\r\n/******/ \t}\r\n/******/ \t// Create a new module (and put it into the cache)\r\n/******/ \tvar module = __webpack_module_cache__[moduleId] = {\r\n/******/ \t\t// no module.id needed\r\n/******/ \t\t// no module.loaded needed\r\n/******/ \t\texports: {}\r\n/******/ \t};\r\n/******/ \r\n/******/ \t// Execute the module function\r\n/******/ \t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\r\n/******/ \r\n/******/ \t// Return the exports of the module\r\n/******/ \treturn module.exports;\r\n/******/ }\r\n/******/ \r\n/************************************************************************/\r\nvar __webpack_exports__ = {};\r\n// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.\r\n(() => {\r\nconst sum = __webpack_require__(1)\r\n\r\nsum(3, 8)\r\n\r\n})();\r\n```\r\n\r\n对 `webpack runtime` 做进一步的精简，代码如下\r\n\r\n``` js\r\nconst __webpack_modules__ = [() => {}]\r\nconst __webpack_require = id => {\r\n  const module = { exports: {} }\r\n  const m = __webpack_modules__[id](module)\r\n  return module.exports\r\n}\r\n\r\n__webpack_require__(0)\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "I_kwDODQzyOs48doFg",
    "number": 730,
    "title": "【Q706】typescript 中 interface 与 type 有何区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwzMjEzODUzNTU2",
        "name": "ts"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs43m8A5",
      "body": "https://stackoverflow.com/questions/37233735/interfaces-vs-types-in-typescript",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "I_kwDODQzyOs48doXN",
    "number": 731,
    "title": "【Q707】请简述 typescript 中的 infer",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwzMjEzODUzNTU2",
        "name": "ts"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs45tW5l",
      "body": "和returnType有点关联，做返回值推断的",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "okbug",
        "url": "https://github.com/okbug"
      }
    }
  },
  {
    "id": "I_kwDODQzyOs481wLk",
    "number": 733,
    "title": "【Q708】webpack 中的 code spliting 是如何动态加载 chunk 的？",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
        "name": "webpack"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs437rs-",
      "body": "一个 `webpack` 中运行时，包括最重要的两个数据结构：\r\n\r\n1. `__webpack_modules__`: 维护一个所有模块的数组。将入口模块解析为 AST，根据 AST 深度优先搜索所有的模块，并构建出这个模块数组。每个模块都由一个包裹函数 `(module, module.exports, __webpack_require__)` 对模块进行包裹构成。\r\n2. `__webpack_require__(moduleId)`: 手动实现加载一个模块。对已加载过的模块进行缓存，对未加载过的模块，根据 id 定位到 `__webpack_modules__` 中的包裹函数，执行并返回 `module.exports`，并缓存。\r\n\r\n在 webpack 中，通过 `import()` 可实现 code spliting.\r\n\r\n``` js\r\nimport('./sum').then(m => {\r\n  m.default(3, 4)\r\n})\r\n\r\n// 以下为 sum.js 内容\r\nconst sum = (x, y) => x + y\r\nexport default sum\r\n```\r\n\r\n使用 `import()` 加载数据时，以上代码将被 `webpack`  编译为以下代码\r\n\r\n``` js\r\n__webpack_require__.e(/* import() | sum */ 644).then(__webpack_require__.bind(__webpack_require__, 709)).then(m => {\r\n  m.default(3, 4)\r\n})\r\n```\r\n\r\n每一个 `chunk` 的代码如下，以下为 `sum` 函数所构建而成的 chunk:\r\n\r\n``` js\r\n\"use strict\";\r\n(self[\"webpackChunk\"] = self[\"webpackChunk\"] || []).push([[644],{\r\n\r\n/***/ 709:\r\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\r\n\r\n        __webpack_require__.r(__webpack_exports__);\r\n        /* harmony export */ __webpack_require__.d(__webpack_exports__, {\r\n        /* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\r\n        /* harmony export */ });\r\n        const sum = (x, y) => x + y\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sum);\r\n\r\n\r\n/***/ })\r\n\r\n}]);\r\n```\r\n\r\n以下两个数据结构是加载 `chunk` 的关键:\r\n\r\n1. `__webpack_require__.e`: 加载 chunk，如 644 为 chunkId。该函数将使用 JSONP (`document.createElement('script')`)异步加载 chunk 并封装为 Promise。\r\n1. `self[\"webpackChunk\"].push`: JSONP cllaback，收集 modules，如 709 为 sum 模块的 id。该函数将 709 置入  `__webpack_modules__` 中。\r\n\r\n实际上，在 `webpack` 中可配置 `output.chunkLoading` 来选择加载 chunk 的方式\r\n\r\n``` js\r\nwebpack({\r\n    entry: './index.js',\r\n    mode: 'none',\r\n    output: {\r\n      filename: 'main.[contenthash].js',\r\n      chunkFilename: '[name].chunk.[chunkhash].js',\r\n      path: path.resolve(__dirname, 'dist/import'),\r\n      clean: true,\r\n      // 默认为 `jsonp`\r\n      chunkLoading: 'import'\r\n    }\r\n  })\r\n```\r\n\r\n可参考示例 [webpack 运行时代码](https://github.com/shfshanyue/node-examples/blob/master/engineering/webpack/code-spliting/example/runtime.js) 中查看加载一个 chunk 的实现。\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "I_kwDODQzyOs488Y9k",
    "number": 734,
    "title": "【Q709】core-js 是做什么用的？",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs44BO0t",
      "body": "垫片",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "Bnm89",
        "url": "https://github.com/Bnm89"
      }
    }
  },
  {
    "id": "I_kwDODQzyOs49CIKr",
    "number": 735,
    "title": "【Q710】打包器(webpack/rollup) 如何将打包后的 js 资源注入 html 中",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
        "name": "webpack"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs44GIfW",
      "body": "如果最终打包生成的 `main.js` 既没有做 code spliting，也没有做 `hash` 化路径。大可以通过在 `index.html` 中手动控制 JS 资源。\r\n\r\n``` js\r\n<body>\r\n  <script src=\"main.js\" defer />\r\n</body>\r\n```\r\n\r\n但往往事与愿违:\r\n\r\n1. `main.js` 即我们最终生成的文件带有 hash 值，如 `main.8a9b3c.js`。\r\n1. 由于长期缓存优化的需要，入口文件不仅只有一个，还包括由第三方模块打包而成的 `verdor.js`，同样带有 hash。\r\n1. 脚本地址同时需要注入 `publicPath`，而在生产环境与测试环境的 publicPath 并不一致\r\n\r\n因此需要有一个插件自动做这种事情。在 webpack 的世界里，它是 [html-webpak-plugin](https://github.com/jantimon/html-webpack-plugin)，在 rollup 的世界里，它是 [@rollup/plugin-html](https://github.com/rollup/plugins/tree/master/packages/html)。\r\n\r\n**而注入的原理为当打包器已生成 entryPoint 文件资源后，获得其文件名及 `publicPath`，并将其注入到 html 中**\r\n\r\n以 `html-webpack-plugin` 为例，它在 `compilation` 处理资源的 `processAssets` 获得其打包生成的资源。伪代码如下，可在 [mini-node:html-webpack-plugin](https://github.com/shfshanyue/mini-code/tree/master/code/html-webpack-plugin) 获得源码并运行示例。\r\n\r\n``` js\r\nclass HtmlWebpackPlugin {\r\n  constructor(options) {\r\n    this.options = options || {}\r\n  }\r\n\r\n  apply(compiler) {\r\n    const webpack = compiler.webpack\r\n\r\n    compiler.hooks.thisCompilation.tap('HtmlWebpackPlugin', (compilation) => {\r\n      // compilation 是 webpack 中最重要的对象，文档见 [compilation-object](https://webpack.js.org/api/compilation-object/#compilation-object-methods)\r\n\r\n      compilation.hooks.processAssets.tapAsync({\r\n        name: 'HtmlWebpackPlugin',\r\n\r\n        // processAssets 处理资源的时机，此阶段为资源已优化后，更多阶段见文档\r\n        // https://webpack.js.org/api/compilation-hooks/#list-of-asset-processing-stages\r\n        stage: webpack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE\r\n      }, (compilationAssets, callback) => {\r\n        // compilationAssets 将得到所有生成的资源，如各个 chunk.js、各个 image、css\r\n\r\n        // 获取 webpac.output.publicPath 选项，(PS: publicPath 选项有可能是通过函数设置)\r\n        const publicPath = getPublicPath(compilation)\r\n\r\n        // 本示例仅仅考虑单个 entryPoint 的情况\r\n        // compilation.entrypoints 可获取入口文件信息\r\n        const entryNames = Array.from(compilation.entrypoints.keys())\r\n\r\n        // entryPoint.getFiles() 将获取到该入口的所有资源，并能够保证加载顺序！！！如 runtime-chunk -> main-chunk\r\n        const assets = entryNames.map(entryName => compilation.entrypoints.get(entryName).getFiles()).flat()\r\n        const scripts = assets.map(src => publicPath + src)\r\n        const content = html({ title: this.options.title || 'Demo', scripts })\r\n\r\n        // emitAsset 用以生成资源文件，也是最重要的一步\r\n        compilation.emitAsset('index.html', new webpack.sources.RawSource(content))\r\n        callback()\r\n      })\r\n    })\r\n  }\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "I_kwDODQzyOs49GpC6",
    "number": 736,
    "title": "【Q711】打包器(webpack/rollup) 如何加载 json、image 等非 Javascript 资源",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
        "name": "webpack"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs44KbBr",
      "body": "\r\n在前端中，网页只能加载 `javascript` 脚本资源，即便在 node，也只能加载 `javascript` 与 `json` 资源。那类似 `webpack`、`rollup` 及 `vite` 这类工具是如何加载图片、JSON 资源的呢？\r\n\r\n在 `webpack` 等打包工具中，号称**一切皆是模块**。\r\n\r\n![一切皆是模块](https://cdn.jsdelivr.net/gh/shfshanyue/assets@master/src/webpack.1bgkaa8r9d7k.png)\r\n\r\n当 `webpack` 在这类打包器中，需要加载 JSON 等非 Javascript 资源时，则通过模块加载器(`loader`)将它们转化为模块的形式。\r\n\r\n以 JSON 为例:\r\n\r\n``` js\r\n// user.json 中内容\r\n{\r\n  \"id\": 10086,\r\n  \"name\": \"shanyue\",\r\n  \"github\": \"https://github.com/shfshanyue\"\r\n}\r\n```\r\n\r\n在现代前端中，我们把它视为 `module` 时，使用 `import` 引入资源。\r\n\r\n``` js\r\nimport user from './user.json'\r\n```\r\n\r\n而我们的打包器，如 `webpack` 与 `rollup`，将通过以下方式来加载 JSON 资源。\r\n\r\n这样它将被视为普通的一副 Javascript \r\n\r\n``` js\r\n// 实际上的 user.json 被编译为以下内容\r\nexport default {\r\n  \"id\": 10086,\r\n  \"name\": \"shanyue\",\r\n  \"github\": \"https://github.com/shfshanyue\"\r\n}\r\n```\r\n\r\n在 webpack 中通过 loader 处理此类非 JS 资源，以下为一个 `json-loader` 的示例:\r\n\r\n> [mini-code:json-loader](https://github.com/shfshanyue/mini-code/tree/master/code/json-loader) 中可见最小实现及示例。\r\n\r\n``` js\r\nmodule.exports = function (source) {\r\n  const json = typeof source === 'string' ? source : JSON.stringify(source)\r\n  return `module.exports = ${json}`\r\n}\r\n```\r\n\r\n那图片是如何处理的呢？\r\n\r\n``` js\r\nimport mainImage from 'main.png'\r\n\r\n<img src={mainImage} />\r\n```\r\n\r\n更简单，它将替换为它自身的路径。示例如下\r\n\r\n``` js\r\nexport default `$PUBLIC_URL/assets/image/main.png` \r\n```\r\n\r\n那如何加载一个 CSS 脚本呢？此处涉及到各种 DOM API，以及如何将它抽成一个 `.css` 文件，复杂很多，下一篇介绍。",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "I_kwDODQzyOs49ahqr",
    "number": 737,
    "title": "【Q712】打包器(webpack/rollup) 如何加载 style 样式资源",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
        "name": "webpack"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs45tW4T",
      "body": "style-loader的原理是，创建一个style标签，并且把样式资源写到这个style的innerHTML中",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "okbug",
        "url": "https://github.com/okbug"
      }
    }
  },
  {
    "id": "I_kwDODQzyOs49iWc3",
    "number": 738,
    "title": "【Q713】如何提升 webpack 构建资源的速度",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
        "name": "webpack"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs44isNG",
      "body": "使用 [speed-measure-webpack-plugin](https://github.com/stephencookdev/speed-measure-webpack-plugin) 可评估每个 loader/plugin 的执行耗时。\r\n\r\n## 持久化缓存: cache\r\n\r\n`webpack5` 内置了关于缓存的插件，可通过以下配置开启。它将 `Module`、`Chunk`、`ModuleChunk` 等信息序列化到磁盘中，二次构建避免重复编译计算，编译速度得到很大提升。\r\n\r\n``` js\r\n{\r\n  cache: {\r\n    type: 'filesystem'\r\n  }\r\n}\r\n```\r\n\r\n如对一个 JS 文件配置了 `eslint`、`typescript`、`babel` 等 `loader`，他将有可能执行五次编译，被五次解析为 AST\r\n\r\n1. `acorn`: 用以依赖分析，解析为 `acorn` 的 AST\r\n2. `eslint-parser`: 用以 lint，解析为 `espree` 的 AST\r\n3. `typescript`: 用以 ts，解析为 `typescript` 的 AST\r\n4. `babel`: 用以转化为低版本，解析为 `@babel/parser` 的 AST\r\n5. `terser`: 用以压缩混淆，解析为 `acorn` 的 AST\r\n\r\n而当开启了持久化缓存功能，最耗时的 AST 解析将能够从磁盘的缓存中获取，再次编译时无需再次进行解析 AST。\r\n\r\n**得益于持久化缓存，二次编译甚至可得到与 Unbundle 的 vite 等相近的开发体验**\r\n\r\n在 webpack4 中，可使用 [cache-loader](https://github.com/webpack-contrib/cache-loader) 仅仅对 `loader` 进行缓存。需要注意的是该 loader 目前已是 `@deprecated` 状态。\r\n\r\n``` js\r\nmodule.exports = {\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.ext$/,\r\n        use: ['cache-loader', ...loaders],\r\n        include: path.resolve('src'),\r\n      },\r\n    ],\r\n  },\r\n};\r\n```\r\n\r\n![cache-loader](https://cdn.jsdelivr.net/gh/shfshanyue/assets@master/src/cache-loader.7hlpm1nh2z40.png)\r\n\r\n## 多进程: thread-loader\r\n\r\n`thread-loader` 为官方推荐的开启多进程的 `loader`，可对 babel 解析 AST 时开启多线程处理，提升编译的性能。\r\n\r\n``` js\r\nmodule.exports={\r\n  module:{\r\n    rules:[\r\n      {\r\n        test:/\\.js$/,\r\n        use:[\r\n          {\r\n            loader: 'thread-loader',\r\n            options: {\r\n              workers: 8\r\n            }\r\n          },\r\n          'babel-loader'\r\n        ]\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\n在 `webpack4` 中，可使用 [happypack plugin](https://github.com/amireh/happypack)，但需要注意的是 `happypack` 已经久不维护了。",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "I_kwDODQzyOs49wP7g",
    "number": 739,
    "title": "【Q714】如何处理白屏错误页的监控的？",
    "body": "用户反馈白屏了，你怎么处理？",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": ""
  },
  {
    "id": "I_kwDODQzyOs491CIg",
    "number": 740,
    "title": "【Q715】简述 npm script 的生命周期",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs44yw-G",
      "body": "\r\n在 npm 中，使用 `npm scripts` 可以组织整个前端工程的工具链。\r\n\r\n``` js\r\n{\r\n  start: 'serve ./dist',\r\n  build: 'webpack',\r\n  lint: 'eslint'\r\n}\r\n```\r\n\r\n除了可自定义 `npm script` 外，npm 附带许多内置 scripts\r\n\r\n``` bash\r\nnpm install\r\n\r\nnpm test\r\n\r\nnpm publish\r\n```\r\n\r\n1. 在某个 npm 库安装结束后，自动执行操作如何处理？\r\n1. npm publish 发布 npm 库时将发布打包后文件，如果遗漏了打包过程如何处理，如何在发布前自动打包？\r\n\r\n这就要涉及到一个 npm script 的生命周期\r\n\r\n## 一个 npm script 的生命周期\r\n\r\n当我们执行任意 `npm run` 脚本时，将自动触发 `pre`/`post` 的生命周期。\r\n\r\n当手动执行 `npm run abc` 时，将在此之前自动执行 `npm run preabc`，在此之后自动执行 `npm run postabc`。\r\n\r\n``` js\r\n// 自动执行\r\nnpm run preabc\r\n\r\nnpm run abc\r\n\r\n// 自动执行\r\nnpm run postabc\r\n```\r\n\r\n[patch-package](https://github.com/ds300/patch-package) 一般会放到 `postinstall` 中。\r\n\r\n``` js\r\n{\r\n  postinstall: 'patch-package'\r\n}\r\n```\r\n\r\n而发包的生命周期更为复杂，当执行 `npm publish`，将自动执行以下脚本。\r\n\r\n+ **prepublishOnly**: 最重要的一个生命周期。\r\n+ prepack\r\n+ prepare\r\n+ postpack\r\n+ publish\r\n+ postpublish\r\n\r\n当然你无需完全记住所有的生命周期，如果你需要在发包之前自动做一些事情，如测试、构建等，请在 `prepulishOnly` 中完成。\r\n\r\n``` js\r\n{\r\n  prepublishOnly: 'npm run test && npm run build'\r\n}\r\n```\r\n\r\n## 一个最常用的生命周期\r\n\r\n`prepare`\r\n\r\n1. `npm install` 之后自动执行\r\n1. `npm publish` 之前自动执行\r\n\r\n比如 `husky`\r\n\r\n``` js\r\n{\r\n  prepare: 'husky install'\r\n}\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "I_kwDODQzyOs4-GQfp",
    "number": 741,
    "title": "【Q716】git hooks 原理是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs45C5wA",
      "body": "`git` 允许在各种操作之前添加一些 `hook` 脚本，如未正常运行则 git 操作不通过。最出名的还是以下两个\r\n\r\n+ `precommit`\r\n+ `prepush`\r\n\r\n而 `hook` 脚本置于目录 `~/.git/hooks` 中，以可执行文件的形式存在。\r\n\r\n\r\n``` bash\r\n$ ls -lah .git/hooks\r\napplypatch-msg.sample     pre-merge-commit.sample\r\ncommit-msg.sample         pre-push.sample\r\nfsmonitor-watchman.sample pre-rebase.sample\r\npost-update.sample        pre-receive.sample\r\npre-applypatch.sample     prepare-commit-msg.sample\r\npre-commit.sample         update.sample\r\n```\r\n\r\n\r\n另外  git hooks 可使用 `core.hooksPath` 自定义脚本位置。\r\n\r\n``` bash\r\n# 可通过命令行配置 core.hooksPath\r\n$ git config 'core.hooksPath' .husky\r\n\r\n# 也可通过写入文件配置 core.hooksPath\r\n$ cat .git/config\r\n[core]\r\n  ignorecase = true\r\n  precomposeunicode = true\r\n  hooksPath = .husky\r\n```\r\n\r\n在前端工程化中，`husky` 即通过自定义 `core.hooksPath` 并将 `npm scripts` 写入其中的方式来实现此功能。\r\n\r\n`~/.husky` 目录下**手动创建 hook 脚本**。\r\n\r\n``` bash\r\n# 手动创建 pre-commit hook\r\n$ vim .husky/pre-commit\r\n```\r\n\r\n在 `pre-commit` 中进行代码风格校验\r\n\r\n``` bash\r\n#!/bin/sh\r\n\r\nnpm run lint\r\nnpm run test\r\n```",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "I_kwDODQzyOs4-L8Rl",
    "number": 742,
    "title": "【Q717】如何检测出你们安装的依赖是否安全",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs45Lqiz",
      "body": "如何确保所有 `npm install` 的依赖都是安全的？\r\n\r\n当有一个库偷偷在你的笔记本后台挖矿怎么办？\r\n\r\n比如，不久前一个周下载量超过八百万的库被侵入，它在你的笔记本运行时会偷偷挖矿。\r\n\r\n![](https://cdn.jsdelivr.net/gh/shfshanyue/assets/2021-11-03/clipboard-0833.d9da75.webp)\r\n\r\n## Audit\r\n\r\n`Audit`，审计，检测你的所有依赖是否安全。`npm audit`/`yarn audit` 均有效。\r\n\r\n通过审计，可看出有风险的 `package`、依赖库的依赖链、风险原因及其解决方案。\r\n\r\n``` bash\r\n$ npm audit\r\n┌───────────────┬──────────────────────────────────────────────────────────────┐\r\n│ high          │ Regular Expression Denial of Service in trim                 │\r\n├───────────────┼──────────────────────────────────────────────────────────────┤\r\n│ Package       │ trim                                                         │\r\n├───────────────┼──────────────────────────────────────────────────────────────┤\r\n│ Patched in    │ >=0.0.3                                                      │\r\n├───────────────┼──────────────────────────────────────────────────────────────┤\r\n│ Dependency of │ @mdx-js/loader                                               │\r\n├───────────────┼──────────────────────────────────────────────────────────────┤\r\n│ Path          │ @mdx-js/loader > @mdx-js/mdx > remark-mdx > remark-parse >   │\r\n│               │ trim                                                         │\r\n├───────────────┼──────────────────────────────────────────────────────────────┤\r\n│ More info     │ https://www.npmjs.com/advisories/1002775                     │\r\n└───────────────┴──────────────────────────────────────────────────────────────┘\r\n76 vulnerabilities found - Packages audited: 1076\r\nSeverity: 49 Moderate | 27 High\r\n✨  Done in 4.60s.\r\n```\r\n\r\n你可以在我的笔记本上挖矿，但绝不能在生产环境服务器下挖矿，此时可使用以下两条命令。\r\n\r\n``` bash\r\n$ npm audit production\r\n\r\n$ yarn audit dependencies\r\n```\r\n\r\n![Audit](https://cdn.jsdelivr.net/gh/shfshanyue/assets/2021-11-03/clipboard-1904.f4c916.webp)\r\n\r\n通过 `npm audit fix` 可以自动修复该库的风险，原理就是升级依赖库，升级至已修复了风险的版本号。\r\n\r\n``` bash\r\n$ npm audit fix\r\n```\r\n\r\n`yarn audit` 无法自动修复，需要手动更新版本号，不过不够智能。\r\n\r\n[synk](https://snyk.io/) 是一个高级版的 `npm audit`，可自动修复，且支持 CICD 集成与多种语言。\r\n\r\n\r\n``` bash\r\n$ npx snyk\r\n\r\n$ npx wizard\r\n```\r\n\r\n![](https://cdn.jsdelivr.net/gh/shfshanyue/assets/2021-11-03/clipboard-1409.96de76.webp)\r\n\r\n## CI 机器人\r\n\r\n可通过 CI/gitlab/github 中配置机器人，使他们每天轮询一次检查仓库的依赖中是否有风险。\r\n\r\n![Github 机器人](https://cdn.jsdelivr.net/gh/shfshanyue/assets/2021-11-03/clipboard-4186.0dac46.webp)\r\n\r\n在 Github 中，可单独设置 `dependabot` 机器人，在仓库设置中开启小机器人，当它检测到有问题时，会自动向该仓库提交 PR。\r\n\r\n![dependabot](https://cdn.jsdelivr.net/gh/shfshanyue/assets/2021-11-03/clipboard-6581.08f1c2.webp)\r\n\r\n而它的解决方案也是升级版本号。\r\n\r\n![Github Bot 提的 PR](https://cdn.jsdelivr.net/gh/shfshanyue/assets/2021-11-03/clipboard-8617.e80863.webp)\r\n",
      "star": {
        "totalCount": 1
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "I_kwDODQzyOs4-UtTS",
    "number": 744,
    "title": "【Q718】请简述下 eslint 的作用",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs45UwzW",
      "body": "`eslint`，对代码不仅有风格的校验，更有可读性、安全性、健壮性的校验。\r\n\r\n关于校验分号、冒号等，属于风格校验，与个人风格有关，遵循团队标准即可，可商量可妥协。\r\n\r\n``` js\r\n// 这属于风格校验\r\n{\r\n  semi: ['error', 'never']\r\n}\r\n```\r\n\r\n与 `prettier` 不同，`eslint` 更多是关于代码健壮性校验，试举一例。\r\n\r\n+ `Array.prototype.forEach` 不要求也**不推荐回调函数返回值**\r\n+ `Array.prototype.map` 回调函数**必须返回一个新的值**用以映射\r\n\r\n当代码不遵守此两条要求时，通过 `eslint` 以下规则校验，则会报错。此种校验与代码健壮有关，不可商量不可妥协。\r\n\r\n``` js\r\n// 这属于代码健壮性校验\r\n{\r\n  'array-callback-return': ['error', { checkForEach: true }]\r\n}\r\n```\r\n\r\n## Rule\r\n\r\n在 `eslint` 中，使用 `Rule` 最为校验代码最小规则单元。\r\n\r\n``` js\r\n{\r\n  rules: {\r\n    semi: ['error', 'never']\r\n    quotes: ['error', 'single', { avoidEscape: true }]\r\n  }\r\n}\r\n```\r\n\r\n在 `eslint` 自身，内置大量 `rules`，比如分号冒号逗号等配置。\r\n\r\n> [eslint rules 源码位置](https://github.com/eslint/eslint/tree/main/lib/rules)\r\n\r\n校验 `typescript`、`react` 等规则，自然不会由 `eslint` 官方提供，那这些 Rules 如何维护？\r\n\r\n## Plugin\r\n\r\n如 `react`、`typescript`、`flow` 等，需要自制 `Rule`，此类为 `Plugin`，他们维护了一系列 `Rules`。\r\n\r\n在命名时以 `eslint-plugin-` 开头并发布在 `npm` 仓库中，而执行的规则以 `react/`、`flow/` 等开头。\r\n\r\n``` js\r\n{\r\n  'react/no-multi-comp': [error, { ignoreStateless: true }]\r\n}\r\n```\r\n\r\n+ [React ESLint Rules](https://www.npmjs.com/package/eslint-plugin-react)\r\n+ [TypeScript ESLint Rules](https://github.com/typescript-eslint/typescript-eslint/tree/master/packages/eslint-plugin/src/rules)\r\n\r\n## Config\r\n\r\n在第三方库、公司业务项目中需要配置各种适应自身的规则、插件等，称为 `Config`。\r\n\r\n1. 作为库发布，在命名时以 `elint-config-` 开头，并发布在 `npm` 仓库中。\r\n1. 为项目服务，在项目中以 `.eslintrc` 命名或者置于项目 package.json 中的 `eslintConfig` 字段中，推荐第二种方案。\r\n\r\n+ [eslint-config-react-app](https://github.com/facebook/create-react-app/tree/main/packages/eslint-config-react-app)\r\n+ [eslint-config-airbnb](https://github.com/airbnb/javascript/tree/master/packages/eslint-config-airbnb)\r\n\r\n以下是 `eslint-config-airbnb` 的最外层配置。\r\n\r\n``` js\r\nmodule.exports = {\r\n  extends: [\r\n    'eslint-config-airbnb-base',\r\n    './rules/react',\r\n    './rules/react-a11y',\r\n  ].map(require.resolve),\r\n  rules: {}\r\n}\r\n```\r\n\r\n在我们公司实际项目中，无需重新造轮子，只需要配置文件中的 `extends` 继承那些优秀的 `eslint-config` 即可。",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "I_kwDODQzyOs4-k0ws",
    "number": 745,
    "title": "【Q719】在项目中，如何平滑升级 npm 包",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs45hwQZ",
      "body": "# 如何对 npm 包进行升级\r\n\r\nnpm 的版本号为 `semver` 规范，由 [major, minor, patch] 三部分组成，其中\r\n\r\n+ major: 当你发了一个含有 Breaking Change 的 API\r\n+ minor: 当你新增了一个向后兼容的功能时\r\n+ patch: 当你修复了一个向后兼容的 Bug 时\r\n\r\n假设 `react` 当前版本号为 `17.0.1`，我们要升级到 `17.0.2` 应该如何操作？\r\n\r\n``` diff\r\n- \"react\": \"17.0.1\",\r\n+ \"react\": \"17.0.2\",\r\n```\r\n\r\n## 自动发现更新\r\n\r\n升级版本号，最不建议的事情就是手动在 package.json 中进行修改。\r\n\r\n``` diff\r\n- \"react\": \"17.0.1\",\r\n+ \"react\": \"17.0.2\",\r\n```\r\n\r\n**毕竟，你无法手动发现所有需要更新的 package。**\r\n\r\n此时可借助于 `npm outdated`，发现有待更新的 package。\r\n\r\n![](https://cdn.jsdelivr.net/gh/shfshanyue/assets/2021-11-10/clipboard-6918.0c6824.webp)\r\n\r\n使用 `npm outdated`，还可以列出其待更新 package 的文档。\r\n\r\n``` bash\r\n$ npm outdated -l\r\nPackage                 Current    Wanted    Latest  Location                            Depended by  Package Type     Homepage\r\n@next/bundle-analyzer    10.2.0    10.2.3    12.0.3  node_modules/@next/bundle-analyzer  app          dependencies     https://github.com/vercel/next.js#readme\r\n```\r\n\r\n## 自动更新版本号\r\n\r\n使用 `npm outdated` 虽能发现需要升级版本号的 package，但仍然需要手动在 package.json 更改版本号进行升级。\r\n\r\n此时推荐一个功能更强大的工具 `npm-check-updates`，比 `npm outdated` 强大百倍。\r\n\r\n`npm-check-updates -u`，可自动将 package.json 中待更新版本号进行重写。\r\n\r\n![](https://cdn.jsdelivr.net/gh/shfshanyue/assets/2021-11-10/clipboard-3561.1b70dc.webp)\r\n\r\n升级 [minor] 小版本号，有可能引起 `Break Change`，可仅仅升级到最新的 patch 版本。\r\n\r\n``` bash\r\n$ npx npm-check-updates --target patch\r\n```\r\n\r\n## 一点小建议\r\n\r\n1. 当一个库的 major 版本号更新后，不要第一时间去更新，容易踩坑，可再度过几个 patch 版本号再更新尝试新功能\r\n1. 当遇到 major 版本号更新时，多看文档中的 ChangeLog，多看升级指导并多测试及审计",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "I_kwDODQzyOs4-xZ_F",
    "number": 746,
    "title": "【Q720】请描述 node_modules 的目录结构(拓扑结构)",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs45uXyW",
      "body": "> 以下 mermaid 无法渲染，可移至 <https://juejin.cn/post/7030084290989948935>\r\n\r\n\r\n## 很久以前:嵌套结构\r\n\r\n在 `npmv2` 时，`node_modules` 对于各个 package 的拓扑为嵌套结构。\r\n\r\n假设: \r\n\r\n1. 项目依赖 `package-a` 与 `package-b` 两个 package\r\n1. `package-a` 与 `package-b` 均依赖 `lodash@4.17.4`\r\n\r\n依赖关系以 Markdown 列表表示:\r\n\r\n``` markdown\r\n+ package-a\r\n  + `lodash@4.17.4`\r\n+ package-b\r\n  + `lodash@4.17.4`\r\n```\r\n\r\n此时 `node_modules` 目录结构如下: \r\n\r\n``` mermaid\r\ngraph\r\n  app(node_modules) ---> A(package-a)\r\n  app          ---> B(package-b)\r\n  A            ---> C(\"lodash@4.17.4\")\r\n  B            ---> D(\"lodash@4.17.4\")\r\n```\r\n\r\n此时最大的问题\r\n\r\n1. 嵌套过深\r\n2. 占用空间过大\r\n\r\n## 现在阶段: 平铺结构\r\n\r\n在 `npmv3` 之后 `node_modules` 为平铺结构，拓扑结构如下:\r\n\r\n``` mermaid\r\ngraph\r\n  app(node_modules) ---> A(package-a)\r\n  app          ---> B(package-b)\r\n  app          ---> C(\"lodash@4.17.4\")\r\n```\r\n\r\n### *一个问题: 以下依赖最终 node_modules 结果如何？*\r\n\r\n> 可参考[该示例](https://github.com/shfshanyue/node-examples/tree/master/engineering/package/topology)\r\n\r\n依赖关系以 Markdown 列表表示\r\n\r\n``` markdown\r\n+ package-a\r\n  + `lodash@^4.17.4`\r\n+ package-b\r\n  + `lodash@^4.16.1`\r\n```\r\n\r\n答: 与上拓扑结构一致，因为二者为 `^` 版本号，他们均会下载匹配该版本号范围的最新版本，比如 `@4.17.4`，因此二者依赖一致。\r\n\r\n> 此时如果有 lock，会有一点小问题，待稍后讨论\r\n\r\nnode_modules 目录结构如下图：\r\n\r\n``` mermaid\r\ngraph\r\n  app(node_modules) ---> A(package-a)\r\n  app          ---> B(package-b)\r\n  app          ---> C(\"lodash@4.17.4\")\r\n```\r\n\r\n### *再一个问题: 以下依赖最终 node_modules 结果如何？*\r\n\r\n> 可参考[该示例](https://github.com/shfshanyue/node-examples/tree/master/engineering/package/topology-dup)\r\n\r\n``` markdown\r\n+ package-a\r\n  + `lodash@4.17.4`\r\n+ package-b\r\n  + `lodash@4.16.1`\r\n```\r\n\r\n答：package-b 先从自身 node_modules 下寻找 `lodash`，找到 `lodash@4.16.1`\r\n\r\nnode_modules 目录结构如下图：\r\n\r\n``` mermaid\r\ngraph\r\n  app(node_modules) ---> A(package-a)\r\n  app          ---> B(package-b)\r\n  app          ---> C(\"lodash@4.17.4\")\r\n  B            ---> D(\"lodash@4.16.1\")\r\n```\r\n\r\n### *再一个问题: 以下依赖最终 node_modules 结果如何*\r\n\r\n``` markdown\r\n+ package-a\r\n  + `lodash@4.0.0`\r\n+ package-b\r\n  + `lodash@4.0.0`\r\n+ package-c\r\n  + `lodash@3.0.0`\r\n+ package-d\r\n  + `lodash@3.0.0`\r\n```\r\n\r\n答：package-d 只能从自身的 node_modules 下寻找 `lodash@3.0.0`，而无法从 package-c 下寻找，此时 **lodash@3.0.0 不可避免地会被安装两次**\r\n\r\nnode_modules 目录结构如下图:\r\n\r\n``` mermaid\r\ngraph\r\n  app(node_modules) ---> A(package-a)\r\n  app          ---> B(package-b)\r\n  app          ---> C(package-c)\r\n  app          ---> D(package-d)\r\n  app          ---> X(\"lodash@4.0.0\")\r\n  C            ---> Y(\"lodash@3.0.0\")\r\n  D            ---> Z(\"lodash@3.0.0\")\r\n```\r\n\r\n\r\n## 现在阶段问题: 重复的版本依赖有什么问题？\r\n\r\n1. Install Size，安装体积变大，浪费磁盘空间\r\n1. Build Size，构建打包体积变大，浪费带宽，网站打开延迟，破坏用户体验 (PS: 支持 Tree Shaking 会好点)\r\n1. 破坏单例模式，破坏缓存，如 postcss 的许多插件将 postcss 扔进 dependencies，重复的版本将导致解析 AST 多次\r\n\r\n",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "I_kwDODQzyOs4-3kDL",
    "number": 747,
    "title": "【Q721】npm 第三方库需要提交 lockfile 吗",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "IC_kwDODQzyOs4505c4",
      "body": "\r\n## 为何有人说第三方库不需要提交 package-lock.json/yarn.lock？\r\n\r\n> 该观点仅对第三方库的 `dependencies` 有效\r\n\r\n答: 你自己项目中所有依赖都会根据 lockfile 被锁死，**但并不会依照你第三方依赖的 lockfile**。\r\n\r\n试举一例:\r\n\r\n1. 项目中依赖 `react@^17.0.2`\r\n2. 而 `react@17.0.2` 依赖 `object-assign@^4.1.0`\r\n\r\n在 React 自身的 `yarn.lock` 中版本锁定依赖如下:\r\n\r\n``` bash\r\nreact@17.0.2\r\n└── object-assign@4.1.0 (PS: 请注意该版本号)\r\n```\r\n\r\n而在个人业务项目中 `yarn.lock` 中版本锁定依赖如下:\r\n\r\n``` bash\r\nApplication\r\n└── react@17.0.2\r\n    └── object-assign@4.99.99 (PS: 请注意该版本号)\r\n```\r\n\r\n**此时个人业务项目中 `object-assign@4.99.99` 与 React 中 `object-assign@4.1.0` 不符，将有可能出现问题**。\r\n\r\n此时，即使第三方库存在 `lockfile`，但也有着间接依赖(如此时的 `object-assign`，是第三方的依赖，个人业务项目中的依赖的依赖)不可控的问题。\r\n\r\n## 第三方库如何解决潜在的间接依赖不可控问题\r\n\r\n可参考 `next.js` 的解决方案。\r\n\r\n> [next.js 源码](https://github.com/vercel/next.js/tree/canary/packages/next) 点击此处\r\n\r\n1. 将所有依赖中的版本号在 `package.json` 中锁死。可见 [package.json](https://github.com/vercel/next.js/tree/canary/packages/next/package.json)\r\n1. 将部分依赖直接编译后直接引入，而非通过依赖的方式，如 `webpack`、`babel` 等。可见目录 [next/compiled](https://github.com/vercel/next.js/tree/canary/packages/next/compiled)\r\n\r\n以下是一部分 `package.json`\r\n\r\n``` js\r\n{\r\n  \"dependencies\": {\r\n    \"@babel/runtime\": \"7.15.4\",\r\n    \"@hapi/accept\": \"5.0.2\",\r\n    \"@napi-rs/triples\": \"1.0.3\"\r\n  }\r\n}\r\n```\r\n\r\n除了参考 `next.js` 直接锁死版本号方式外，还可以仍然按照 `^x.x.x` 加勤加维护并时时更新 `depencencies`\r\n\r\n## 总结\r\n\r\n`lockfile` 对于第三方库仍然必不可少。可见 `react`、`next.js`、`webpack` 均有 `yarn.lock`。(PS: 可见 yarn 的受欢迎程度，另外 vue3 采用了 pnpm)\r\n\r\n1. 第三方库的 `devDependencies` 必须锁定，这样 Contributor 可根据 lockfile 很容易将项目跑起来。\r\n2. 第三方库的 `dependencies` 虽然有可能存在不可控问题，但是可通过锁死 `package.json` 依赖或者勤加更新的方式来解决。",
      "star": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  }
]